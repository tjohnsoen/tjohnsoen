#!/bin/bash
#set -x
# Script to install databases with on EXADATA  
# 
# 1.0.0   2015-06-30 asger.solvang@nordea.com    Initial version
# 1.0.1   2015-07-03 asger.solvang@nordea.com    First "working" version
# 1.0.2   2015-07-06 asger.solvang@nordea.com    First released version
# 1.0.3   2015-07-07 asger.solvang@nordea.com    Added nls_length_semantics option to command line (-nlsLengthSemantics)
# 1.0.4   2015-07-08 asger.solvang@nordea.com    Added dg_broker_config_file1 and dg_broker_config_file2
#                                                rman service needs to be defined as primary,physical_standby
#                                                Check for CHAR was wrong
# 1.0.5   2015-07-10 asger.solvang@nordea.com    Changed handling of custom scripts
# 1.0.6   2015-07-15 asger.solvang@nordea.com    Added small,medimum,large and modified parameters. Also added DB_CACHE_SIZE 
# 1.0.7   2015-08-13 asger.solvang@nordea.com    Fixed wrong setup of dg_broker_config_file2
# 1.0.8   2015-08-25 asger.solvang@nordea.com    Fixed handling on new database types
# 1.0.9   2015-08-31 asger.solvang@nordea.com    Now sets prerred instances on services correct
# 1.0.10  2015-09-01 asger.solvang@nordea.com    Added help
# 1.0.11  2015-09-02 asger.solvang@nordea.com    Added automatically finding the correct ORACLE AGENT home
# 1.0.12  2015-09-04 asger.solvang@nordea.com    Now using obfusticated passwords
# 1.0.13  2015-09-10 asger.solvang@nordea.com    Better way to find agent home as it seems to be broken on some exadatas
# 1.0.14  2015-09-18 asger.solvang@nordea.com    Added streams_pool_size
# 1.0.15  2015-09-22 asger.solvang@nordea.com    Added Template as parameter (not to be used yet)
#                                                Fixed also some wrong memory parameters, java_pool_size,
#                                                db_cache_size,shared_pool_size,large_pool_size,streams_pool_size
#                                                use fix_tiny_memory_before_20150922.sql to fix existing ones
# 1.0.16  2015-09-22 asger.solvang@nordea.com    Added help for -nlsLengthSemantics  
# 1.0.17  2015-10-01 asger.solvang@nordea.com    Changed Tiny to allow for two instances (was 1) and removed the check on running on only one instance
#                                                Also added that standard service is runing on 1 random instance
#
# 1.0.18  2015-10-02 asger.solvang@nordea.com    Added more report output to tell more precisely what has been created, fixed java_pool_size in large 
# 1.0.19  2015-10-20 asger.solvang@nordea.com    Started adding more comprehensive tracking of what have been installed (not enabled) 
# 1.0.20  2015-10-20 asger.solvang@nordea.com    Added maxsize settings for various tablespaces 
# 1.0.21  2016-01-05 asger.solvang@nordea.com    Added DB_RECOVERY_FILE_DEST_SIZE_MB for each database type
# 1.0.22  2016-01-05 asger.solvang@nordea.com    Added + in front of parameter value to db_recovery_file_dest (+$ASM_RECO_DISK_GROUP)
# 1.0.23  2016-01-05 asger.solvang@nordea.com    Added micro for testing purposes
# 1.0.24  2016-01-20 asger.solvang@nordea.com    Added more testing configuration
# 1.0.25  2016-01-28 asger.solvang@nordea.com    First version that support 12c
# 1.0.26  2016-02-01 asger.solvang@nordea.com    Small textual changes
# 1.0.27  2016-02-08 asger.solvang@nordea.com    Fixed PGA_AGGREGATE_LIMIT = 3 * PGA_AGGREGATE_TARGET fro 12c
# 1.0.28  2016-02-12 asger.solvang@nordea.com    Wong init.ora parameter name for PGA_AGGREGATE_LIMIT made dbca fail
# 1.0.29  2016-03-14 asger.solvang@nordea.com    Added possibility to call specific scripts depending on major db version. Used for running datapatch on 12c
#                                                Increased SHARED_POOL_SIZE memory for micro setup
# 1.0.30  2016-08-11 asger.solvang@nordea.com    Added possibility to use shared TNS_ADMIN
# 1.0.31  2016-08-12 asger.solvang@nordea.com    Minor changes
# 1.0.32  2016-11-22 asger.solvang@nordea.com    Added data center site
# 1.0.33  2016-11-30 asger.solvang@nordea.com    Rewrote as nddbctl
# 1.0.34  2016-11-30 asger.solvang@nordea.com    Changed a couple of paths
# 1.0.35  2016-11-30 asger.solvang@nordea.com    Changed a another set of paths and lower database names for files
# 1.0.36  2016-12-01 asger.solvang@nordea.com    Added check of data center unique number
# 1.0.37  2016-12-02 asger.solvang@nordea.com    Added delete database
# 1.0.38  2016-12-02 asger.solvang@nordea.com    Fixed that delete database did not work for 11.2.0.4 databases
# 1.0.39  2016-12-02 asger.solvang@nordea.com    Added seeting DB_PERFORMANCE_PROFILE on 12c databases and commented it out as it did not work
# 1.0.40  2017-01-04 asger.solvang@nordea.com    Missed some exports when deleting db's
# 1.0.41  2017-01-04 asger.solvang@nordea.com    Changed deafault nllengthsemnatics help text to show char is default
# 1.0.42  2017-01-06 asger.solvang@nordea.com    using database uniquename where relevant
# 1.0.43  2017-01-11 asger.solvang@nordea.com    Preparing for crating standby ready empty databases
# 1.0.44  2017-01-14 asger.solvang@nordea.com    Now can better clean up database when delting them
# 1.0.45  2017-01-14 asger.solvang@nordea.com    Added ORACLE_BASE before dbca as it seems like that was needed
# 1.0.46  2017-01-14 asger.solvang@nordea.com    Renamed diretory that logs ar put in
# 1.0.47  2017-01-14 asger.solvang@nordea.com    Minor typo
# 1.0.48  2017-01-14 asger.solvang@nordea.com    Tns was not called correctly
# 1.0.49  2017-01-15 asger.solvang@nordea.com    Now allow database unique name when creating databases. Will extract site etc form that name plus ficxed wrong year in comments
# 1.0.50  2017-01-15 asger.solvang@nordea.com    Now supports distribution of password files for 11.x databases
# 1.0.51  2017-01-16 asger.solvang@nordea.com    Small textual updates
# 1.0.52  2017-01-18 asger.solvang@nordea.com    Added more rigid database name testing
# 1.0.53  2017-01-19 asger.solvang@nordea.com    Now adds directory for backups
# 1.0.54  2017-01-19 asger.solvang@nordea.com    Updated version string
# 1.0.55  2017-02-06 asger.solvang@nordea.com    Bug in how UNIQUE SITE NUMBER was calculated fron database unique name plus mkdir rman directories got -p
# 1.0.56  2017-02-10 asger.solvang@nordea.com    Updated help text and corrected spelling errors
# 1.0.57  2017-03-30 asger.solvang@nordea.com    Added --skipEmConfiguration to documentation
# 1.0.58  2017-04-18 asger.solvang@nordea.com    Now modifies standby database in cluster registry to be registred as a 'PHYSICAL_STANDBY' database
# 1.0.59  2017-06-08 asger.solvang@nordea.com    Print extra step when doing Dataguard, # CONFIGURE SNAPSHOT CONTROLFILE NAME TO '+DATAC2/isoems1h/CONTROLFILE/snapcf_isoems1h.f' ;
# 1.0.59.1 2017-06-08 asger.solvang@nordea.com   Only create one member got standby redo log groups
# 1.0.60  2017-03-01 asger.solvang@nordea.com    Preparing 12.2
# 1.0.61  2017-08-08 asger.solvang@nordea.com    Preparing 12.2 even more
# 1.0.62  2017-08-11 asger.solvang@nordea.com    First 12.2 container version taht does something right
# 1.0.63  2017-08-31 asger.solvang@nordea.com    Preparing 12.2 for container
# 1.0.64  2017-09-08 asger.solvang@nordea.com    More sql scripts for container
# 1.0.65  2017-09-08 asger.solvang@nordea.com    Error in creating standby logs, missing ''
# 1.0.66  2018-01-09 asger.solvang@nordea.com    Creates two control files in "DATA" and redo files in "DATA". Don't use RECO because of IO pressure problems on Exadata
# 1.0.67  2018-01-10 asger.solvang@nordea.com    Removed some RMAN commands as they we not needed for duplicating
# 1.0.68  2018-01-15 asger.solvang@nordea.com    Added -XX:MaxPermSize=128M to dbca to avoid Bug 21121578  
# 1.0.69  2018-01-16 asger.solvang@nordea.com    Added demultiplex standbylogs and now default is not to register with em   
# 1.0.70  2018-01-17 asger.solvang@nordea.com    Removed thread from standby logs and colred dataguard output
# 1.0.71  2018-01-17 asger.solvang@nordea.com    AUDIT Trail changed for dm11-dm14 to DB,EXTENDED
# 1.0.72  2018-01-18 asger.solvang@nordea.com    renamed dontSkipEmConfiguration to -registerWithEm  and fixed demultiplex standbylog
# 1.0.73  2018-02-02 asger.solvang@nordea.com    Redo logs were multiplexed on data and reco, should be on data, data and control files on data only. Fixed for 12.2
# 1.0.74  2018-02-06 asger.solvang@nordea.com    Fixed wrong deletion of standby logs  
# 1.0.75  2018-02-06 asger.solvang@nordea.com    Added default template for 12.2 container database and fixed 12.2 wrong template selection  
# 1.0.76  2018-02-07 asger.solvang@nordea.com    Handling sysdg,syskm and sysbackup users  
# 1.0.77  2018-02-13 asger.solvang@nordea.com    Added rman commands when creating database  
# 1.0.78  2018-03-06 asger.solvang@nordea.com    Now Creating standby logs with thead again as it gave warning in dgmgrl not to have threads   
# 1.0.79  2018-03-08 asger.solvang@nordea.com    Rewrote handling database types and container to be able overwrite parameters if -createAsContainer is specified   
# 1.0.80  2018-03-06 asger.solvang@nordea.com    Now Creating standby logs with thead again as it gave warning in dgmgrl not to have threads   
# 1.0.81  2018-05-22 asger.solvang@nordea.com    Allowed posibilty to specify  --ignorePreReqs to get arround issues with latest 12.2 patchset  
# 1.0.82  2018-06-07 asger.solvang@nordea.com    More support for variable sized databases  
# 1.0.83  2018-06-14 asger.solvang@nordea.com    Fixed issue when no rman directories specified  
# 1.0.84  2018-06-14 asger.solvang@nordea.com    Rewrote handling of container databases
# 1.0.85  2018-06-29 asger.solvang@nordea.com    Switched to search for CRS="true" to find grid home and changes to make it work in dev environment
# 1.0.86  2018-06-29 asger.solvang@nordea.com    parallel_max_servers should be 5*cpu
# 1.0.87  2018-09-01 asger.solvang@nordea.com    Updating to 18
# 1.0.88  2018-09-05 asger.solvang@nordea.com    Updating Backup settings a little
# 1.0.89  2018-09-05 asger.solvang@nordea.com    Change db_files to always be 4000, gives problems otherwise for 18 rac
# 1.0.90  2018-09-06 asger.solvang@nordea.com    Add dependency to cluster shared file systems
# 1.0.91  2018-09-14 asger.solvang@nordea.com    Changed RMA setting do turn of backup optimazions
# 1.0.92  2018-09-14 asger.solvang@nordea.com    Added creaing pdb's
# 1.0.93  2018-09-14 asger.solvang@nordea.com    Demultiplex diden't handle new DISK groups correctly
# 1.0.94  2018-10-01 asger.solvang@nordea.com    Added rman function
# 1.0.95  2018-10-08 asger.solvang@nordea.com    Added duplicate and finish standby
# 1.0.96  2018-10-08 asger.solvang@nordea.com    Fxed issue with duplicate where SID was not selected correctly
# 1.0.97  2018-10-22 asger.solvang@nordea.com    Better help when creating PDB's (Data guard services plus tnsnames entry
# 1.0.98  2018-10-30 asger.solvang@nordea.com    Added possibility to us a file created by the unplug command (ending in .pdb)
# 1.0.99  2018-11-09 asger.solvang@nordea.com    Added --nlsLengthSemantics to pdb create
# 1.0.100 2018-11-09 asger.solvang@nordea.com    Added --pdbFriendlyName and checks
# 1.0.101 2018-11-14 asger.solvang@nordea.com    Added  harsden pdb and an option to not initialy harden the pdb's created
# 1.0.102 2018-11-23 asger.solvang@nordea.com    Added  Possibility to create non al32utf databases in data guard database taht is al32utf8 and added sysbackup privilege to all containers for sysbackup user
# 1.0.103 2018-11-27 asger.solvang@nordea.com    Fixed that snaphot name was changed to snapshot_gv$services, made dgfinish not able to find defined services
# 1.0.104 2018-12-05 asger.solvang@nordea.com    More errorchecking and some typos corrected
# 1.0.105 2018-12-06 asger.solvang@nordea.com    Added the extra admin_service to create pdb
# 1.0.106 2018-12-13 asger.solvang@nordea.com    Fixed varios "wrong" ways to find an active instance and the related node
# 1.0.107 2018-12-13 asger.solvang@nordea.com    Node selection copy/pastes was wrong
# 1.0.108 2018-12-18 asger.solvang@nordea.com    Usage of DB_ORACLE_HOME was wrong and had to be fixed
# 1.0.109 2019-01-04 asger.solvang@nordea.com    delete databse did not find a node correctly
# 1.0.110 2019-01-07 asger.solvang@nordea.com    Nov gives syskm a password
# 1.0.111 2019-02-01 asger.solvang@nordea.com    Admin service not created correctly Should be created to run on both primary and standby
# 1.0.112 2019-02-07 asger.solvang@nordea.com    Added datapatch call
# 1.0.113 2019-03-28 asger.solvang@nordea.com    Changed dbsnmp password to work with 10g clients (emagent)
# 1.0.114 2019-03-26 asger.solvang@nordea.com    Added .world to tnsnames.ora entry and addet --useProfile and did changes to standby creation/recreation (wont automatically switch over unless told by option)
# 1.0.115 2019-05-24 asger.solvang@nordea.com    Working on patching features - still work in progress do not use
# 1.0.116 2019-06-04 asger.solvang@nordea.com    Fixed wrong detection of services was existing
# 1.0.117 2019-06-17 asger.solvang@nordea.com    Finished work on initial DB patching , added some logging to /clustershare/nddbctl/log/dbpatch
# 1.0.118 2019-06-27 asger.solvang@nordea.com    Added work srround for SR 3-20154033281 : Starting a RAC database don't - always - start the services for the databases
# 1.0.119 2019-07-01 asger.solvang@nordea.com    Added option --dontReloadListener to avoid reloading the listener when patching
# 1.0.120 2019-08-05 asger.solvang@nordea.com    Fixed create services
# 1.0.121 2019-08-06 asger.solvang@nordea.com    Added help text for create services and deletion of restore points in pluggables
# 1.0.122 2019-08-06 asger.solvang@nordea.com    Patching now works difeent in dryRun and fixes to dgmgrl work. Started adding switchover functionality
# 1.0.123 2019-08-20 asger.solvang@nordea.com    Adding checks before switchover
# 1.0.124 2019-08-26 asger.solvang@nordea.com    Had to add extra checks to ensure Data Guard was running OK
# 1.0.125 2019-08-26 asger.solvang@nordea.com    Fixed issue with pdb create and waiting time in switchover
# 1.0.126 2019-08-29 asger.solvang@nordea.com    Added recompile to snapshot services and added coloring and some extra sanity checks while preparing to switchover
# 1.0.127 2019-09-02 asger.solvang@nordea.com    rewrote switchover to be more "robust" and to "bang out" fast in case Data Guard has serius problems, also increased some times use and made more checks
# 1.0.128 2019-09-03 asger.solvang@nordea.com    added data guard property checks and autofix for that plus many updates
# 1.0.129 2019-09-06 asger.solvang@nordea.com    Made prepare standby "workable"
# 1.0.130 2019-09-09 asger.solvang@nordea.com    Changed order of checks to catch more important ones first
# 1.0.131 2019-09-16 asger.solvang@nordea.com    Changed to use common library, and added status dataguard
# 1.0.132 2019-09-16 asger.solvang@nordea.com    Fixed that we now try to forcefuly shutdown database when patching
# 1.0.133 2019-10-01 asger.solvang@nordea.com    Retyr datapatch two times, changes to BL schema
# 1.0.134 2019-10-01 asger.solvang@nordea.com    Tried to fix issue with accouns having default password
# 1.0.135 2019-10-25 asger.solvang@nordea.com    Changed way to create pdb's to enable datapatch earlier as it failed with newer home and seed files
# 1.0.136 2019-10-31 asger.solvang@nordea.com    Added way to create plug file
# 1.0.137 2019-12-18 asger.solvang@nordea.com    Added applyinstances='ALL' to dataguard configuration
# 1.0.138 2020-02-07 asger.solvang@nordea.com    Added that we understand the new exadata naming convention db-e*
# 1.0.139 2020-02-14 asger.solvang@nordea.com    Had an issue with pdb$seed showing up in mising files for tablespacesRAPWD
# 1.0.140 2020-03-14 asger.solvang@nordea.com    Added option to skip tnsnames.ora and listener update (used for special purposes)
# 1.0.141 2020-03-24 asger.solvang@nordea.com    Changed system password for prod systems
# 1.0.141.1 2020-03-30 asger.solvang@nordea.com    Did not support pdb creation in F databases
# 1.0.143 2020-03-31 asger.solvang@nordea.com    More updates for NON RAC databases
# 1.0.144 2020-04-20 asger.solvang@nordea.com    Fixing dgfinish_pdb for non rac databases and create_services and switch_database
# 1.0.145 2020-04-28 asger.solvang@nordea.com    Added check for creating PDB's only on primary
# 1.0.146 2020-05-04 asger.solvang@nordea.com    Issues with _ parameters in autofix
# 1.0.147 2020-05-05 asger.solvang@nordea.com    Added checks of pdbs and fixes if checks are wrong
# 1.0.148 2020-05-12 asger.solvang@nordea.com    Working on initial 19 support
# 1.0.149 2020-05-28 asger.solvang@nordea.com    Trying to avoid issues with default password security alarms
# 1.0.150 2020-06-10 asger.solvang@nordea.com    Added standbys option
# 1.0.151 2020-06-30 asger.solvang@nordea.com    standbys option was not working
# 1.0.152 2020-06-30 asger.solvang@nordea.com    Removed applyinstances=all
# 1.0.153 2020-08-11 asger.solvang@nordea.com    parallel_force_local = TRUE p√• 19c container databaser for at reducere antallet af ORA-12850 fejl - Martin request plus plus startet adding nddbctl setressources
# 1.0.154 2021-05-31 martinafd4983.jensen@nordea.com add dbupgrade when characterset seed databases ar to be used


# Use common library
source /var/lib/ndcommon/ndcommon

# Used to trim for whitespace in front and in back - remove when ndcommon is updated
#trim() {
#    local var="$*"
#    # remove leading whitespace characters
#    var="${var#"${var%%[![:space:]]*}"}"
#    # remove trailing whitespace characters
#    var="${var%"${var##*[![:space:]]}"}"   
#    printf '%s' "$var"
#}

# TODO much more error checking
# TODO MAybe set snapshot control file name in RMAN to "clustered" file system as duplicate does not work if we run active on multiple instancers
# Maybe use for getting IB adresses
#  $GRID_HOME/bin/oifcfg getif # Get all interfaces
#  ip addr show ib0 | grep 'state UP' -A2 | tail -n1 | awk -F'[/ ]+' '{print $3}' # Gets first IP
# Sample call ./nddbctl create database --oracleHome /u01/app/oracle/product/12.2.0.1/db --databaseType container --databaseUniqueName c0001s1h --runOnNodes dm00db01,dm00db02 --template nordea_exadata_container_12201_v1.0.dbt --skipEmConfiguration


SVERSION="1.0.154"
# Used for timestamps in files etc
now=$(date +"%F_%T")
echo "   INFO: Script version $SVERSION (${now})"
# Where we can get the dbca logs
dbca_logs_directory="/u01/app/oracle/cfgtoollogs/dbca"
# name of the script
script_name=${0##*/}
# File for various log stuff
#log_file="/var/log/${script_name}.log"
log_file=/dev/null
# Save the command line parameters
CMD_LINE_PARAMS=$*
# Location of a clustered tnsnames.ora. If the file tnsnames.ora exists in this directory we assume that databases uses a shared TNS_ADMIN
# In this case we add also TNS_ADMIN environment to the cluster configuratiomn for the database we create
# and the variable USING_SHARED_TNS_ADMIN will be set to "Y" 
# TBD
CLUSTERED_TNS_ADMIN=/clustershare/network/admin
# LOg files are put here
CLUSTERED_LOG_LOCATION=/clustershare/nddbctl/log
# Log files for database patching are put here
DBPATCH_CLUSTERED_LOG_LOCATION=/clustershare/nddbctl/log/dbpatch
# Log files for database switchover are put here
SWITCHOVER_CLUSTERED_LOG_LOCATION=/clustershare/nddbctl/log/switchover
# Local log files to be moved after creation
LIB_LOG_LOCATION="/var/lib/nddbctl/log"
# Location of oratab used to find the GRID ORACLE_HOME later
ORA_TAB=/etc/oratab	
# Where is oraInst.loc file. Used for finding inventory and later agent
ORA_INST_LOC_POSSIBLE_LOCATIONS=("/etc/oraInst.loc" "/u01/app/oracle/product/agent/core/12.1.0.3.0/oraInst.loc" "/u01/app/oracle/product/agent/core/12.1.0.5.0/oraInst.loc")
# How to find disk groups in ASM - remember escape $ with 1 slash
ASM_DISK_GROUPS_SQL="set heading off
set feedback off
select name
from v\\\$asm_diskgroup;
"
# How to find if database is CDB
IS_DB_CDB_SQL="set heading off
set feedback off
select cdb
from v\\\$database;
"
# Can we find primary_db_unique_name where role is standby - if yes then we are a standby 
PRIMARY_DB_NAME_ON_STANDBY_SQL="set heading off
set feedback off
select primary_db_unique_name from v\\\$database
where database_role='PHYSICAL STANDBY';
"
# Can we find db_unique_name where role is primnary - if yes then we are a primary 
PRIMARY_DB_NAME_ON_PRIMARY_SQL="set heading off
set feedback off
select db_unique_name from v\\\$database
where database_role='PRIMARY';
"

# Number of PDB's in CDB
NUMBER_OF_PDBS_IN_CDB_SQL="set heading off
set feedback off
select count(*) from v\\\$pdbs where NAME<>'PDB\\\$SEED';
"

# Extra SQL to set dg and backup user
#alter user sysdg identified by xxx;
#alter user sysdg account unlock;
#alter system set redo_transport_user=sysdg scope=both sid='*';
#alter user sysbackup identified by xx;
#alter user sysbackup account unlock;
#alter user syskm identified by xxx;
#alter user syskm account unlock;
# Issue dev rman coommands
RMAN_SETUP="N"
# RMAN RETENTION policy 
RMAN_RETENTION_POLICY_PROD=14
RMAN_RETENTION_POLICY_PREPROD=7
RMAN_RETENTION_POLICY_TEST=7
RMAN_RETENTION_POLICY_DEV=1
# Default skip em configuration
SKIP_EM_CONFIGURATION="Y"
# Default auditing
AUDIT_TRAIL="XML,EXTENDED"
# Default datacenter running unique number
DATACENTER_UNIQUE_NUMBER=1
# Default characterset
CHARACTERSET=AL32UTF8
# Default national characterset
NATIONAL_CHARACTERSET=AL16UTF16
# Default nls_length_semantics
NLS_LENGTH_SEMANTICS=char
# Location of where the templates are located
#COMMON_TEMPLATES_DIRECTORY=/zfssa/rmantest/backup1/dbtp/exadata/templates
#COMMON_TEMPLATES_DIRECTORY=/clustershare/tools/dbca/templates
# Used while testing
#COMMON_TEMPLATES_DIRECTORY=/home/oracle/g48642/templates
# Should point to where the script is located right now
#COMMON_TEMPLATES_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
COMMON_LIB_DIRECTORY="/var/lib/nddbctl"
COMMON_TEMPLATES_DIRECTORY="${COMMON_LIB_DIRECTORY}/templates"
# Database will default be multiple instances enabled on multiple hosts
#SINGLE_INSTANCE="N"
# This is work in progreaa (logging)
# This will be used as unique id when logging info 
LOG_ID=$(date +%s%N)
# This is where we will put the final "log" and artifacts that was used to create the database
LOG_DIRECTORY=${CLUSTERED_LOG_LOCATION}/${LOG_ID}
# Database will default have no DG enabled - not implemented yet. Manual process
USE_DATA_GUARD="N"
# Split between SGA and PGA
SGA_PERCENT=72
# One GB in bytes
ONE_GB_IN_BYTES=$((1024*1024*1024))
# One MB in bytes
ONE_MB_IN_BYTES=$((1024*1024))
# Split between SGA/PGA
SGA_PERCENT=72
# Default Template for 11 and 12 versions
#TEMPLATE_112=nordea_exadata_11204_v1.0.dbt
#TEMPLATE_121=nordea_exadata_12102_v1.0.dbt
#TEMPLATE_122=nordea_exadata_12201_v1.0.dbt
#TEMPLATE_122_CONTAINER=nordea_exadata_container_12201_v1.0.dbt
#TEMPLATE_18=nordea_exadata_18000_v1.0.dbt
#TEMPLATE_18_CONTAINER=nordea_exadata_container_18000_v1.0.dbt
# New method to support standard
TEMPLATE_112=11204_v1.0.dbt
TEMPLATE_121=12102_v1.0.dbt
TEMPLATE_122=12201_v1.0.dbt
TEMPLATE_122_CONTAINER=container_12201_v1.0.dbt
TEMPLATE_18=18000_v1.0.dbt
TEMPLATE_18_CONTAINER=container_18000_v1.0.dbt
TEMPLATE_19=19000_v1.0.dbt
TEMPLATE_19_CONTAINER=container_19000_v1.0.dbt
# User needed for 12c dbca em registration
AGENT_REGISTRATOR_USERNAME="AGENT_REGISTRATOR"
AGENT_REGISTRATOR_OMS_PORT="7802"
AGENT_REGISTRATOR_OMS_HOST="ap-oem1p.oneadr.net"
# User neede for 12c dbca em registration on test cluster rac4
TEST_AGENT_REGISTRATOR_USERNAME="AGENT_REGISTRATOR"
TEST_AGENT_REGISTRATOR_OMS_PORT="7799"
TEST_AGENT_REGISTRATOR_OMS_HOST="server40.leva.dk"
# HASHED passwords
SANDBOX_SYS_PASSWORD="S:E224D8A8655ED13BEFB14ECAFC384BE10E71DBBDE00DAD7F54C7E3DE061B;T:99FC64CF33535D2602DD13124416F64DB7F928FFF0F2781AD81DEBBDE91E8EB62603B07F0501BF2B1BE3C9E7BA0263EE582472181750D97D196CD85346BBBC38AF12539E0D13A5516BD95881D0BA7D56"
SANDBOX_SYSTEM_PASSWORD="S:AFA83FBEAF305EA55A5FE22B72C0530D0664B2947564069428F013AEFDCB;T:EE90788C8B2710AB1C9F19598A14C158F20C6B8F27F43E3BCEBD21E4F5BD97B172B79F3E58A85FF8B67D303B6F1AEB77E64D7D7C4D4D0045A6CBEA549F01992E37F2B700053858EF1F6E6EC233E7B2E4"
SANDBOX_DBSNMP_PASSWORD="S:9AF46D8A22DE82C65DDE4AA115E4BC69E263EB1DCD3378D51D42E9DCE5D3;T:6C3BB820639DAF9B1AC397B10848085FC3402CE9D98931418E3AD311AF1EB52DCC1C9E5CC00F5B0C2B77599960CD9B0B0D4D1E3A01B2D5A4B22EED7C50F51956532721A699088DD91AD94BDA659FF736;8E7C0FBF423E05CF"
SANDBOX_PDB_ADMIN_PASSWORD="S:A1BC03E650E7A639DEF66D046385CD57E4086FB081FD302CAFC887FCD94F;T:C6B56E8A13389F530058AE114ADB9F553DB18EA89430B67AA45128DA9391402741F356B0ACB399D695E16F925E79207CD18AF6E22D4E0B59E6C2379D22728A08A4CC224D59940E8583BFD914138E07F5"
SANDBOX_SYSDG_PASSWORD="S:E7823F912EA49BC8B6D634DC82D235229D7427B4A4C1F5503C83A9412185;T:3FE9A5747D4B3E7D08D4951AA364CB40364B907743BAC7C84BB6D92D8E0F495C2937B9A8353F7CD5272C835F4C550B169B8B7C09FF27BBDD0C345570ED2AA16760DDFCBBCB4F21F5A6C46E6CD37E2D56"
SANDBOX_SYSKM_PASSWORD="S:A192B3624EE2C5704DA78A4F9B9F8F8FDD90DF83D9D8F1E12B5C902916AB;T:C04036D114D5A55A5A72B376FEB34FD53223C9C43BDC73FDD1FA2203EC215FA4B57A021BE4901F3B5E6E9D0FC6226178197DF6F7E7A702F0AA25FFB4DD8E37E988EFB2E3DCEF6C4AF46079E1A6253B70"
SANDBOX_SYSBACKUP_PASSWORD="S:1E35399A3FB5C83B24C9E0309AEAFC2B96AE5E7E85D93E4C58145E592744;T:2B54C6F867C831198DC520939C4E7C6B9C733C7308E3A38B97BFA46DC12E1E25BAA726BBAE5BA8FCC1D62D181A4B67239293A55F72070277E3A1D34F212FD51AE653DE847DE4637F4846C45AD879929D"
TEST_SYS_PASSWORD="S:B041C7B15176A3CB91CB9CDAD97E65281FFBDA69A066BCB1A8F49594427C;T:65F2F8B7A03304D3252FEE31C4D5599961EC41B597CEC413B6CB967A63FADE2F035B745720A25C9656E397294D5045CB7F7C06EEC3CF259DD58798BDDC256944E8F642D6B2C3CC8AAFA3B6FBF0878BEE"
TEST_SYSTEM_PASSWORD="S:FB033137B3FE9BFA984553D04E4B855AB3B540A85F14ED617D8E5313391B;T:46570A63BC287AFC529DE67E26EC896191D276A67DD7916C1EE961B8691375E4E67F3DC65A0AA086F7FCA677B96430EAACA74D5B0EF340C295B856ADF01254B5108CBAFA32B20885A471FE5AD6DF218D"
TEST_DBSNMP_PASSWORD="S:457C0F461109386744A80442D6B5A810D10321F0962204803C91A85CD7C9;T:E96E91479432479D868934BCB0DC13146EAD7C8AA0267E5664050E375522491428939CDD7D8CC6DA0E5108101D705BB8B59C3E7BC1CF5D7068E6A42363455ED19421F4377BCDEA38A58A462D9B05AC9A;20A1D6870DEC481A"
TEST_PDB_ADMIN_PASSWORD="S:3ECE1B3785270D441818F057ACD5AB074D2B3A7F9EC3B4A583AF1BE01B04;T:18715ED160924662F16728922360976E03B7430CB5CB05D87A21300F9A9DDA5EECE13FA033254ECDC08FF543233A047EA47ED5022E5029385CC3C177C46B88866AC594655AECA75628C2B09793E3FAB1"
TEST_SYSDG_PASSWORD="S:92570BB955110D573470F2636611F9BABFF0C300A974B15A464FFB3701B0;T:078F7E883868779AFCB6EADDA6FD9A44B2F18D93CD8D68144868624C04CBAF9AA29A9CEB182830A3C4EA0D922E9000081D34EFF1BB9C17E17F79165F704EA6E4D1A80478C4467C71BC256C1DE3E7C63D"
TEST_SYSKM_PASSWORD="S:947A62CF611C2920421906066C5D6C9D7B4F7CF32F03A2B7DE09035F82B5;T:08D33F0DC5FDA48D5F5C2F4A568EBECEA8E90E3E9AB338B153ACBB7D5FCCDE90CEFF66B2A9D6AE72BA3B3E05B03701685A38E345CC95D0C40ED5FC36ED3C1513F6146FF0D8A998EE856D3216BC2DDA17"
TEST_SYSBACKUP_PASSWORD="S:C7EA4CD0FF4BE0BB9B611E43BE24BF5E03386AF8C182F16EB056C0145FED;T:DC1687281B682FD69EF4916242FD242FAA3524F568C91EE1C716446A5787F1FCA2B5205765A523BF2971B3B58E5E33A5ABE7A3C3473F079A4C575CE662CBF6C869E1ACA1643B95D8F9245ACC7FF13A1B"
DEMO_SYS_PASSWORD="S:1A9114E9D187223AD50D75DDB830C1142FDB3369ACA486C6051DBEDAC43E;T:9BABDE602A3EC973D94CDEF6926647F545C91A0A113D0ADFFA79EBC6637646799F3C28BCD85372567516C82A99AAC2CA408AC4B1FDB1B725A53E59FD0BFA1E27C26E3AD12ECFC890892AB66DAFEE96D7"
DEMO_SYSTEM_PASSWORD="S:E76D87BE9AF5CA8C6E798CC7EC229D0AC4174B5AD167E37367FDF14F28F1;T:BDDDEA5D6397E6866C52130116E14EA78AD60D804FD58253D792CA2DC82C7F15602202EDF5F9EF8EB7286478B25BDCEE87E0EE0707C27F42E3760480B2CC5D56ABCF12EFC58E5858177F0B24D2BE6007"
DEMO_DBSNMP_PASSWORD="S:7A5D93E448D9E9B35FF8B5760978B7F01CC9591BDD2FB0D3D1AD20DAC95A;T:B2584533677EC15DF89FC64BEF8F02456556000DA5EE3EAEBF0B5019A8A4F78C8DF12D8A17FBF7A2E55449BDE830156EF33332DCC530441A6B37AD6D38AC37786A798E3D2AAF4732A7344A96B339C742;CC545590B4F5BFC8"
DEMO_PDB_ADMIN_PASSWORD="S:3F0041FA09325000D65787D32354CD0CA0D28FE7670F9301090C592EECD7;T:633C79DB2348024F9F4F825B9ABCEC91D1386B24979560590307B22989A094F6864E6539F7007FC243BC2DDC196214E7E2A7DA4C35DEA3644A6766A9D5531B1C21F68B1A93400C5B5FCEED7444486B69"
DEMO_SYSDG_PASSWORD="S:E7620B1C69509EB24336E1AE2DE805A095321BAA84CCA5CB3A73C75DDFA3;T:2D51A985E05F3D4E841F2F23C841B956743015DD20CE72073085D433660396A420226B8D9F79609E47C33CFBC2933987256AE55BDCC678AE2C894116ED253A8E490E34312A814CF436C57F538D13FC16"
DEMO_SYSKM_PASSWORD="S:69E2EF54004878D4FCB6D99B54EC418F38DFCA3BE03E4525D5E632ED58BC;T:6B3A0929F365C2A970CABA483DE3A0A36E09390149F9DEB1CDA52C2380211956DAA3C7D8ACEE7A7C29C43218D044E2E6883DE93DFE41CF652B3DB12C157E2418E71D0850AEEA84A8A1F0FED7088A3827"
DEMO_SYSBACKUP_PASSWORD="S:54D78EF76D7129641137162CE3A263BB48669CF9113CC87A466A6E2DA601;T:3C713906326D887026367715FD951678FA5D35FA304A3A02994B969052B0D3255F104638B29136D113C0D05D5E264E805EDED7629EC6ABD7856FA66AD6BBD0BBB77AE7598D7FD8F1E194977ECABCEAA0"
PROD_SYS_PASSWORD="S:11601908F6FFD6EAB11CABA636BE87B7161491EC454AA2ADEC3622764AA6;T:B261EA086F90A6C0B96DA33805296535DBF85C96B68DF3B1E85A4F0F3E4977C48820E02BD17E1E99B2E6EF5F6089150D1F49FAF977B6E66A15287EA4EF3AB359DAA0B75B9AC67845F0715CB83101B671"
PROD_SYSTEM_PASSWORD="S:04820614569FD5964855FC8B776F2B331526358BE40D9A5E68F25F65BF69;T:470CFC1172C4F9543AD9F65A2BB44A80566FFA19938C8FC9BC3D3F2056733563EEAA067C9B4FF6E813FC1856322862AEF657B2992EE64FE032008D9E3E930D708D2ED8C459D6C6B9C1A95CA2D8EDF053"
PROD_DBSNMP_PASSWORD="S:20167AD9C4727B85FDA1CE7A813F730275AA22758C047D8EB696F299FDD6;T:548DC5FACA2D3E1F59156CCB9BAB7E97A7EF9B45D642CA5BA667B8CD1CAD8D29B8B206090A0F7CBD48218A0596A7D0AF8D38F3ED1B539A51FD827655F52B7BDC508D5E3647192322517ACBD145ACA02A;E3A50EEDEF49E233"
PROD_PDB_ADMIN_PASSWORD="S:A36882BCCC2475E9617695B245CAF3F038343DC2CC73CB1C28D322A73981;T:7FD17D51BAD17D441A7ED0F3ACFBC38996FE281A49C573EF7FE0D9923C26236AD38837FEDD52B55B09D70FE2F8692AC5350FA918CA25B6AD409DFA5D52FE894F253113F1F79B33C91E8096D8CA86E734"
PROD_SYSDG_PASSWORD="S:FF3A5402D08761E35B3076C096389600CD1BFB55BA748273D3721A2AE3D3;T:78A37B8FAB031CE41C867F94AAF340381174994828E25BF11E7080EDF6C3A7BA5A67034401972A547B24BBE30C2C8AC38BC094F7D321972B40599F9EBD368D2B7048C4BBC761F21BB29E5BF852A69D1D"
PROD_SYSKM_PASSWORD="S:1B589B8B5D7707215E183831E7531C3E5BD229411590044346A19EB30040;T:5F34B43546792EE6527B1B43967A998CE17A793F761454A8E6FB507060CE8C26A15CB1FC653FA2D2ACAB9BF0956E7EB71EAD61CE8910067C8457E0B4DA11A61C4FF3AC8C6FC5D869DA3843D300C1C81C"
PROD_SYSBACKUP_PASSWORD="S:45044B4CCF4CA36B4B43602768C7EE5906A0279B786CB51C15A9B361BD42;T:59BBB1AFCED44C46B5A219162702D2130384C2BF712C16490FACABA7FBA666D871F501463EDD7BBA2E5847788D0B4F6805C65943B71518CBC0EC90D88752615949AD90C9352A3E585FF2DA3B62B3FB58"

# The following 2 are not used yet. Specified directly in SQL files instead
BL_PASSWORD="S:F87EF4F691D98EF8E0D8477F235D894FECE5FCC8AE84E209B393205C198C"
DBADMIN_PASSWORD="S:095BB9E38C45305422CDA6EA232B0CD5079018FC3BA7419516A2A668CDC5"
# Check for invalid components
INVALID_COMPONENTS_SQL="set heading off
set feedback off
select substr(comp_name,1,40) comp_name, status, substr(version,1,10) version 
from dba_registry
where status NOT IN ('VALID','OPTION OFF');
"
INVALID_SYS_OBJECTS_SQL="set heading off
set feedback off
SELECT owner, object_type, object_name
FROM all_objects
WHERE status = 'INVALID'
AND OWNER='SYS'
"
PDB_PLUG_IN_VIOLATIONS_SQL="set heading off
set feedback off
select name, message, time, type, status action from pdb_plug_in_violations
where
status != 'RESOLVED' and type != 'WARNING'
order by name, message;
"
# Used for preparing the primary
# Here escape $ with 3 slashes as that's needed when using it in this context
prepare_primary_sql="set serveroutput on
set heading off
set feedback off
--enable dg_broker
alter system set dg_broker_start=true scope=both;
--Add standby logs
set serveroutput on
DECLARE
  l_cnt   NUMBER;
  l_size  NUMBER;
  l_group NUMBER;
  l_thread NUMBER;
  l_sql   VARCHAR2(4096);
  l_data  varchar2(32);
BEGIN
  SELECT
    COUNT(*),
    MAX(bytes),
    MAX(GROUP#),
    MAX(thread#)
  INTO
    l_cnt,
    l_size,
    l_group,
    l_thread
  FROM
    v\\\$log;
  select value into l_data from v\\\$parameter where name = 'db_create_file_dest';
  FOR i0 IN l_group+1..l_group+l_cnt+l_thread
  LOOP
    l_sql:='alter database add standby logfile thread '||(mod(i0,l_thread)+1)||' group '||i0||
    ' '''||l_data||'(ONLINELOG)'' size '||l_size;
    BEGIN
      --dbms_output.put_line('Executing:'||l_sql);
      EXECUTE immediate l_sql;
    EXCEPTION
    WHEN OTHERS THEN
      dbms_output.put_line(l_sql||' failed with '||sqlerrm);
    END;
  END LOOP;
END;
/
"
# This is the sql that tries to demultiplex standby logs 
# Will delete RECO before DATA if both exists
demultiplex_standby_logs_sql="
set serveroutput on
DECLARE
  sql_to_execute VARCHAR2(4096);
BEGIN
  FOR stdby_files_rec IN (
    with ordered_standby_logfile as
      (
        select group#,  member,
          case 
            when member like '+DATA%' then 1 
            when member like '+RECO%' then 2
            when member like '+%_DATA%' then 1 
            when member like '+%_RECO%' then 2            
            else 3
          end cust_order
       from v\\\$logfile
       where type='STANDBY'),   
    standby_files_to_delete as
      (
        select group#,  member, cust_order
        from ordered_standby_logfile 
      minus
        select group#,  member, cust_order from 
        (
          select First_Value(member) over (partition by group# order by cust_order ) first_member,group#,member,cust_order
          from ordered_standby_logfile
          where cust_order = 1
        )
        where first_member = member
      )
    select group#,  member, cust_order from standby_files_to_delete
    )
  LOOP
    sql_to_execute:='ALTER DATABASE DROP LOGFILE MEMBER '''||stdby_files_rec.member||'''';
    BEGIN
      dbms_output.put_line('Executing: '||sql_to_execute);
      EXECUTE immediate sql_to_execute;
    EXCEPTION
    WHEN OTHERS THEN
      dbms_output.put_line('Failed with '||sqlerrm);
    END;    
  END LOOP;
END;
/
"

check_cpu_count_profile()
{
  local USE_CPU_COUNT=$1
  local USE_CPU_COUNT_PROFILE
  case ${USE_CPU_COUNT} in
    1|2|4|6|8|12|16|24|32|48|64)
      # Extract the number and build the profile name
      USE_CPU_COUNT_PROFILE="cpu_${USE_CPU_COUNT}"
      echo "$USE_CPU_COUNT_PROFILE"
      ;;
    *)
      echo "  ERROR: Parameter --useCpuCount needs to be one of [1|2|4|6|8|12|16|24|32|48|64]"
      exit 1
      ;;
  esac
}

check_sga_memory_profile()
{
  local USE_SGA_MEMORY=$1
  local USE_SGA_MEMORY_PROFILE
  case ${USE_SGA_MEMORY} in
    1gb|2gb|4gb|6gb|8gb|12gb|16gb|24gb|32gb|48gb|64gb|96gb|128gb|192gb|256gb|384gb|512gb) 
      # Extract the number and build the profile name
      USE_SGA_MEMORY_PROFILE="memory_${USE_SGA_MEMORY//gb/_gb}"
      echo "$USE_SGA_MEMORY_PROFILE"
      ;;
    *)
      echo "  ERROR: Parameter --useSGAMemory needs to be one of [1gb|2gb|4gb|6gb|8gb|12gb|16gb|24gb|32gb|48gb|64gb|96gb|128gb|192gb|256gb|384gb|512gb]"
      exit 1
      ;;
  esac
}

check_storage_capacity_profile()
{
  local USE_STORAGE_CAPACITY=$1
  local USE_STORAGE_CAPACITY_PROFILE
  case ${USE_STORAGE_CAPACITY} in
    100gb|200gb|400gb)
      # Extract the number and build the profile name
      USE_STORAGE_CAPACITY_PROFILE="storagecapacity_${USE_STORAGE_CAPACITY//gb/_gb}"
      echo "$USE_STORAGE_CAPACITY_PROFILE"
      ;;
    1tb|2tb|4tb|10tb|20tb|40tb|100tb|200tb|400tb)
      # Extract the number and build the profile name
      USE_STORAGE_CAPACITY_PROFILE="storagecapacity_${USE_STORAGE_CAPACITY//tb/_tb}"
      echo "$USE_STORAGE_CAPACITY_PROFILE"
      ;;
    *)
      echo "  ERROR: Parameter --useStorageCapacity needs to be one of [100gb|200gb|400gb|1tb|2tb|4tb|10tb|20tb|40tb|100tb|200tb|400tb]"
      exit 1
      ;;
  esac
}

check_storage_iops_profile()
{
  local USE_STORAGE_IOPS=$1
  local USE_STORAGE_IOPS_PROFILE
  case ${USE_STORAGE_IOPS} in
    100iops|1000iops|10000iops|100000iops|1000000iops|200iops|2000iops|20000iops|200000iops|2000000iops|400iops|4000iops|40000iops|400000iops|4000000iops)
      # Extract the number and build the profile name
      USE_STORAGE_IOPS_PROFILE="storageiops_${USE_STORAGE_IOPS//iops/_iops}"
      echo "$USE_STORAGE_IOPS_PROFILE"
      ;;
    *)
      echo "  ERROR: Parameter --useStorageIops needs to be one of [100iops|1000iops|10000iops|100000iops|1000000iops|200iops|2000iops|20000iops|200000iops|2000000iops|400iops|4000iops|40000iops|400000iops|4000000iops]"
      exit 1
      ;;
  esac
}

check_storage_bandwidth_profile()
{
  local USE_STORAGE_BANDWIDTH=$1
  local USE_STORAGE_BANDWIDTH_PROFILE
  case ${USE_STORAGE_BANDWIDTH} in
    1mbps|10mbps|100mbps|2mbps|20mbps|200mbps|4mbps|40mbps|400mbps)
      # Extract the number and build the profile name
      USE_STORAGE_BANDWIDTH_PROFILE="storagebandwidth_${USE_STORAGE_BANDWIDTH//mbps/_mbps}"
      echo "$USE_STORAGE_BANDWIDTH_PROFILE"
      ;;
    1gbps|10gbps|2gbps|20gbps|4gbps|40gbps)
      # Extract the number and build the profile name
      USE_STORAGE_BANDWIDTH_PROFILE="storagebandwidth_${USE_STORAGE_BANDWIDTH//gbps/_gbps}"
      echo "$USE_STORAGE_BANDWIDTH_PROFILE"
      ;;
    *)
      echo "  ERROR: Parameter --useStorageBandwidth needa to be one of [1mbps|2mbps|4mbps|10mbps|20mbps|40mbps|100mbps|200mbps|200mbps|1gbps|2gbps|4gbps|10gbps|20gbps|40gbps]"
      exit 1
      ;;
  esac
} 

check_combined_profiles()
{
  # Not used yet
  local USE_CPU_COUNT_PROFILE=$1
  local USE_SGA_MEMORY_PROFILE=$2
  local USE_STORAGE_CAPACITY_PROFILE=$3
  local USE_STORAGE_IOPS_PROFILE=$4
  local USE_STORAGE_BANDWIDTH_PROFILE=$5
} 



# Execute a command remote using sudo
sudo_execute_remote()
{
  local node=$1
  local command=$2
  echo "$command" | ssh -o 'StrictHostKeyChecking no' ${node} "cat > command.sh; chmod 777 command.sh; sudo $HOME/command.sh"
}

# Copy to a user remotely using sudo
sudo_cp_remote()
{
  local node=$1
  local localfile=$2
  local remote_file=$3
  scp $localfile $node:temp.file
  sudo_execute_remote $node "mv temp.file $remote_file"
}

sort_comma_separated_list()
{
  local list="$1"
  echo "$list" | tr , "\n" | sort | tr "\n" , | sed 's@,$@\n@'
}

convert_dgmgrl_time_to_seconds()
{
    #Try to calculate lag
    #DGMGRL_TIME="1 day(s) 14 hours 55 minutes 13 seconds"
    #DGMGRL_TIME="14 hours 55 minutes 13 seconds"
    local DGMGRL_TIME=$1
    local timelag_seconds=0
    local MATCHDAY="([0-9]*) day"
    local MATCHHOUR="([0-9]*) hour"
    local MATCHMINUTE="([0-9]*) minute"
    local MATCHSECOND="([0-9]*) second"
    if [[ $DGMGRL_TIME =~ $MATCHDAY ]];
    then
      timelag_seconds=$((timelag_seconds+BASH_REMATCH[1]*24*3600))
    fi
    if [[ $DGMGRL_TIME =~ $MATCHHOUR ]];
    then
      timelag_seconds=$((timelag_seconds+BASH_REMATCH[1]*3600))
    fi
    if [[ $DGMGRL_TIME =~ $MATCHMINUTE ]];
    then
      timelag_seconds=$((timelag_seconds+BASH_REMATCH[1]*60))
    fi
    if [[ $DGMGRL_TIME =~ $MATCHSECOND ]];
    then
      timelag_seconds=$((timelag_seconds+BASH_REMATCH[1]))
    fi 
    echo "$timelag_seconds"
}

# Used for calling SRVCTL
call_srvctl()
{
  local ORACLE_HOME="$1"
  local SRVCTL_COMMAND="$2"
  local DRY_RUN="$3"
  local txtresult
  local result
  if [ "$DRY_RUN" = "YES" ]
  then
    # Return command that would be run
    txtresult="(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl ${SRVCTL_COMMAND})"
  else
    # run Command
    txtresult=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl ${SRVCTL_COMMAND} 2>&1)
  fi
  result=$?
  echo "$txtresult"
  return $result
}

#find_databases()
#{
#  local grid_home=$(find_grid_home)
#  (export ORACLE_HOME=${db_home};${grid_home}/bin/srvctl config database)
#}

get_current_script_with_path()
{
  local MY_PATH=`dirname "$0"`
  local MY_PATH=`( cd "$MY_PATH" && pwd )`
  echo "$MY_PATH/$0"
}

# Used for calling SQL*Plus
call_sql_plus_as_sys()
{
  local NODE_NAME="$1"
  local ORACLE_HOME="$2"
  local ORACLE_SID="$3"
  local SQL="$4"
  local SQL_OPTIONS="$5"
  local DRY_RUN="$6"
  local txtresult
  local result
  if [ "$DRY_RUN" = "YES" ]
  then
    # Return command that would be run
    txtresult="ssh -o 'StrictHostKeyChecking no' $node_selected \"export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \\\"${SQL}\\\" | $ORACLE_HOME/bin/sqlplus ${SQL_OPTIONS} / as sysdba\""
  else
    # run Command
    txtresult=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${SQL}\" >>/tmp/sqlplus.log" 2>&1)
    txtresult=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${SQL}\" | $ORACLE_HOME/bin/sqlplus ${SQL_OPTIONS} / as sysdba" 2>&1)
  fi
  result=$?
  echo "$txtresult"
  return $result
}

# Used for calling DGMGRL
call_dgmgrl_as_sys()
{
  local NODE_NAME="$1"
  local ORACLE_HOME="$2"
  local ORACLE_SID="$3"
  local DGMGRL="$4"
  local DGMGRL_OPTIONS="$5"
  local DRY_RUN="$6"
  local txtresult
  local result
  if [ "$DRY_RUN" = "YES" ]
  then
    # Return command that would be run
    txtresult="ssh -o 'StrictHostKeyChecking no' $node_selected \"export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; $ORACLE_HOME/bin/dgmgrl ${DGMGRL_OPTIONS} / \\\"${DGMGRL}\\\"\"" 
  else
    # run command
    #set -x
    txtresult=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; $ORACLE_HOME/bin/dgmgrl ${DGMGRL_OPTIONS} / \"${DGMGRL}\"" 2>&1)
    #set +x
  fi
  result=$?
  echo "$txtresult"
  return $result
}
# Call with a variable in PLINGs to get count of words inside
how_many() ( set -f; set -- $1; echo $# )

## Find Grid Home - complicated as we can't assume in the future /etc/oratab will have an ASM entry
#find_grid_home()
#{
#  # Where is the file that tells us where the oracle inventory is 
#  local ORAINST_LOC="/etc/oraInst.loc"
#  # If the file is there we can try to find the ASM home
#  if [ -f $ORAINST_LOC ]
#  then
#    # Look up the oracle inventory location
#    local ORAINVENTORY_LOCATION=`cat $ORAINST_LOC 2>>/dev/null | sed -n -e 's/inventory_loc=\(.*\)/\1/p' 2>>/dev/null`
#    if [ "$ORAINVENTORY_LOCATION" != "" ]
#    then
#      # If we wound the oracle inventory location look for grid home by looking for OraGI name 
#      GRID_HOME=`grep -v ".*REMOVED=\"T" ${ORAINVENTORY_LOCATION}/ContentsXML/inventory.xml 2>>/dev/null | sed -n -e '/<HOME NAME=.*CRS="true"/s/.*LOC=\"\([^\"]*\)\".*CRS="true".*/\1/p' 2>>/dev/null`
#    fi
#  fi
#  if [ "$GRID_HOME" != "" ]
#  then
#    echo "$GRID_HOME"
#  fi
#}


# Find amount of physical memory etc and expose them as variables
calculate_machine_parameters()
{
  local host_memory_kb=`cat /proc/meminfo | grep MemTotal: | sed 's/MemTotal:[[:blank:]]*\(.*\)[[:blank:]].*/\1/'`
  # Total bytes memory in host
  (( HOST_MEMORY_BYTES = $host_memory_kb * 1024 ))
  # Number of CPU's
  HOST_CPU_COUNT=`grep -c processor /proc/cpuinfo`
  HOST_HUGEPAGES_SIZE=`cat /proc/meminfo | grep Hugepagesize: | sed 's/Hugepagesize:[[:blank:]]*\(.*\)[[:blank:]].*/\1/'`
  local hugepages_total_kb=`cat /proc/meminfo | grep HugePages_Total: | sed 's/HugePages_Total:[[:blank:]]*\(.*\)/\1/'`
  local hugepages_free_kb=`cat /proc/meminfo | grep HugePages_Free: | sed 's/HugePages_Free:[[:blank:]]*\(.*\)/\1/'`
  local memfree_kb=`cat /proc/meminfo | grep MemFree: | sed 's/MemFree:[[:blank:]]*\(.*\)[[:blank:]].*/\1/'`
  (( HOST_HUGEPAGES_TOTAL = $HOST_HUGEPAGES_SIZE * $hugepages_total_kb * 1024 ))
  (( HOST_HUGEPAGES_FREE = $HOST_HUGEPAGES_SIZE * $hugepages_free_kb * 1024 ))
  (( HOST_MEMFREE = $memfree_kb * 1024 ))
}
calculate_machine_parameters
#echo "HOST_MEMORY_BYTES=$HOST_MEMORY_BYTES"
#echo "HOST_CPU_COUNT=$HOST_CPU_COUNT"
#echo "HOST_HUGEPAGES_SIZE=$HOST_HUGEPAGES_SIZE"
#echo "HOST_HUGEPAGES_TOTAL=$HOST_HUGEPAGES_TOTAL"
#echo "HOST_HUGEPAGES_FREE=$HOST_HUGEPAGES_FREE"
#echo "HOST_MEMFREE=$HOST_MEMFREE"

# Nordea environment file
NORDEA_ENVIRONMENT_FILE="/etc/nordea_environment.conf"
# Used to color text
cecho() {
  local code="\033["
  case "$1" in
    black  | bk) color="${code}0;30m";;
    red    |  r) color="${code}1;31m";;
    green  |  g) color="${code}1;32m";;
    yellow |  y) color="${code}1;33m";;
    blue   |  b) color="${code}1;34m";;
    purple |  p) color="${code}1;35m";;
    cyan   |  c) color="${code}1;36m";;
    gray   | gr) color="${code}0;37m";;
    *) local text="$1"
  esac
  [ -z "$text" ] && local text="$color$2${code}0m"
  echo -e "$text"
}

get_configuration_parameter()
{
  local parameter="$1"
  grep "^${parameter}=" ${NORDEA_ENVIRONMENT_FILE} >>${log_file} 2>&1 && sed -n "s/^${parameter}[[:space:]]*=[[:space:]]*\(.*\)/\1/p" ${NORDEA_ENVIRONMENT_FILE} || echo ""     
}

prepare_rman()
{
  local database_unique_name=$1
  get_environment_names
  # Check that database exists and find Oracle home
  ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
  if [ "$ORACLE_HOME" = "" ]
  then
    cecho r "  ERROR: Cam't find database $DATABASE_UNIQUE_NAME on this cluster"
    exit 1
  fi
  make_backup_directories_etc $database_unique_name 
}


# Also generate rman specific disk settings
make_backup_directories_etc()
{
  local channel_counter=0
  local directory_counter=0
  local extra_channel_runs=0
  local database_unique_name=$1
  local standby_database_unique_name=$2
  local backup_directories=$(get_configuration_parameter "nordea_rman_directories")
  # If character set - has been checked
  case ${database_unique_name:${#database_unique_name} -3:1} in
    p) RMAN_RETENTION_POLICY=$RMAN_RETENTION_POLICY_PROD
    	 # Maybe check if RAC and DG makes sense
    	 ;;
    d) RMAN_RETENTION_POLICY=$RMAN_RETENTION_POLICY_PREPROD
    	 # Maybe check if RAC and DG makes sense
    	 ;;
    t) RMAN_RETENTION_POLICY=$RMAN_RETENTION_POLICY_TEST
    	 # Maybe check if RAC and DG makes sense
    	 ;;
    s) RMAN_RETENTION_POLICY=$RMAN_RETENTION_POLICY_DEV
    	 # Maybe check if RAC and DG makes sense
    	 ;;
  esac  
  # Always set snapshot controlfile
  RMAN_SETTINGS_DISK="CONNECT TARGET /;
CONFIGURE SNAPSHOT CONTROLFILE NAME TO '+${ASM_DATA_DISK_GROUP}/${database_unique_name}/CONTROLFILE/snapcf_${database_unique_name}.f' ;"
  # Get count of backup directories
  for directory in ${backup_directories//,/ }
  do
    ((directory_counter++))
  done
  # did we find any backup directories
  if [ $directory_counter -gt 0 ]
  then
    RMAN_SETTINGS_DISK="${RMAN_SETTINGS_DISK}
CONFIGURE BACKUP OPTIMIZATION ON;
CONFIGURE DEVICE TYPE DISK PARALLELISM ${directory_counter} BACKUP TYPE TO COMPRESSED BACKUPSET;
CONFIGURE COMPRESSION ALGORITHM 'low' AS OF RELEASE 'default' OPTIMIZE FOR LOAD TRUE;
CONFIGURE ARCHIVELOG DELETION POLICY TO BACKED UP 2 TIMES TO 'DISK';
CONFIGURE COMPRESSION ALGORITHM 'LOW' AS OF RELEASE 'DEFAULT' OPTIMIZE FOR LOAD TRUE;
CONFIGURE DB_UNIQUE_NAME '${database_unique_name}' CONNECT IDENTIFIER '${database_unique_name}';
CONFIGURE RETENTION POLICY TO RECOVERY WINDOW OF ${RMAN_RETENTION_POLICY} DAYS;
CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO '${directory}/${database_unique_name}/cf_${database_unique_name}_%F';"
    if [ "$standby_database_unique_name" != "" ]
    then
      RMAN_SETTINGS_DISK="${RMAN_SETTINGS_DISK}
CONFIGURE DB_UNIQUE_NAME '${standby_database_unique_name}' CONNECT IDENTIFIER '${standby_database_unique_name}';"    
    fi
  fi
  
  # We want to have minimum 8 channels configured, how many extra should we create pr. directory
  # Also ensure there are directories defined
  if [ $directory_counter -gt 0 ]
  then
    extra_channel_runs=$(( ( 8 + directory_counter - 1 ) / directory_counter ))
  else
    extra_channel_runs=0;
  fi
  #echo "channel runs needed="$extra_channel_runs
  # Loop over the directories found
  for directory in ${backup_directories//,/ }
  do
    (( channel_counter++ ))
    # Does the directory exist otherwise create
    if [ -d ${directory} ]
    then
      mkdir -p ${directory}/${database_unique_name}
    fi
    # Now create channels
    for (( i = 0; i < $extra_channel_runs; i++ ))
    do
      RMAN_SETTINGS_DISK="$RMAN_SETTINGS_DISK
CONFIGURE CHANNEL $(( channel_counter + ( i * directory_counter ) )) DEVICE TYPE DISK FORMAT '${directory}/${database_unique_name}/%U';"
    done
  done
  RMAN_SETTINGS_DISK="${RMAN_SETTINGS_DISK}
exit;"
  #echo "$RMAN_SETTINGS_DISK"
  # First find a first node where it exists
  node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")
  # On specific node run rman script
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${RMAN_SETTINGS_DISK}\" | $ORACLE_HOME/bin/rman"       
}

##
## Purpose: We only want root to run this
##
#check_for_permission()
#{
#  local input_user
#  input_user=$1
#  if [ `id -un` != "$input_user" ]
#  then
#    cecho r "  ERROR: No access rights. Need to be run as user $1"
#    exit 1
#  fi
#}


##
## string_contain
##
## Purpose: Will check if string argument 1 is in argument2
## Arguments: The section part to print
## Return: 0 if ok 1 otherwise
##
#string_contain()
#{
#  [ -z "${2##*$1*}" ] && [ -z "$1" -o -n "$2" ]
#}

# Will return 0 if parameter supplied is integer, otherwise return 1
# Will also echo the number if it is integer
check_integer()
{
  #log_file DEBUG "Entered function: $FUNCNAME"
  test $1 -eq 0 2>/dev/null
  if [ $? -eq 2 ]; then
    return 1
  else
    echo $1
  fi
}  



# Will find orainventory location and look up the ACTIVE agent
find_agent_oracle_home()
{
  for ORAINST_LOC in "${ORA_INST_LOC_POSSIBLE_LOCATIONS[@]}"
  do
    if [ -f $ORAINST_LOC ] 
    then
      ORAINVENTORY_LOCATION=`cat $ORAINST_LOC | sed -n -e 's/inventory_loc=\(.*\)/\1/p'`
      if [ "$ORAINVENTORY_LOCATION" = "" ]
      then
        cecho r "  ERROR: Can't find oraInventory location in $ORAINST_LOC"
        exit 1
      fi
      # Then find current agent oracle_home
      AGENT_ORACLE_HOME=`grep -v ".*REMOVED=\"T" ${ORAINVENTORY_LOCATION}/ContentsXML/inventory.xml | sed -n -e '/<HOME NAME="agent.*/s/.*LOC=\"\([^\"]*\)\".*/\1/p'`
      if [ "$AGENT_ORACLE_HOME" != "" ]
      then
        break
      fi
    fi
  done
  if [ "$AGENT_ORACLE_HOME" = "" ]
  then
    cecho p "WARNING: Can't find current agent oracle_home in any of ${ORA_INST_LOC_POSSIBLE_LOCATIONS[@]}" 
  fi
}


# used to set hashed passwords
set_password()
{
  case $1 in
    p)
    	SYS_PASSWORD=$PROD_SYS_PASSWORD
    	ASM_SYS_PASSWORD=$PROD_ASM_SYS_PASSWORD
    	SYSTEM_PASSWORD=$PROD_SYSTEM_PASSWORD
    	SYSMAN_PASSWORD=$PROD_SYSMAN_PASSWORD
    	DBSNMP_PASSWORD=$PROD_DBSNMP_PASSWORD
    	AGENT_REGISTRATOR_PASSWORD=$PROD_AGENT_REGISTRATOR_PASSWORD
    	SYSDG_PASSWORD=$PROD_SYSDG_PASSWORD
    	SYSKM_PASSWORD=$PROD_SYSKM_PASSWORD
    	SYSBACKUP_PASSWORD=$PROD_SYSBACKUP_PASSWORD
    	;;
    d)
    	SYS_PASSWORD=$DEMO_SYS_PASSWORD
    	ASM_SYS_PASSWORD=$DEMO_ASM_SYS_PASSWORD
    	SYSTEM_PASSWORD=$DEMO_SYSTEM_PASSWORD
    	SYSMAN_PASSWORD=$DEMO_SYSMAN_PASSWORD
    	DBSNMP_PASSWORD=$DEMO_DBSNMP_PASSWORD
    	AGENT_REGISTRATOR_PASSWORD=$DEMO_AGENT_REGISTRATOR_PASSWORD
    	SYSDG_PASSWORD=$DEMO_SYSDG_PASSWORD
    	SYSKM_PASSWORD=$DEMO_SYSKM_PASSWORD
    	SYSBACKUP_PASSWORD=$DEMO_SYSBACKUP_PASSWORD
    	;;
    t)
    	SYS_PASSWORD=$TEST_SYS_PASSWORD
    	ASM_SYS_PASSWORD=$TEST_ASM_SYS_PASSWORD
    	SYSTEM_PASSWORD=$TEST_SYSTEM_PASSWORD
    	SYSMAN_PASSWORD=$TEST_SYSMAN_PASSWORD
    	DBSNMP_PASSWORD=$TEST_DBSNMP_PASSWORD
    	AGENT_REGISTRATOR_PASSWORD=$TEST_AGENT_REGISTRATOR_PASSWORD
    	SYSDG_PASSWORD=$TEST_SYSDG_PASSWORD
    	SYSKM_PASSWORD=$TEST_SYSKM_PASSWORD
    	SYSBACKUP_PASSWORD=$TEST_SYSBACKUP_PASSWORD
    	;;
    s)
    	SYS_PASSWORD=$SANDBOX_SYS_PASSWORD
    	ASM_SYS_PASSWORD=$SANDBOX_ASM_SYS_PASSWORD
    	SYSTEM_PASSWORD=$SANDBOX_SYSTEM_PASSWORD
    	SYSMAN_PASSWORD=$SANDBOX_SYSMAN_PASSWORD
    	DBSNMP_PASSWORD=$SANDBOX_DBSNMP_PASSWORD
    	AGENT_REGISTRATOR_PASSWORD=$SANDBOX_AGENT_REGISTRATOR_PASSWORD    	
    	SYSDG_PASSWORD=$SANDBOX_SYSDG_PASSWORD
    	SYSKM_PASSWORD=$SANDBOX_SYSKM_PASSWORD
    	SYSBACKUP_PASSWORD=$SANDBOX_SYSBACKUP_PASSWORD
    	;;
    *) cecho r "  ERROR: Parameter 1 should be one of [pdts]"
  esac
}

## Used to convert a string to lower case
#convert_to_lower()
#{
#  echo $1 | tr [:upper:] [:lower:]
#}
# Used to convert a string to upper case
#convert_to_upper()
#{
#  echo $1 | tr [:lower:] [:upper:]
#}

# These are the values for a normal micro database (including Multiple Instances)
# Are now official
set_pico_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=2  
  # Normal database parameters
  CPU_COUNT=2
  SGA_TARGET=2684354560
  PGA_AGGREGATE_TARGET=536870912
  PARALLEL_MAX_SERVERS=10
  LARGE_POOL_SIZE=67108864
  JAVA_POOL_SIZE=67108864
  SHARED_POOL_SIZE=150994944
  DB_CACHE_SIZE=805306368
  JOB_QUEUE_PROCESSES=1
  AQ_TM_PROCESSES=1
  PARALLEL_DEGREE_LIMIT=2
  PROCESSES=250
  DB_FILES=4000
  RECOVERY_PARALLELISM=1
  LOG_ARCHIVE_MAX_PROCESSES=2
  STREAMS_POOL_SIZE=67108864
  # Seems not to work have put it under "size" directories also
  DB_RECOVERY_FILE_DEST_SIZE_MB=16000
  REDO_LOG_FILE_SIZE_MB=8
  PGA_AGGREGATE_LIMIT=$((PGA_AGGREGATE_TARGET*3))
}

# These are the values for a normal micro database when created as container database, will overide above parameters
set_pico_container_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=8  
  # PGA_AGGREGATE_LIMIT needs to be min 12000M 12884901888
  PGA_AGGREGATE_LIMIT=$(($PGA_AGGREGATE_LIMIT<12884901888?12884901888:$PGA_AGGREGATE_LIMIT))
}


# These are the values for a normal micro database (including Multiple Instances)
# Are now official
set_micro_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=2  
  # Normal database parameters
  CPU_COUNT=2
  SGA_TARGET=5368709120
  PGA_AGGREGATE_TARGET=1073741824
  PARALLEL_MAX_SERVERS=10
  LARGE_POOL_SIZE=134217728
  JAVA_POOL_SIZE=134217728
  SHARED_POOL_SIZE=301989888
  DB_CACHE_SIZE=1610612736
  JOB_QUEUE_PROCESSES=1
  AQ_TM_PROCESSES=1
  PARALLEL_DEGREE_LIMIT=2
  PROCESSES=250
  DB_FILES=4000
  RECOVERY_PARALLELISM=1
  LOG_ARCHIVE_MAX_PROCESSES=2
  STREAMS_POOL_SIZE=134217728
  # Seems not to work have put it under "size" directories also
  DB_RECOVERY_FILE_DEST_SIZE_MB=524288
  REDO_LOG_FILE_SIZE_MB=4096
  PGA_AGGREGATE_LIMIT=$((PGA_AGGREGATE_TARGET*3))
}

# These are the values for a normal micro database when created as container database, will overide above parameters
set_micro_container_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=8  
  # PGA_AGGREGATE_LIMIT needs to be min 12000M 12884901888
  PGA_AGGREGATE_LIMIT=$(($PGA_AGGREGATE_LIMIT<12884901888?12884901888:$PGA_AGGREGATE_LIMIT))
}

# These are the values for a normal tiny database (including Multiple Instances)
set_tiny_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=2
  # Normal database parameters
  CPU_COUNT=4
  SGA_TARGET=10737418240
  PGA_AGGREGATE_TARGET=2147483648
  PARALLEL_MAX_SERVERS=20
  LARGE_POOL_SIZE=268435456
  JAVA_POOL_SIZE=134217728
  SHARED_POOL_SIZE=2147483648
  DB_CACHE_SIZE=3221225472
  JOB_QUEUE_PROCESSES=2
  AQ_TM_PROCESSES=1
  PARALLEL_DEGREE_LIMIT=2
  PROCESSES=500
  DB_FILES=4000
  RECOVERY_PARALLELISM=2
  LOG_ARCHIVE_MAX_PROCESSES=4
  STREAMS_POOL_SIZE=134217728
  # Seems not to work have put it under "size" directories also
  DB_RECOVERY_FILE_DEST_SIZE_MB=524288
  REDO_LOG_FILE_SIZE_MB=4096
  PGA_AGGREGATE_LIMIT=$((PGA_AGGREGATE_TARGET*3))
}

# These are the values for a normal tiny database when created as container database, will overide above parameters
set_tiny_container_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=8  
  # PGA_AGGREGATE_LIMIT needs to be min 12000M 12884901888
  PGA_AGGREGATE_LIMIT=$(($PGA_AGGREGATE_LIMIT<12884901888?12884901888:$PGA_AGGREGATE_LIMIT))
}

# These are the values for a normal small database (including Multiple Instances)
set_small_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=2  
  # Normal database parameters
  CPU_COUNT=6
  SGA_TARGET=18253611008
  PGA_AGGREGATE_TARGET=5368709120
  PARALLEL_MAX_SERVERS=30
  LARGE_POOL_SIZE=268435456
  JAVA_POOL_SIZE=134217728
  SHARED_POOL_SIZE=4294967296
  DB_CACHE_SIZE=5368709120
  JOB_QUEUE_PROCESSES=3
  AQ_TM_PROCESSES=1
  PARALLEL_DEGREE_LIMIT=4
  PROCESSES=500
  DB_FILES=4000
  RECOVERY_PARALLELISM=2
  LOG_ARCHIVE_MAX_PROCESSES=10
  STREAMS_POOL_SIZE=134217728
  # Seems not to work have put it under "size" directories also
  DB_RECOVERY_FILE_DEST_SIZE_MB=1048576
  REDO_LOG_FILE_SIZE_MB=4096
  PGA_AGGREGATE_LIMIT=$((PGA_AGGREGATE_TARGET*3))
}

# These are the values for a normal small database when created as container database, will overide above parameters
set_small_container_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=8  
  # PGA_AGGREGATE_LIMIT needs to be min 12000M 12884901888
  PGA_AGGREGATE_LIMIT=$(($PGA_AGGREGATE_LIMIT<12884901888?12884901888:$PGA_AGGREGATE_LIMIT))
}

# These are the values for a normal medium database (including Multiple Instances)
set_medium_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=3  
  # Normal database parameters
  CPU_COUNT=8
  SGA_TARGET=25769803776
  PGA_AGGREGATE_TARGET=8589934592
  PARALLEL_MAX_SERVERS=40
  LARGE_POOL_SIZE=10737418240
  JAVA_POOL_SIZE=268435456
  SHARED_POOL_SIZE=5368709120
  DB_CACHE_SIZE=7516192768
  JOB_QUEUE_PROCESSES=4
  AQ_TM_PROCESSES=2
  PARALLEL_DEGREE_LIMIT=4
  PROCESSES=1000
  DB_FILES=4000
  RECOVERY_PARALLELISM=3
  LOG_ARCHIVE_MAX_PROCESSES=4
  STREAMS_POOL_SIZE=268435456
  # Seems not to work have put it under "size" directories also
  DB_RECOVERY_FILE_DEST_SIZE_MB=2097152
  REDO_LOG_FILE_SIZE_MB=4096
  PGA_AGGREGATE_LIMIT=$((PGA_AGGREGATE_TARGET*3))
}

# These are the values for a normal medium database when created as container database, will overide above parameters
set_medium_container_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=8  
  # PGA_AGGREGATE_LIMIT needs to be min 12000M 12884901888
  PGA_AGGREGATE_LIMIT=$(($PGA_AGGREGATE_LIMIT<12884901888?12884901888:$PGA_AGGREGATE_LIMIT))
}

# These are the values for a normal large database (including Multiple Instances)
set_large_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=4  
  # Normal database parameters
  CPU_COUNT=12
  SGA_TARGET=36507222016
  PGA_AGGREGATE_TARGET=10737418240
  PARALLEL_MAX_SERVERS=60
  LARGE_POOL_SIZE=2147483648
  JAVA_POOL_SIZE=402653184
  SHARED_POOL_SIZE=7516192768
  DB_CACHE_SIZE=10737418240
  JOB_QUEUE_PROCESSES=6
  AQ_TM_PROCESSES=4
  PARALLEL_DEGREE_LIMIT=8
  PROCESSES=2000
  DB_FILES=4000
  RECOVERY_PARALLELISM=3
  LOG_ARCHIVE_MAX_PROCESSES=4
  STREAMS_POOL_SIZE=402653184
  # Seems not to work have put it under "size" directories also
  DB_RECOVERY_FILE_DEST_SIZE_MB=4194304
  REDO_LOG_FILE_SIZE_MB=4096
  PGA_AGGREGATE_LIMIT=$((PGA_AGGREGATE_TARGET*3))
}

# These are the values for a normal large database when created as container database, will overide above parameters
set_large_container_parameters()
{
  MAX_INSTANCES_TO_RUN_ON=8  
  # PGA_AGGREGATE_LIMIT needs to be min 12000M 12884901888
  PGA_AGGREGATE_LIMIT=$(($PGA_AGGREGATE_LIMIT<12884901888?12884901888:$PGA_AGGREGATE_LIMIT))
}

read_pdb_admin_password()
{
  local PDB_ADMIN_PASSWORD_2
  local pw_quality="$1"
  if [ "$pw_quality" == "single" ]
  then
      read -s -p "PDB_ADMIN Password: " PDB_ADMIN_PASSWORD
      echo
  else
    while true; do
      read -s -p "PDB_ADMIN Password: " PDB_ADMIN_PASSWORD
      echo
      read -s -p "PDB_ADMIN Password (again): " PDB_ADMIN_PASSWORD_2
      echo
      [ "$PDB_ADMIN_PASSWORD" = "$PDB_ADMIN_PASSWORD_2" ] && break
      cecho r "  ERROR: PDB_ADMIN Passwords differ - please try again"
    done
  fi
}

read_sys_password()
{
  local SYS_PASSWORD_2
  local pw_quality="$1"
  if [ "$pw_quality" == "single" ]
  then
      read -s -p "SYS Password: " SYS_PASSWORD
      echo
  else
    while true; do
      read -s -p "SYS Password: " SYS_PASSWORD
      echo
      read -s -p "SYS Password (again): " SYS_PASSWORD_2
      echo
      [ "$SYS_PASSWORD" = "$SYS_PASSWORD_2" ] && break
      cecho r "  ERROR: SYS Passwords differ - please try again"
    done
  fi
}

read_system_password()
{
  local SYSTEM_PASSWORD_2
  local pw_quality="$1"
  if [ "$pw_quality" == "single" ]
  then
      read -s -p "SYSTEM Password: " SYSTEM_PASSWORD
      echo
  else
    while true; do
      read -s -p "SYSTEM Password: " SYSTEM_PASSWORD
      echo
      read -s -p "SYSTEM Password (again): " SYSTEM_PASSWORD_2
      echo
      [ "$SYSTEM_PASSWORD" = "$SYSTEM_PASSWORD_2" ] && break
      cecho r "  ERROR: SYSTEM Passwords differ - please try again"
    done
  fi
}

read_dbsnmp_password()
{
  local DBSNMP_PASSWORD_2
  local pw_quality="$1"
  if [ "$pw_quality" == "single" ]
  then
      read -s -p "DBSNMP Password: " DBSNMP_PASSWORD
      echo
  else
    while true; do
      read -s -p "DBSNMP Password: " DBSNMP_PASSWORD
      echo
      read -s -p "DBSNMP Password (again): " DBSNMP_PASSWORD_2
      echo
      [ "$DBSNMP_PASSWORD" = "$DBSNMP_PASSWORD_2" ] && break
      cecho r "  ERROR: DBSNMP Passwords differ - please try again"
    done
  fi
}

read_syskm_password()
{
  local SYSKM_PASSWORD_2
  local pw_quality="$1"
  if [ "$pw_quality" == "single" ]
  then
      read -s -p "SYSKM Password: " SYSKM_PASSWORD
      echo
  else
    while true; do
      read -s -p "SYSKM Password: " SYSKM_PASSWORD
      echo
      read -s -p "SYSKM Password (again): " SYSKM_PASSWORD_2
      echo
      [ "$SYSKM_PASSWORD" = "$SYSKM_PASSWORD_2" ] && break
      cecho r "  ERROR: SYSKM Passwords differ - please try again"
    done
  fi
}

read_sysdg_password()
{
  local SYSDG_PASSWORD_2
  local pw_quality="$1"
  if [ "$pw_quality" == "single" ]
  then
      read -s -p "SYSDG Password: " SYSDG_PASSWORD
      echo
  else
    while true; do
      read -s -p "SYSDG Password: " SYSDG_PASSWORD
      echo
      read -s -p "SYSDG Password (again): " SYSDG_PASSWORD_2
      echo
      [ "$SYSDG_PASSWORD" = "$SYSDG_PASSWORD_2" ] && break
      cecho r "  ERROR: SYSDG Passwords differ - please try again"
    done
  fi
}

read_sysbackup_password()
{
  local SYSBACKUP_PASSWORD_2
  local pw_quality="$1"
  if [ "$pw_quality" == "single" ]
  then
      read -s -p "SYSBACKUP Password: " SYSBACKUP_PASSWORD
      echo
  else
    while true; do
      read -s -p "SYSBACKUP Password: " SYSBACKUP_PASSWORD
      echo
      read -s -p "SYSBACKUP Password (again): " SYSBACKUP_PASSWORD_2
      echo
      [ "$SYSBACKUP_PASSWORD" = "$SYSBACKUP_PASSWORD_2" ] && break
      cecho r "  ERROR: SYSBACKUP Passwords differ - please try again"
    done
  fi
}


setresources_database()
{
  DATABASE_UNIQUE_NAME="$1"
  USE_SGA_MEMORY_PROFILE="$2"
  USE_CPU_COUNT_PROFILE="$3"
  USE_STORAGE_CAPACITY_PROFILE="$4"
  USE_STORAGE_IOPS_PROFILE="$5"
  USE_STORAGE_BANDWIDTH_PROFILE="$6"
  echo "PDB_NAME=$PDB_NAME"
  echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  echo "USE_SGA_MEMORY_PROFILE=$USE_SGA_MEMORY_PROFILE"
  echo "USE_CPU_COUNT_PROFILE=$USE_CPU_COUNT_PROFILE"
  echo "USE_STORAGE_CAPACITY_PROFILE=$USE_STORAGE_CAPACITY_PROFILE"
  echo "USE_STORAGE_IOPS_PROFILE=$USE_STORAGE_IOPS_PROFILE"
  echo "USE_STORAGE_BANDWIDTH_PROFILE=$USE_STORAGE_BANDWIDTH_PROFILE"
  echo " ERROR: Not implemented yet TBD"
  exit 1
}

setresources_pdb()
{
  PDB_NAME="$1"
  DATABASE_UNIQUE_NAME="$2"
  USE_SGA_MEMORY_PROFILE="$3"
  USE_CPU_COUNT_PROFILE="$4"
  USE_STORAGE_CAPACITY_PROFILE="$5"
  USE_STORAGE_IOPS_PROFILE="$6"
  USE_STORAGE_BANDWIDTH_PROFILE="$7"
  echo "PDB_NAME=$PDB_NAME"
  echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  echo "USE_SGA_MEMORY_PROFILE=$USE_SGA_MEMORY_PROFILE"
  echo "USE_CPU_COUNT_PROFILE=$USE_CPU_COUNT_PROFILE"
  echo "USE_STORAGE_CAPACITY_PROFILE=$USE_STORAGE_CAPACITY_PROFILE"
  echo "USE_STORAGE_IOPS_PROFILE=$USE_STORAGE_IOPS_PROFILE"
  echo "USE_STORAGE_BANDWIDTH_PROFILE=$USE_STORAGE_BANDWIDTH_PROFILE"
  echo " ERROR: Not implemented yet TBD"
  exit 1
}

create_database_dbca()
{
  case $ORACLE_MAJOR_VERSION  in
    11.2|12.1)
      #create_database_dbca_old;;
      cecho r "  ERROR: We don't support creating 11.2 and 12.1 databases with this script."
      cecho r "         If you run on Exadata you can use nddbctl.pre12.2 script for this"
      ;;
    *)
      create_database_dbca_new;;
  esac
}

# Here we create the actual database (new way as dbca parameters are not working the same way anymore)
create_database_dbca_new()
{
  local node
  #read_sys_password
  #read_system_password
  SYS_PASSWORD_UNSECURE="Alkadjla1253as4AZN"
  SYSTEM_PASSWORD_UNSECURE="Bzladskas1s2523EVB"
  DBSNMP_PASSWORD_UNSECURE="Nladkjldj86kaslHSH"
  DBCA_PARAMETERS=""
  if [ "$CREATE_AS_CONTAINER" = "YES" ]
  then
    DBCA_PARAMETERS="${DBCA_PARAMETERS} -createAsContainerDatabase true\
 -useLocalUndoForPDBs true\
"
    CUSTOM_SCRIPTS="-customScripts /var/lib/nddbctl/templates/sql/nordeasystem/nordeasystem.sql,/var/lib/nddbctl/templates/sql/components/remove_public_grants.sql,/var/lib/nddbctl/templates/sql/components/prepare_database_for_nordea.sql,/var/lib/nddbctl/templates/sql/profiles/${USE_CPU_COUNT_PROFILE}.sql,/var/lib/nddbctl/templates/sql/profiles/${USE_SGA_MEMORY_PROFILE}.sql,/var/lib/nddbctl/templates/sql/profiles/${USE_STORAGE_CAPACITY_PROFILE}.sql,/var/lib/nddbctl/templates/sql/profiles/${USE_STORAGE_IOPS_PROFILE}.sql,/var/lib/nddbctl/templates/sql/profiles/${USE_STORAGE_BANDWIDTH_PROFILE}.sql"
    # parallel_force_local = TRUE p√• 19c container databaser for at reducere antallet af ORA-12850 fejl - Martin request
    PARALLEL_FORCE_LOCAL="TRUE"
  else
    PARALLEL_FORCE_LOCAL="TRUE"
  fi
  INIT_PARAMS="-initParams \
${REMOTE_LISTENER_PARAMETER}db_name=$DB_NAME\
,cpu_count=$CPU_COUNT\
,pga_aggregate_target=$PGA_AGGREGATE_TARGET\
,db_unique_name=$DATABASE_UNIQUE_NAME\
,large_pool_size=$LARGE_POOL_SIZE\
,java_pool_size=$JAVA_POOL_SIZE\
,shared_pool_size=$SHARED_POOL_SIZE\
,db_cache_size=$DB_CACHE_SIZE\
,job_queue_processes=$JOB_QUEUE_PROCESSES\
,parallel_max_servers=$PARALLEL_MAX_SERVERS\
,parallel_degree_limit=$PARALLEL_DEGREE_LIMIT\
,aq_tm_processes=$AQ_TM_PROCESSES\
,processes=$PROCESSES\
,recovery_parallelism=$RECOVERY_PARALLELISM\
,log_archive_max_processes=$LOG_ARCHIVE_MAX_PROCESSES\
,sga_target=$SGA_TARGET\
,db_create_online_log_dest_1=+$ASM_DATA_DISK_GROUP\
,db_create_online_log_dest_2=+$ASM_DATA_DISK_GROUP\
,streams_pool_size=$STREAMS_POOL_SIZE\
,dg_broker_config_file1=+${ASM_DATA_DISK_GROUP}/${DATABASE_UNIQUE_NAME}/dr1${DATABASE_UNIQUE_NAME}.dat\
,dg_broker_config_file2=+${ASM_DATA_DISK_GROUP}/${DATABASE_UNIQUE_NAME}/dr2${DATABASE_UNIQUE_NAME}.dat\
,nls_length_semantics=$NLS_LENGTH_SEMANTICS\
,db_files=$DB_FILES\
,db_performance_profile=${DATABASE_TYPE}\
,pga_aggregate_limit=${PGA_AGGREGATE_LIMIT}\
,parallel_force_local=${PARALLEL_FORCE_LOCAL}\
,control_files=+${ASM_DATA_DISK_GROUP}\,+${ASM_DATA_DISK_GROUP}\
,audit_trail=XML\,EXTENDED\
,_sys_logon_delay=1"
#,redo_transport_user=sysdg\
#,db_recovery_file_dest=+$ASM_RECO_DISK_GROUP\
#,db_recovery_file_dest_size=$DB_RECOVERY_FILE_DEST_SIZE_MB\

if [ "$SKIP_EM_CONFIGURATION" = "N" ]
  then      
    DBCA_PARAMETERS="${DBCA_PARAMETERS} -emConfiguration CENTRAL
-omsHost ${AGENT_REGISTRATOR_OMS_HOST}\
-omsPort ${AGENT_REGISTRATOR_OMS_PORT}\
-emUser ${AGENT_REGISTRATOR_USERNAME}\
-emPassword ${AGENT_REGISTRATOR_PASSWORD}
"
  fi
  #-asmSysPassword ${ASM_SYS_PASSWORD} \
  if [ "${ORACLE_INSTANCE_TYPE}" == 'SINGLE' ]
  then
    node=${RUN_ON_NODES}
  else
    node=${HOSTNAME%%.*}
  fi
  ssh -o 'StrictHostKeyChecking no' ${node} $ORACLE_HOME/bin/dbca \
  -silent \
  -createDatabase  \
  -templateName ${COMMON_TEMPLATES_DIRECTORY}/$TEMPLATE \
  -sid $DATABASE_INSTANCE \
  -gdbName $DATABASE_UNIQUE_NAME \
  -sysPassword ${SYS_PASSWORD_UNSECURE} \
  -systemPassword ${SYSTEM_PASSWORD_UNSECURE} \
  -dbsnmpPassword ${DBSNMP_PASSWORD_UNSECURE} \
  ${EM_CONFIGURATION}-storageType ASM \
  ${SPECIAL_DB_PARAMETERS}-diskGroupName +$ASM_DATA_DISK_GROUP ${IGNORE_PRE_REQS} \
  ${CONTAINER_DB_PARAMTERS}-redundancy NORMAL \
  -datafileDestination +$ASM_DATA_DISK_GROUP \
  -recoveryAreaDestination +$ASM_RECO_DISK_GROUP \
  -recoveryAreaSize $DB_RECOVERY_FILE_DEST_SIZE_MB \
  -nodeinfo $INSTALL_ON_NODES \
  -characterSet $CHARACTERSET  \
  -nationalCharacterSet $NATIONAL_CHARACTERSET \
  -obfuscatedPasswords false \
  -sampleSchema false \
  -redoLogFileSize $REDO_LOG_FILE_SIZE_MB \
  -databaseType MULTIPURPOSE \
  -enableArchive true \
  -useOMF true \
  -initParamsEscapeChar \"\\\\\" \
  ${DBCA_PARAMETERS} \
  ${INIT_PARAMS} \
  ${CUSTOM_SCRIPTS}
  #exit 99
  #return_code=$?
  #echo "DBCA Return Code = $return_code - we return 0"
  #return 0
}


# Here we create the actual database (old way)
create_database_dbca_old()
{
  # Anything special for the specific db versions
  case $ORACLE_MAJOR_VERSION in
    11.2)
      SPECIAL_DB_PARAMETERS="";;
    12.1)
#      -initParams db_performance_profile=${DATABASE_TYPE}  \
      SPECIAL_DB_PARAMETERS="-initParams pga_aggregate_limit=${PGA_AGGREGATE_LIMIT} \
";;
  esac;
  if [ "$SKIP_EM_CONFIGURATION" = "N" ]
  then
  	# Dont skip
    case $ORACLE_MAJOR_VERSION in
      11.2)
      	EM_CONFIGURATION="-sysmanPassword ${SYSMAN_PASSWORD} \
  -dbsnmpPassword ${DBSNMP_PASSWORD} \
  -emConfiguration CENTRAL \
  -centralAgent ${AGENT_ORACLE_HOME} \
";;
      12.1)
        EM_CONFIGURATION="-emConfiguration CENTRAL
  -dbsnmpPassword ${DBSNMP_PASSWORD} \
  -omsHost ${AGENT_REGISTRATOR_OMS_HOST} \
  -omsPort ${AGENT_REGISTRATOR_OMS_PORT} \
  -emUser ${AGENT_REGISTRATOR_USERNAME} \
  -emPassword ${AGENT_REGISTRATOR_PASSWORD} \
";;
    esac;
  else
  	# Skip EM Configuration
  	EM_CONFIGURATION=""
  fi
  export JRE_OPTIONS="-XX:MaxPermSize=128M"
  $ORACLE_HOME/bin/dbca \
  -silent \
  -createDatabase  \
  -templateName ${COMMON_TEMPLATES_DIRECTORY}/$TEMPLATE \
  -sid $DATABASE_INSTANCE \
  -gdbName $DATABASE_UNIQUE_NAME \
  -sysPassword ${SYS_PASSWORD} \
  -systemPassword ${SYSTEM_PASSWORD} \
  -asmSysPassword ${ASM_SYS_PASSWORD} \
  ${EM_CONFIGURATION}-storageType ASM \
  ${SPECIAL_DB_PARAMETERS}-diskGroupName $ASM_DATA_DISK_GROUP ${IGNORE_PRE_REQS} \
  -redundancy NORMAL \
  -datafileDestination $ASM_DATA_DISK_GROUP \
  -recoveryGroupName $ASM_RECO_DISK_GROUP \
  -recoveryGroupRedundancy NORMAL \
  -nodeinfo $INSTALL_ON_NODES \
  -characterSet $CHARACTERSET  \
  -nationalCharacterSet $NATIONAL_CHARACTERSET \
  -obfuscatedPasswords true \
  -sampleSchema false \
  -redoLogFileSize $REDO_LOG_FILE_SIZE_MB \
  -variables COMMON_TEMPLATES_DIRECTORY=$COMMON_TEMPLATES_DIRECTORY \
  -variables CUSTOM1=exadata \
  -variables CUSTOM2=nordea \
  -variables CUSTOM3=${DATABASE_TYPE} \
  -variables CUSTOM4=${ORACLE_MAJOR_VERSION} \
  -variables CUSTOM5=none \
  -variables CUSTOM6=none \
  -variables CUSTOM7=none \
  -variables CUSTOM8=none \
  -variables CUSTOM9=none \
  -initParams db_name=$DB_NAME \
  -initParams cpu_count=$CPU_COUNT \
  -initParams pga_aggregate_target=$PGA_AGGREGATE_TARGET \
  -initParams db_unique_name=$DATABASE_UNIQUE_NAME \
  -initParams large_pool_size=$LARGE_POOL_SIZE \
  -initParams java_pool_size=$JAVA_POOL_SIZE \
  -initParams shared_pool_size=$SHARED_POOL_SIZE \
  -initParams db_cache_size=$DB_CACHE_SIZE \
  -initParams job_queue_processes=$JOB_QUEUE_PROCESSES \
  -initParams parallel_max_servers=$PARALLEL_MAX_SERVERS \
  -initParams parallel_degree_limit=$PARALLEL_DEGREE_LIMIT \
  -initParams aq_tm_processes=$AQ_TM_PROCESSES \
  -initParams processes=$PROCESSES \
  -initParams recovery_parallelism=$RECOVERY_PARALLELISM \
  -initParams log_archive_max_processes=$LOG_ARCHIVE_MAX_PROCESSES \
  -initParams sga_target=$SGA_TARGET \
  -initParams db_create_online_log_dest_1=+$ASM_DATA_DISK_GROUP \
  -initParams db_create_online_log_dest_2=+$ASM_DATA_DISK_GROUP \
  -initParams streams_pool_size=$STREAMS_POOL_SIZE \
  -initParams dg_broker_config_file1=+${ASM_DATA_DISK_GROUP}/${DATABASE_UNIQUE_NAME}/dr1${DATABASE_UNIQUE_NAME}.dat \
  -initParams dg_broker_config_file2=+${ASM_DATA_DISK_GROUP}/${DATABASE_UNIQUE_NAME}/dr2${DATABASE_UNIQUE_NAME}.dat \
  -initParams nls_length_semantics=$NLS_LENGTH_SEMANTICS \
  -initParams db_files=$DB_FILES \
  -initParams db_recovery_file_dest=+$ASM_RECO_DISK_GROUP \
  -initParams db_recovery_file_dest_size=$DB_RECOVERY_FILE_DEST_SIZE_MB \
  -initParams control_files=+${ASM_DATA_DISK_GROUP}
  # Does not work
  #-initParams audit_trail=XML/,EXTENDED
  #-initParams 'audit_trail="${AUDIT_TRAIL}"'
  #-initParams control_files='+${ASM_DATA_DISK_GROUP}/${DATABASE_UNIQUE_NAME}/control01.ctl','+${ASM_DATA_DISK_GROUP}/${DATABASE_UNIQUE_NAME}/control02.ctl'   
}

#
# Parse arguments
#
# Purpose: Parses all the arguments received on command line
#
parse_arguments()
{
  if [ $# -eq 0 ]
  then
  	echo "No parameters given."
  	echo "Information about environment"
  	get_environment_names
    print_environment
    write_usage
    exit
  fi
  # First check action is one we know off
  VALID_ACTION_LIST="setresources check status snapshot prepatch patch postpatch dgfinish finish distribute delete create export import prepare duplicate demultiplex prepare switchover list -h --help "
  if string_contain "$1 " "$VALID_ACTION_LIST"
  then
    ACTION=$1
  else
    cecho r "  ERROR: Action parameter \"$1\" given to script not recognized"
    exit 1
  fi
  if [ "$ACTION" = "-h" -o "$ACTION" = "--help" ]
  then
    write_usage
    exit
  fi
  shift
  if [ $# -eq 0 ]
  then
    cecho r "  ERROR: Action parameter \"$ACTION\" given to script needs to be followed by an object"
    exit 1
  fi
  # Depending on action various objects might be specified
  case $1 in
    plugfile) OBJECT="plugfile";VALID_ACTION_LIST="create ";;
    stdpdbservices) OBJECT="stdpdbservices";VALID_ACTION_LIST="create ";;
    services) OBJECT="services";VALID_ACTION_LIST="delete create snapshot ";;
    standby) OBJECT="standby";VALID_ACTION_LIST="status prepare duplicate finish prepatch postpatch ";;
    rman) OBJECT="rman";VALID_ACTION_LIST="prepare ";;
    standbylog) OBJECT="standbylog";VALID_ACTION_LIST="demultiplex ";;
    primary) OBJECT="primary";VALID_ACTION_LIST="prepare patch ";;
    database) OBJECT="database";VALID_ACTION_LIST="setresources delete create switchover ";;
    pdb) OBJECT="pdb";VALID_ACTION_LIST="setresources dgfinish list create delete harden check ";;
    asmpasswordfile) OBJECT="asmpasswordfile";VALID_ACTION_LIST="export import ";;
    passwordfile) OBJECT="passwordfile";VALID_ACTION_LIST="distribute ";;
    *)            cecho r "  ERROR: Object parameter $1 given to script not recognized";exit 1;;
  esac;
  shift  
  # first check if we support combination
  if ! string_contain  "$ACTION " "$VALID_ACTION_LIST" 
  then
    cecho r "  ERROR: The action \"$ACTION\" is not not supported for object \"$OBJECT\". Actions allowed is \"$VALID_ACTION_LIST\""
    exit 1
  fi  
  case $OBJECT in
    standby)
      check_for_permission oracle
      case $ACTION in
        status)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueNameRegex: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueNameRegex) INPUT_DATABASE_UNIQUE_NAME_REGEX="$2";shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          ;;
        duplicate|finish)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName:,standbyDatabaseUniqueName:,sysPassword:,sysPasswordFile:,switchOver -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) INPUT_DATABASE_UNIQUE_NAME="$2";shift 2;;
              --standbyDatabaseUniqueName) INPUT_STANDBY_DATABASE_UNIQUE_NAME="$2";shift 2;;
              --sysPassword) INPUT_SYS_PASSWORD="$2";shift 2;;
              --sysPasswordFile) INPUT_SYS_PASSWORD_FILE="$2";shift 2;;
              --switchOver) INPUT_SWITCH_OVER="YES";shift 1;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$INPUT_DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi
          if [ "$INPUT_STANDBY_DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --standbyDatabaseUniqueName <standby database unique name> needs to be specified"
            exit 1
          fi
          if [ "$INPUT_SYS_PASSWORD_FILE" != "" ]
          then
            if [ ! -f $INPUT_SYS_PASSWORD_FILE ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: File given to parameter --sysPasswordfile does not exist"
              exit 1
            else
              #Try to fetch password from file
              read -r INPUT_SYS_PASSWORD < $INPUT_SYS_PASSWORD_FILE
            fi
          fi                        
          if [ "$INPUT_SYS_PASSWORD" == "" ]
          then
            echo "   INFO: SYS password needs to be specified"
            read_sys_password "single"
            INPUT_SYS_PASSWORD=$SYS_PASSWORD
          fi              
          ;;
        prepare)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName:,standbyDuplicateNode: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --standbyDuplicateNode) STANDBY_DUPLICATE_NODE="$2";shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi
          if [ "$STANDBY_DUPLICATE_NODE" == "" ]
          then
            cecho r "  ERROR: --standbyDuplicateNode <node name> needs to be specified"
            exit 1
          fi              
          ;;
        prepatch)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName:,newOracleHome:,dryRun,verbose -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --newOracleHome) NEW_ORACLE_HOME="$2";shift 2;;
              --dryRun) DRY_RUN="YES";shift 1;;
              --verbose) VERBOSE="YES";shift 1;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          else
            # Check that the database exists
            ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
            if [ "$ORACLE_HOME" = "" ]
            then
              cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
              exit 1
            fi
          fi
          if [ "$NEW_ORACLE_HOME" == "" ]
          then
            cecho r "  ERROR: --newOracleHome <full path to Oracle Home> needs to be specified"
            exit 1
          else
            # Check that the home exists (on all nodes?)
            if [ ! -d "$(realpath ${NEW_ORACLE_HOME})" ]
            then
              cecho r "  ERROR: Directory $NEW_ORACLE_HOME does not exist"
              exit 1
            fi
            NEW_ORACLE_HOME="$(realpath ${NEW_ORACLE_HOME})"
            # Is it the same home as the Database home already - not fool proof but better than nothing
            if [ "${NEW_ORACLE_HOME}" = "$ORACLE_HOME" ]
            then
              cecho r "  ERROR: Directory $NEW_ORACLE_HOME is the same as current Oracle Home for the database"
              exit 1
            fi           
          fi 
          ;;
        postpatch)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName:,dryRun,dontReloadListener,verbose -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --dryRun) DRY_RUN="YES";shift 1;;
              --dontReloadListener) DONT_RELOAD_LISTENER="YES"; shift 1;;
              --verbose) VERBOSE="YES";shift 1;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          else
            ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
            if [ "$ORACLE_HOME" = "" ]
            then
              cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
              exit 1
            fi
          fi
      esac
      ;;              
    rman)
      check_for_permission oracle
      case $ACTION in
        prepare)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi              
          ;;
      esac
      ;;              
    standbylog)
      check_for_permission oracle
      case $ACTION in
        demultiplex)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi              
          ;;
      esac
      ;;              
    passwordfile)
      check_for_permission oracle
      case $ACTION in
        distribute)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi              
          ;;
      esac
      ;;              
    primary)
      check_for_permission oracle
      case $ACTION in
        patch)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName:,newOracleHome:,dryRun,dontReloadListener,verbose -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --newOracleHome) NEW_ORACLE_HOME="$2";shift 2;;
              --dryRun) DRY_RUN="YES";shift 1;;
              --dontReloadListener) DONT_RELOAD_LISTENER="YES"; shift 1;;
              --verbose) VERBOSE="YES";shift 1;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          else
            # Check that the database exists
            ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
            if [ "$ORACLE_HOME" = "" ]
            then
              cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
              exit 1
            fi
          fi
          if [ "$NEW_ORACLE_HOME" == "" ]
          then
            cecho r "  ERROR: --newOracleHome <full path to Oracle Home> needs to be specified"
            exit 1
          else
            # Check that the home exists (on all nodes?)
            if [ ! -d "$(realpath ${NEW_ORACLE_HOME})" ]
            then
              cecho r "  ERROR: Directory $NEW_ORACLE_HOME does not exist"
              exit 1
            fi
            NEW_ORACLE_HOME="$(realpath ${NEW_ORACLE_HOME})"
            # Is it the same home as the Database home already - not fool proof but better than nothing
            if [ "${NEW_ORACLE_HOME}" = "$ORACLE_HOME" ]
            then
              cecho r "  ERROR: Directory $NEW_ORACLE_HOME is the same as current Oracle Home for the database"
              exit 1
            fi           
          fi  
          ;;
        prepare)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi              
          ;;
      esac
      ;;          
    asmpasswordfile)
      check_for_permission grid
      case $ACTION in
        export)
          TEMP=`getopt -o "" --name "$0" --long file:,databaseUniqueName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --file) IMPORT_EXPORT_FILE="$2";shift 2;;
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi              
          if [ "$IMPORT_EXPORT_FILE" == "" ]
          then
            cecho r "  ERROR: --file <file name> needs to be specified"
            exit 1
          fi          
          ;;
        import)
          TEMP=`getopt -o "" --name "$0" --long file:,diskgroup:,databaseUniqueName:  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --file) IMPORT_EXPORT_FILE="$2";shift 2;;
              --diskGroup) IMPORT_DISK_GROUP="$2";shift 2;;
              --databaseUniqueName) DATABASE_UNIQUE_NAME="$2";shift 2;;                
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi              
          if [ "$IMPORT_EXPORT_FILE" == "" ]
          then
            cecho r "  ERROR: --file <file name> needs to be specified"
            exit 1
          fi          
          if [ "$IMPORT_DISK_GROUP" == "" ]
          then
            cecho r "  ERROR: --diskGroup <ASM disk group name> needs to be specified"
            exit 1
          fi          
          ;;
      esac
      ;;
    stdpdbservices)
      check_for_permission oracle
      case $ACTION in
        create)
          TEMP=`getopt -o "" --name "$0" --long pdbName:,pdbPrimaryServicename:,pdbStandbyServicename:,databaseUniqueName:,useNodes:  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --pdbName) PDB_NAME=`convert_to_lower $2`;shift 2 ;;
              --useNodes) USE_NODES=$2 ;shift 2 ;; 
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbPrimaryServicename) PDB_PRIMARY_SERVICE_NAME=$2; shift 2;;
              --pdbStandbyServicename) PDB_STANDBY_SERVICE_NAME=$2; shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          #set -x
          errors_found=0
          if [ "${PDB_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --pdbName have to be specified"
            (( errors_found++ ))
          fi     
          if [ "${USE_NODES}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --useNodes have to be specified"
            (( errors_found++ ))
          fi          
          if [ "${DATABASE_UNIQUE_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --databaseUniqueName have to be specified"
            (( errors_found++ ))
          fi          
          if [ "${PDB_PRIMARY_SERVICE_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --pdbPrimaryServicename have to be specified"
            (( errors_found++ ))
          fi          
          if [ "${PDB_STANDBY_SERVICE_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --pdbStandbyServicename have to be specified"
            (( errors_found++ ))
          fi          
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
        ;;
      esac;;  
    plugfile)
      check_for_permission oracle
      case $ACTION in
        create)
          TEMP=`getopt -o "" --name "$0" --long pdbName:,databaseUniqueName:,pdbPlugFile:  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --pdbName) INPUT_PDB_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbPlugFile) INPUT_PDB_PLUG_FILE=$2 ;shift 2 ;; 
              --databaseUniqueName) INPUT_DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          #set -x
          errors_found=0
          if [ "${INPUT_PDB_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --pdbName have to be specified"
            (( errors_found++ ))
          fi     
          if [ "${INPUT_PDB_PLUG_FILE}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --pdbPlugFile have to be specified"
            (( errors_found++ ))
          fi          
          if [ "${INPUT_DATABASE_UNIQUE_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --databaseUniqueName have to be specified"
            (( errors_found++ ))
          fi          
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          # Now check that CDB and PDB is there
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          #set -x
          # Get number of nodes in cluster
          NUMBER_OFF_RAC_NODES=$($GRID_ORACLE_HOME/bin/olsnodes | wc -l)
          # Maybe check if its numeric and sucseeded
          # Check if container CDB exists
          # Find ORACLE_HOME of database selected for pluggabble
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${INPUT_DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $INPUT_DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # Check that database is a container database
          # First find a node where it's configured
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
          # MAybe dubble check that stuff is actually found TBD
          # Now run SQL
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $INPUT_DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi  
          # Check if PDB exists in container
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${INPUT_PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" = "" ]
          then
            cecho r "  ERROR: The PDB $INPUT_PDB_NAME does not exist in the CDB database $INPUT_DATABASE_UNIQUE_NAME"
            exit 1
          fi
          # Check that directory exists
          local basedir=""
          if [ -h $INPUT_PDB_PLUG_FILE ]
          then
            basedir=$(dirname $(readlink $INPUT_PDB_PLUG_FILE))
          else
            basedir=$(dirname $INPUT_PDB_PLUG_FILE)
          fi
          if [ ! -d "${basedir}" ]
          then
            cecho r "  ERROR: The directory $basedir does not exist"
            exit 1
          fi
          if [ ! -w "${basedir}" ]
          then
            cecho r "  ERROR: The directory $basedir is not writeable"
            exit 1
          fi
        ;;
      esac;;          
    services)
      check_for_permission oracle
      case $ACTION in
        snapshot)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) INPUT_DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          # DB Should exists
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          if [ "$INPUT_DATABASE_UNIQUE_NAME" = "" ]
          then
            cecho r "  ERROR: --databaseUniqueName has to be specified"
            exit 1
          fi
          # Find ORACLE_HOME of database selected 
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${INPUT_DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $INPUT_DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # First find a node where it's configured
          local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
          if [ "$node_selected" = "" ]
          then
            cecho r "  ERROR: Can't get node where there is a instanse of ${INPUT_DATABASE_UNIQUE_NAME} running"
            exit 1
          fi
          # Then find instance on that node
          local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
          if [ "$node_selected" = "" ]
          then
            cecho r "  ERROR: Can't get a running instanse of ${INPUT_DATABASE_UNIQUE_NAME}"
            exit 1
          fi
          # DB Should be primary
          # Check that this is a primary database
          last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_PRIMARY_SQL" "-S" )
          local last_error_code=$?
          if [ $last_error_code -ne 0 ]
          then
            # failed
            cecho r "  ERROR: Call to get primary database name on primary failed with code=$last_error_code and error text=$last_result"
            exit 1 
          else
            # success
            local PRIMARY_DB_NAME_ON_PRIMARY=$(echo ${last_result})
            if [ "$PRIMARY_DB_NAME_ON_PRIMARY" = "" ]
            then
              cecho r "  ERROR: $INPUT_DATABASE_UNIQUE_NAME is not running as a primary database - only works on primary databases"
              exit 2
            else
              cecho g "     OK: $INPUT_DATABASE_UNIQUE_NAME is running as a primary database"      
            fi     
          fi
          #set +x
        ;;
        create)
          TEMP=`getopt -o "" --name "$0" --long useNodes:,pdbName:,databaseUniqueName:,pdbPrimaryServiceName:,pdbStandbyServiceName:,pdbAdminServiceName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --pdbName) PDB_NAME=`convert_to_lower $2`;shift 2 ;;
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbPrimaryServiceName) PDB_PRIMARY_SERVICE_NAME=$2; shift 2;;
              --pdbStandbyServiceName) PDB_STANDBY_SERVICE_NAME=$2; shift 2;;                
              --pdbAdminServiceName) PDB_ADMIN_SERVICE_NAME=$2; shift 2;;                
              --useNodes) USE_NODES=$2 ;shift 2 ;; 
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          # Check service names length (30 characters?=
          if [ ${#PDB_PRIMARY_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbPrimaryServicename $PDB_PRIMARY_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi              
          # Check service names length (30 characters?=
          if [ ${#PDB_STANDBY_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbStandbyServicename $PDB_STANDBY_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi             
          # Check service names length (30 characters?=
          if [ ${#PDB_ADMIN_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbAdminServicename $PDB_ADMIN_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi             
          if [ "$PDB_NAME" = "" ]
          then
            # Ouch file needs to be there
            cecho r "  ERROR: Parameter --pdbName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "$DATABASE_UNIQUE_NAME" = "" ]
          then
            # Ouch file needs to be there
            cecho r "  ERROR: Parameter --databaseUniqueName needs to be specified"
            (( errors_found++ ))
          fi
          # if one is there They all need to be there. If not sopecified we will later try to grap themm from the database
          if [ "$USE_NODES" != "" -o  "$PDB_STANDBY_SERVICE_NAME" != "" -o  "$PDB_PRIMARY_SERVICE_NAME" != "" -o "$PDB_ADMIN_SERVICE_NAME" != "" ]
          then
            if [ "$PDB_PRIMARY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Parameter --pdbPrimaryServiceName needs to be specified"
              (( errors_found++ ))
            fi
            if [ "$PDB_STANDBY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Parameter --pdbStandbyServiceName needs to be specified"
              (( errors_found++ ))
            fi
            if [ "$PDB_ADMIN_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Parameter --pdbAdminServiceName needs to be specified"
              (( errors_found++ ))
            fi
            case ${USE_NODES} in
              "")
                cecho r "  ERROR: Parameter --useNodes needs to be specified]"
                (( errors_found++ ))
                ;;
              1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16)
                # Do nothing
                :
                ;;
              *)
                cecho r "  ERROR: Parameter --useNodes needs to be one of [1-16]"
                (( errors_found++ ))
                ;;
            esac
          fi
          # If we have issue here then bang out here as we can het "funny errors" fro mhere if the unique name and pdb_name is not specified here
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          #set -x
          # Get number of nodes in cluster
          NUMBER_OFF_RAC_NODES=$($GRID_ORACLE_HOME/bin/olsnodes | wc -l)
          # Maybe check if its numeric and sucseeded
          # Check if container CDB exists
          # Find ORACLE_HOME of database selected for pluggabble
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # Check that database is a container database
          # First find a node where it's configured
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
          # MAybe dubble check that stuff is actually found TBD
          # Now run SQL
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi  
          # Are we running as a standby database
          # Get the Primary database
          # Try to get primary database name, if that is empty we are not running as standby
          PRIMARY_DB_NAME_ON_STANDBY=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$PRIMARY_DB_NAME_ON_STANDBY_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          PRIMARY_DB_NAME_ON_STANDBY=$(echo ${PRIMARY_DB_NAME_ON_STANDBY})
          if [ "$PRIMARY_DB_NAME_ON_STANDBY" = "" ]
          then
            IS_PRIMARY_DATABASE="YES"
          else
            IS_PRIMARY_DATABASE="NO"
          fi        
          # If not PRIMARY_TNS_SERVICE_NAME set then set it to primary database name 
          #if [ "$PRIMARY_TNS_SERVICE_NAME" = "" ]
          #then
          #  PRIMARY_TNS_SERVICE_NAME=$PRIMARY_DB_NAME_ON_STANDBY
          #fi
          # Check that we can "ping" primaryservice
          # Try to get primary database name, if that is empty we are not running as standby
          #RESULT_FROM_PING=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; $ORACLE_HOME/bin/tnsping ${PRIMARY_TNS_SERVICE_NAME}")
          #if [ $? -ne 0 ]
          #then
          #  cecho r "  ERROR: The TNS NAME entry $PRIMARY_TNS_SERVICE_NAME ca't be pinged"
          #  exit 1
          #fi  
          # Check if PDB exists in container
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" = "" ]
          then
            cecho r "  ERROR: The PDB $PDB_NAME does not exist in the CDB database $DATABASE_UNIQUE_NAME"
            exit 1
          fi
          # Is recovery DISABLED - it should be for us to do this
          #PDB_RECOVERY_STATUS_SQL="set heading off
          #set feedback off
          #select recovery_status from v\\\$pdbs where NAME=upper('${PDB_NAME}');
          #"          
          #PDB_RECOVERY_STATUS=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$PDB_RECOVERY_STATUS_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          ## Filter out new lines using echo
          #PDB_RECOVERY_STATUS=$(echo ${PDB_RECOVERY_STATUS})
          #if [ "$PDB_RECOVERY_STATUS" = "DISABLED" ]
          #then
          #  cecho p "WARNING: The recovery staus of PDB $PDB_NAME is DISABLED. We will have to take standby down during the process"
          #fi          
          #set -x
          # If we have not specified services then try to look up
          if [ "$USE_NODES" = "" -o  "$PDB_STANDBY_SERVICE_NAME" = "" -o  "$PDB_PRIMARY_SERVICE_NAME" = "" ]
          then
            # OK Here we check if services has been manually defined or we should try to get them from the database
            PRIMARY_SERVICES_SQL="set heading off
set feedback off
with primary_services as
(
select psgs.name, ps.service_role, ps.nordea_type, count(psgs.inst_id) number_of_nodes
from c##nordeasystem.snapshot_gv\\\$services psgs, c##nordeasystem.pdb_services ps
where upper(psgs.pdb) = upper('$PDB_NAME')
and upper(psgs.pdb) <> upper(psgs.name)
and upper(psgs.pdb) = upper(ps.pdb_name)
and upper(psgs.name) = upper(ps.service_name)
GROUP BY psgs.name,ps.service_role,ps.nordea_type
)
select name||','||service_role||','||nordea_type||','||number_of_nodes from primary_services;
"
            PRIMARY_SERVICES=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$PRIMARY_SERVICES_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
            RESULT_FROM_SERVICES=$?
            if [ $RESULT_FROM_SERVICES -ne 0 ]
            then
              echo "${PRIMARY_SERVICES}"
              cecho p "WARNING: Problem getting list of services in primary. SQL *plus returned Error code $RESULT_FROM_SERVICES."
            fi
            # Now loop over the lines that should like
            #asgertest,PRIMARY,1
            #asgertest_ro,PHYSICAL STANDBY,1
            local number_of_found_services=0
            errors_found=0
            while IFS=, read -r service service_role nordea_type use_nodes
            do
              #echo "service=$service"
              #echo "service_role=$service_role"
              #echo "nordea_type=$nordea_type"              
              #echo "use_nodes=$use_nodes"
              case $nordea_type in
                APP_SERVICE*)
                  ((number_of_found_services++))
                  PDB_PRIMARY_SERVICE_NAME=$service
                  USE_NODES=$use_nodes
                  ;;
                APP_RO_SERVICE*)
                  ((number_of_found_services++))
                  PDB_STANDBY_SERVICE_NAME=$service
                  USE_NODES=$use_nodes
                  ;;
                ADMIN_SERVICE*)
                  ((number_of_found_services++))
                  PDB_ADMIN_SERVICE_NAME=$service
                  USE_NODES=$use_nodes
                  ;;
              esac
            done <<< "$PRIMARY_SERVICES"
            if [ "$PDB_PRIMARY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Could not get primary service name from database"
              (( errors_found++ ))
            fi
            if [ "$PDB_STANDBY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: could not get standby service name from database"
              (( errors_found++ ))
            fi
            if [ "$PDB_ADMIN_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Could not get admin service name from database"
              (( errors_found++ ))
            fi
            # If we have issue here then bang out here as we can get "funny errors" from here if the unique name and pdb_name is not specified here
            if [ $errors_found -gt 0 ]
            then
            	exit 2
            fi
          fi
          # Check that service are not defined already
          # Check that services are not running here already
          #THe folloWing 3 lines needed because I uses "copied lines" below hat uses anothername - sigh!
          PDB_SERVICE=$PDB_PRIMARY_SERVICE_NAME
          PDB_SERVICE_RO=$PDB_STANDBY_SERVICE_NAME
          PDB_ADMIN_SERVICE=$PDB_ADMIN_SERVICE_NAME
          ALL_SERVICES=$($GRID_ORACLE_HOME/bin/crsctl status res -w "TYPE == ora.service.type"| grep "NAME=")
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_SERVICE}\.svc" && { cecho r "  ERROR: Service ${PDB_SERVICE} is already configured in this cluster"; exit 1; }
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_SERVICE_RO}\.svc" && { cecho r "  ERROR: Service ${PDB_SERVICE_RO} is already configured in this cluster"; exit 1; }
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_ADMIN_SERVICE}\.svc" && { cecho r "  ERROR: Service ${PDB_ADMIN_SERVICE} is already configured in this cluster"; exit 1; }
          # Find all database instances that are "offline"
          DATABASE_INSTANCES_OFFLINE=($(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME  | sed -n "s/^Instance[[:blank:]]*\(.*\)[[:blank:]]*is not running on node.*/\1/p"))
          DATABASE_INSTANCES_OFFLINE_COUNT=${#DATABASE_INSTANCES_OFFLINE[@]}
          # Find instances that are "online"
          DATABASE_INSTANCES_ONLINE=($(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME  | sed -n "s/^Instance[[:blank:]]*\(.*\)[[:blank:]]*is running on node.*/\1/p"))
          #DATABASE_INSTANCES_ONLINE=$(echo $DATABASE_INSTANCES_ONLINE)          
          # Now do some logical check. If number of instances taht the user want the service to run on is larger than number of online services hen bang out
          #DATABASE_INSTANCES_ONLINE_COUNT=$(how_many "$DATABASE_INSTANCES_ONLINE")
          DATABASE_INSTANCES_ONLINE_COUNT=${#DATABASE_INSTANCES_ONLINE[@]}
          if [ $DATABASE_INSTANCES_ONLINE_COUNT -eq 0 ]
          then
            cecho r "  ERROR: There is no active database instances running for database $DATABASE_UNIQUE_NAME"
            exit 1
          fi
          if [ $USE_NODES -gt $DATABASE_INSTANCES_ONLINE_COUNT ]
          then
            cecho r "  ERROR: Parameter --useNodes needs to be between 1 and $(how_many "$DATABASE_INSTANCES_ONLINE_COUNT") (Number of active instances)"
            exit 1
          fi
          # Generate nmumber for first instance that service will run on - use the PDB name to get consisten numbers accros similar clusters (e.g same numer of nodes)
          PDB_NAME_CKSUM=$(cksum <<< "$PDB_NAME")
          PDB_NAME_CKSUM_INTEGER=$((0x${PDB_NAME_CKSUM%% *}))
          PDB_FIRST_INSTANCE=$((PDB_NAME_CKSUM_INTEGER%DATABASE_INSTANCES_ONLINE_COUNT))
          PDB_LAST_INSTANCE=$((PDB_FIRST_INSTANCE+USE_NODES))
          # Now loop over instances atrting with the beginning one
          #set -x
          for (( instance_counter=PDB_FIRST_INSTANCE; instance_counter < PDB_LAST_INSTANCE; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            modulus_value=$((instance_counter%DATABASE_INSTANCES_ONLINE_COUNT))
            #echo "modulus_value=$modulus_value"
            if [ "$PDB_PREFERRED_INSTANCES" = "" ]
            then
              PDB_PREFERRED_INSTANCES="${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            else
              PDB_PREFERRED_INSTANCES="$PDB_PREFERRED_INSTANCES,${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            fi            
          done
          for (( instance_counter=PDB_LAST_INSTANCE; instance_counter < PDB_LAST_INSTANCE + DATABASE_INSTANCES_ONLINE_COUNT-USE_NODES ; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            modulus_value=$((instance_counter%DATABASE_INSTANCES_ONLINE_COUNT))
            #echo "modulus_value=$modulus_value"
            if [ "$PDB_AVAILABLE_INSTANCES" = "" ]
            then
              PDB_AVAILABLE_INSTANCES="${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            else
              PDB_AVAILABLE_INSTANCES="$PDB_AVAILABLE_INSTANCES,${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            fi
          done
          #echo "PDB_AVAILABLE_INSTANCES=$PDB_AVAILABLE_INSTANCES"
          # Add all offline to available
          for (( instance_counter=0; instance_counter < DATABASE_INSTANCES_OFFLINE_COUNT ; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            if [ "$PDB_AVAILABLE_INSTANCES" = "" ]
            then
              PDB_AVAILABLE_INSTANCES="${DATABASE_INSTANCES_OFFLINE[instance_counter]}"
            else
              PDB_AVAILABLE_INSTANCES="$PDB_AVAILABLE_INSTANCES,${DATABASE_INSTANCES_OFFLINE[instance_counter]}"
            fi
          done          
          # OK we should be good to go
          ;;
        delete)
          TEMP=`getopt -o "" --name "$0" --long pdbName:,databaseUniqueName:  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --pdbName) PDB_NAME=`convert_to_lower $2`;shift 2 ;;
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          #set -x
          errors_found=0
          if [ "${PDB_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --pdbName have to be specified"
            (( errors_found++ ))
          fi     
          if [ "${DATABASE_UNIQUE_NAME}" = "" ]
          then
            # Need that
            cecho r "  ERROR: Parameter --databaseUniqueName have to be specified"
            (( errors_found++ ))
          fi          
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          # Now check that CDB and PDB is there
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          #set -x
          # Get number of nodes in cluster
          NUMBER_OFF_RAC_NODES=$($GRID_ORACLE_HOME/bin/olsnodes | wc -l)
          # Maybe check if its numeric and sucseeded
          # Check if container CDB exists
          # Find ORACLE_HOME of database selected for pluggabble
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # Check that database is a container database
          # First find a node where it's configured
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
          # MAybe dubble check that stuff is actually found TBD
          # Now run SQL
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi  
          # Check if PDB exists in container
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" = "" ]
          then
            cecho r "  ERROR: The PDB $PDB_NAME does not exist in the CDB database $DATABASE_UNIQUE_NAME"
            exit 1
          fi
        ;;
      esac;;          
    pdb)
      check_for_permission oracle
      case $ACTION in
        check)
          TEMP=`getopt -o "" --name "$0" --long databaseUniqueName:,pdbName:,checks:,tryFix  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) INPUT_DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbName) INPUT_PDB_NAME=$2; shift 2 ;;
              --checks) INPUT_CHECKS="$2"; shift 2 ;;                
              --tryFix) INPUT_TRY_FIX="YES"; shift 1 ;;                
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "${INPUT_CHECKS}" != "" ]
          then
            # If ALL or empty then set them implicit
            case $INPUT_CHECKS in 
              [Aa][Ll][Ll])
                INPUT_CHECKS="space,services"
                ;;
            esac
            for ENTRY in ${INPUT_CHECKS//,/ }
            do
              #echo "ENTRY:$ENTRY"
              case $ENTRY in
                [Ss][Pp][Aa][Cc][Ee])
                  INPUT_SPACE_SPECIFIED="Y"
                  ;;
                [Ss][Ee][Rr][Vv][Ii][Cc][Ee][Ss])
                  INPUT_SERVICES_SPECIFIED="Y"
                  ;;
                *)    cecho r "  ERROR: --checks parameter $INPUT_CHECKS not known. Should be one or more of space,services or it should be all";exit 1;;
              esac  
            done
          fi
          if [ "$INPUT_DATABASE_UNIQUE_NAME" != "" ]
          then
            # Check that specified CDB exists
            # Ensure GRID_ORACLE__HOME is set
            set_grid_home
            # Check that the database exists
            ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${INPUT_DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
            if [ "$ORACLE_HOME" = "" ]
            then
              cecho r "  ERROR: Can't find database $INPUT_DATABASE_UNIQUE_NAME on this cluster"
              exit 1
            fi
            if [ "$INPUT_PDB_NAME" != "" ]
            then
              # If the PDB is specified check it's there
              # First find a node where it's configured
              local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
              if [ "$node_selected" = "" ]
              then
                cecho r "  ERROR: Can't get node where there is a instanse of ${INPUT_DATABASE_UNIQUE_NAME} running"
                exit 1
              fi
              # Then find instance on that node
              local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
              if [ "$node_selected" = "" ]
              then
                cecho r "  ERROR: Can't get a running instanse of ${INPUT_DATABASE_UNIQUE_NAME}"
                exit 1
              fi
              # MAybe dubble check that stuff is actually found TBD
              # Now run SQL
              IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
              # Filter out new lines using echo
              IS_DB_CDB=$(echo ${IS_DB_CDB})
              if [ "$IS_DB_CDB" != "YES" ]
              then
                cecho r "  ERROR: The database $INPUT_DATABASE_UNIQUE_NAME is not a cdb"
                exit 1
              fi  
              # Check if PDB exists in container
              # Test if PDB exists
              FOUND_PDB_NAME_SQL="set heading off
              set feedback off
              select lower(name) from v\\\$pdbs where lower(NAME) = lower('${INPUT_PDB_NAME}');
              "
              FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
              # Filter out new lines using echo
              FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
              if [ "$FOUND_PDB_NAME" = "" ]
              then
                cecho r "  ERROR: The PDB $INPUT_PDB_NAME does not exist in the CDB database $INPUT_DATABASE_UNIQUE_NAME"
                exit 1
              fi
            fi
          fi
          ;;
        list)
          TEMP=`getopt -o "" --name "$0" --long GUID:,databaseUniqueName:,dataOnly  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) INPUT_DB_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --GUID) INPUT_GUID=$2; shift 2 ;;
              --dataOnly) INPUT_DATA_ONLY="YES"; shift 1 ;;                
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          ;;
        delete)
          TEMP=`getopt -o "" --name "$0" --long pdbName:,databaseUniqueName:  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbName) PDB_NAME=$2; shift 2 ;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --databaseUniqueName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "$PDB_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --pdbName needs to be specified"
            (( errors_found++ ))
          fi
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          # Check that database exists and find Oracle home
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # First find a first node where it exists
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p") 
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi
          #set -x
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" == "" ]
          then
            cecho r "  ERROR: The PDB $PDB_NAME does not exist in this database"
            exit 1
          fi
          # So now we know he pdb is there and we have som enodes to run commands on
          ;;
        harden)
          TEMP=`getopt -o "" --name "$0" --long pdbName:,databaseUniqueName:,fixStaticGrants  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbName) PDB_NAME=$2; shift 2 ;;
              --fixStaticGrants) PDB_FIX_STATIC_GRANTS="YES"; shift 1 ;; 
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --databaseUniqueName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "$PDB_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --pdbName needs to be specified"
            (( errors_found++ ))
          fi
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          # Check that database exists and find Oracle home
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Cam't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # First find a first node where it exists
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p") 
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi
          #set -x
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" == "" ]
          then
            cecho r "  ERROR: The PDB $PDB_NAME does not exist in this database"
            exit 1
          fi
          # So now we know he pdb is there and we have som enodes to run commands on
          ;;
        dgfinish)
          TEMP=`getopt -o "" --name "$0" --long useNodes:,pdbName:,databaseUniqueName:,primaryTnsServiceName:,pdbPrimaryServiceName:,pdbStandbyServiceName:,useNodes:,pdbAdminServiceName: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --pdbName) PDB_NAME=`convert_to_lower $2`;shift 2 ;;
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --primaryTnsServiceName) PRIMARY_TNS_SERVICE_NAME=$2 ;shift 2 ;; 
              --pdbPrimaryServiceName) PDB_PRIMARY_SERVICE_NAME=$2; shift 2;;
              --pdbStandbyServiceName) PDB_STANDBY_SERVICE_NAME=$2; shift 2;;                
              --pdbAdminServiceName) PDB_ADMIN_SERVICE_NAME=$2; shift 2;;                
              --useNodes) USE_NODES=$2 ;shift 2 ;; 
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          # Check service names length (30 characters?=
          if [ ${#PDB_PRIMARY_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbPrimaryServicename $PDB_PRIMARY_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi              
          # Check service names length (30 characters?=
          if [ ${#PDB_STANDBY_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbStandbyServicename $PDB_STANDBY_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi             
          # Check service names length (30 characters?=
          if [ ${#PDB_ADMIN_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbAdminServicename $PDB_ADMIN_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi             
          if [ "$PDB_NAME" = "" ]
          then
            # Ouch file needs to be there
            cecho r "  ERROR: Parameter --pdbName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "$DATABASE_UNIQUE_NAME" = "" ]
          then
            # Ouch file needs to be there
            cecho r "  ERROR: Parameter --databaseUniqueName needs to be specified"
            (( errors_found++ ))
          fi
          # if one is there They all need to be there. If not sopecified we will later try to grap themm from the database
          if [ "$USE_NODES" != "" -o  "$PDB_STANDBY_SERVICE_NAME" != "" -o  "$PDB_PRIMARY_SERVICE_NAME" != "" -o "$PDB_ADMIN_SERVICE_NAME" != "" ]
          then
            if [ "$PDB_PRIMARY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Parameter --pdbPrimaryServiceName needs to be specified"
              (( errors_found++ ))
            fi
            if [ "$PDB_STANDBY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Parameter --pdbStandbyServiceName needs to be specified"
              (( errors_found++ ))
            fi
            if [ "$PDB_ADMIN_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Parameter --pdbAdminServiceName needs to be specified"
              (( errors_found++ ))
            fi
            case ${USE_NODES} in
              "")
                cecho r "  ERROR: Parameter --useNodes needs to be specified]"
                (( errors_found++ ))
                ;;
              1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16)
                # Do nothing
                :
                ;;
              *)
                cecho r "  ERROR: Parameter --useNodes needs to be one of [1-16]"
                (( errors_found++ ))
                ;;
            esac
          fi
          # If we have issue here then bang out here as we can het "funny errors" fro mhere if the unique name and pdb_name is not specified here
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          #set -x
          # Get number of nodes in cluster
          NUMBER_OFF_RAC_NODES=$($GRID_ORACLE_HOME/bin/olsnodes | wc -l)
          # Maybe check if its numeric and sucseeded
          # Check if container CDB exists
          # Find ORACLE_HOME of database selected for pluggabble
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # Check that database is a container database
          # First find a node where it's configured
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
          # MAybe dubble check that stuff is actually found TBD
          # Now run SQL
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi  
          # Are we running as a standby database
          # Get the Primary database
          # Try to get primary database name, if that is empty we are not running as standby
          PRIMARY_DB_NAME_ON_STANDBY=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$PRIMARY_DB_NAME_ON_STANDBY_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          PRIMARY_DB_NAME_ON_STANDBY=$(echo ${PRIMARY_DB_NAME_ON_STANDBY})
          if [ "$PRIMARY_DB_NAME_ON_STANDBY" = "" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not running as a standby database"
            exit 1
          fi        
          # If not PRIMARY_TNS_SERVICE_NAME set then set it to primary database name 
          if [ "$PRIMARY_TNS_SERVICE_NAME" = "" ]
          then
            PRIMARY_TNS_SERVICE_NAME=$PRIMARY_DB_NAME_ON_STANDBY
          fi
          # Check that we can "ping" primaryservice
          # Try to get primary database name, if that is empty we are not running as standby
          RESULT_FROM_PING=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; $ORACLE_HOME/bin/tnsping ${PRIMARY_TNS_SERVICE_NAME}")
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: The TNS NAME entry $PRIMARY_TNS_SERVICE_NAME ca't be pinged"
            exit 1
          fi  
          # Check if PDB exists in container
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" = "" ]
          then
            cecho r "  ERROR: The PDB $PDB_NAME does not exist in the CDB database $DATABASE_UNIQUE_NAME"
            exit 1
          fi
          # Is recovery DISABLED - it should be for us to do this
          PDB_RECOVERY_STATUS_SQL="set heading off
          set feedback off
          select recovery_status from v\\\$pdbs where NAME=upper('${PDB_NAME}');
          "          
          PDB_RECOVERY_STATUS=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$PDB_RECOVERY_STATUS_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          PDB_RECOVERY_STATUS=$(echo ${PDB_RECOVERY_STATUS})
          if [ "$PDB_RECOVERY_STATUS" = "DISABLED" ]
          then
            cecho p "WARNING: The recovery staus of PDB $PDB_NAME is DISABLED. We will have to take standby down during the process"
          fi          
          #set -x
          # If we have not soecified services then try to look up
          if [ "$USE_NODES" = "" -o  "$PDB_STANDBY_SERVICE_NAME" = "" -o  "$PDB_PRIMARY_SERVICE_NAME" = "" ]
          then
            # OK Here we check if services has been manually defined or we should try to get them from the database
            PRIMARY_SERVICES_SQL="set heading off
set feedback off
with primary_services as
(
select psgs.name, ps.service_role, ps.nordea_type, count(psgs.inst_id) number_of_nodes
from c##nordeasystem.snapshot_gv\\\$services psgs, c##nordeasystem.pdb_services ps
where upper(psgs.pdb) = upper('$PDB_NAME')
and upper(psgs.pdb) <> upper(psgs.name)
and upper(psgs.pdb) = upper(ps.pdb_name)
and upper(psgs.name) = upper(ps.service_name)
GROUP BY psgs.name,ps.service_role,ps.nordea_type
)
select name||','||service_role||','||nordea_type||','||number_of_nodes from primary_services;
"
            PRIMARY_SERVICES=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$PRIMARY_SERVICES_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
            RESULT_FROM_SERVICES=$?
            if [ $RESULT_FROM_SERVICES -ne 0 ]
            then
              echo "${PRIMARY_SERVICES}"
              cecho p "WARNING: Problem getting list of services in primary. SQL *plus returned Error code $RESULT_FROM_SERVICES."
            fi
            # Now loop over the lines that should like
            #asgertest,PRIMARY,1
            #asgertest_ro,PHYSICAL STANDBY,1
            local number_of_found_services=0
            errors_found=0
            while IFS=, read -r service service_role nordea_type use_nodes
            do
              #echo "service=$service"
              #echo "service_role=$service_role"
              #echo "nordea_type=$nordea_type"              
              #echo "use_nodes=$use_nodes"
              case $nordea_type in
                APP_SERVICE*)
                  ((number_of_found_services++))
                  PDB_PRIMARY_SERVICE_NAME=$service
                  USE_NODES=$use_nodes
                  ;;
                APP_RO_SERVICE*)
                  ((number_of_found_services++))
                  PDB_STANDBY_SERVICE_NAME=$service
                  USE_NODES=$use_nodes
                  ;;
                ADMIN_SERVICE*)
                  ((number_of_found_services++))
                  PDB_ADMIN_SERVICE_NAME=$service
                  USE_NODES=$use_nodes
                  ;;
              esac
            done <<< "$PRIMARY_SERVICES"
            if [ "$PDB_PRIMARY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Could not get primary service name from database"
              (( errors_found++ ))
            fi
            if [ "$PDB_STANDBY_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: could not get standby service name from database"
              (( errors_found++ ))
            fi
            if [ "$PDB_ADMIN_SERVICE_NAME" = "" ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: Could not get admin service name from database"
              (( errors_found++ ))
            fi
            # If we have issue here then bang out here as we can get "funny errors" from here if the unique name and pdb_name is not specified here
            if [ $errors_found -gt 0 ]
            then
            	exit 2
            fi
          fi
          # Check that service are not defined already
          # Check that services are not running here already
          #THe folloWing 3 lines needed because I uses "copied lines" below hat uses anothername - sigh!
          PDB_SERVICE=$PDB_PRIMARY_SERVICE_NAME
          PDB_SERVICE_RO=$PDB_STANDBY_SERVICE_NAME
          PDB_ADMIN_SERVICE=$PDB_ADMIN_SERVICE_NAME
          ALL_SERVICES=$($GRID_ORACLE_HOME/bin/crsctl status res -w "TYPE == ora.service.type"| grep "NAME=")
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_SERVICE}\.svc" && { cecho r "  ERROR: Service ${PDB_SERVICE} is already configured in this cluster"; exit 1; }
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_SERVICE_RO}\.svc" && { cecho r "  ERROR: Service ${PDB_SERVICE_RO} is already configured in this cluster"; exit 1; }
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_ADMIN_SERVICE}\.svc" && { cecho r "  ERROR: Service ${PDB_ADMIN_SERVICE} is already configured in this cluster"; exit 1; }
          # Find all database instances that are "offline"
          DATABASE_INSTANCES_OFFLINE=($(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME  | sed -n "s/^Instance[[:blank:]]*\(.*\)[[:blank:]]*is not running on node.*/\1/p"))
          DATABASE_INSTANCES_OFFLINE_COUNT=${#DATABASE_INSTANCES_OFFLINE[@]}
          # Find instances that are "online"
          DATABASE_INSTANCES_ONLINE=($(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME  | sed -n "s/^Instance[[:blank:]]*\(.*\)[[:blank:]]*is running on node.*/\1/p"))
          #DATABASE_INSTANCES_ONLINE=$(echo $DATABASE_INSTANCES_ONLINE)          
          # Now do some logical check. If number of instances taht the user want the service to run on is larger than number of online services hen bang out
          #DATABASE_INSTANCES_ONLINE_COUNT=$(how_many "$DATABASE_INSTANCES_ONLINE")
          DATABASE_INSTANCES_ONLINE_COUNT=${#DATABASE_INSTANCES_ONLINE[@]}
          if [ $DATABASE_INSTANCES_ONLINE_COUNT -eq 0 ]
          then
            cecho r "  ERROR: There is no active database instances running for database $DATABASE_UNIQUE_NAME"
            exit 1
          fi
          if [ $USE_NODES -gt $DATABASE_INSTANCES_ONLINE_COUNT ]
          then
            cecho r "  ERROR: Parameter --useNodes needs to be between 1 and $(how_many "$DATABASE_INSTANCES_ONLINE_COUNT") (Number of active instances)"
            exit 1
          fi
          # Generate nmumber for first instance that service will run on - use the PDB name to get consisten numbers accros similar clusters (e.g same numer of nodes)
          PDB_NAME_CKSUM=$(cksum <<< "$PDB_NAME")
          PDB_NAME_CKSUM_INTEGER=$((0x${PDB_NAME_CKSUM%% *}))
          PDB_FIRST_INSTANCE=$((PDB_NAME_CKSUM_INTEGER%DATABASE_INSTANCES_ONLINE_COUNT))
          PDB_LAST_INSTANCE=$((PDB_FIRST_INSTANCE+USE_NODES))
          # Now loop over instances atrting with the beginning one
          #set -x
          for (( instance_counter=PDB_FIRST_INSTANCE; instance_counter < PDB_LAST_INSTANCE; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            modulus_value=$((instance_counter%DATABASE_INSTANCES_ONLINE_COUNT))
            #echo "modulus_value=$modulus_value"
            if [ "$PDB_PREFERRED_INSTANCES" = "" ]
            then
              PDB_PREFERRED_INSTANCES="${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            else
              PDB_PREFERRED_INSTANCES="$PDB_PREFERRED_INSTANCES,${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            fi            
          done
          for (( instance_counter=PDB_LAST_INSTANCE; instance_counter < PDB_LAST_INSTANCE + DATABASE_INSTANCES_ONLINE_COUNT-USE_NODES ; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            modulus_value=$((instance_counter%DATABASE_INSTANCES_ONLINE_COUNT))
            #echo "modulus_value=$modulus_value"
            if [ "$PDB_AVAILABLE_INSTANCES" = "" ]
            then
              PDB_AVAILABLE_INSTANCES="${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            else
              PDB_AVAILABLE_INSTANCES="$PDB_AVAILABLE_INSTANCES,${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            fi
          done
          #echo "PDB_AVAILABLE_INSTANCES=$PDB_AVAILABLE_INSTANCES"
          # Add all offline to available
          for (( instance_counter=0; instance_counter < DATABASE_INSTANCES_OFFLINE_COUNT ; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            if [ "$PDB_AVAILABLE_INSTANCES" = "" ]
            then
              PDB_AVAILABLE_INSTANCES="${DATABASE_INSTANCES_OFFLINE[instance_counter]}"
            else
              PDB_AVAILABLE_INSTANCES="$PDB_AVAILABLE_INSTANCES,${DATABASE_INSTANCES_OFFLINE[instance_counter]}"
            fi
          done          
          # OK we should be good to go
          ;;
        setresources)
          TEMP=`getopt -o "" --name "$0" --long useProfile:,pdbName:,databaseUniqueName:,useSGAMemory:,useCpuCount:,useStorageCapacity:,useStorageIops:,useStorageBandwidth: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --useProfile) USE_PROFILE=$2 ;shift 2 ;; 
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --useSGAMemory) USE_SGA_MEMORY=$2; shift 2;;
              --useCpuCount) USE_CPU_COUNT=$2; shift 2;;                
              --useStorageCapacity) USE_STORAGE_CAPACITY=$2; shift 2;;                
              --useStorageIops) USE_STORAGE_IOPS=$2; shift 2;;                
              --useStorageBandwidth) USE_STORAGE_BANDWIDTH=$2; shift 2;;
              --pdbName) PDB_NAME=`convert_to_lower $2`;shift 2 ;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --databaseUniqueName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "$PDB_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --pdbName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "${USE_SGA_MEMORY}" != "" ]
          then
            # Verify values
            USE_SGA_MEMORY_PROFILE=$(check_sga_memory_profile "${USE_SGA_MEMORY}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_SGA_MEMORY_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_CPU_COUNT}" != "" ]
          then
            # Verify values
            USE_CPU_COUNT_PROFILE=$(check_cpu_count_profile "${USE_CPU_COUNT}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_CPU_COUNT_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_STORAGE_CAPACITY}" != "" ]
          then
            # Verify values
            USE_STORAGE_CAPACITY_PROFILE=$(check_storage_capacity_profile "${USE_STORAGE_CAPACITY}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_STORAGE_CAPACITY_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_STORAGE_IOPS}" != "" ]
          then
            # Verify values
            USE_STORAGE_IOPS_PROFILE=$(check_storage_iops_profile "${USE_STORAGE_IOPS}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_STORAGE_IOPS_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_STORAGE_BANDWIDTH}" != "" ]
          then
            # Verify values
            USE_STORAGE_BANDWIDTH_PROFILE=$(check_storage_bandwidth_profile "${USE_STORAGE_BANDWIDTH}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_STORAGE_BANDWIDTH_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
            
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          # Check that database exists and find Oracle home
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Cam't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # First find a first node where it exists
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p") 
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi
          # DB Should be primary
          # Check that this is a primary database
          last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_PRIMARY_SQL" "-S" )
          local last_error_code=$?
          if [ $last_error_code -ne 0 ]
          then
            # failed
            cecho r "  ERROR: Call to get primary database name on primary failed with code=$last_error_code and error text=$last_result"
            exit 1 
          else
            # success
            local PRIMARY_DB_NAME_ON_PRIMARY=$(echo ${last_result})
            if [ "$PRIMARY_DB_NAME_ON_PRIMARY" = "" ]
            then
              cecho r "  ERROR: $DATABASE_UNIQUE_NAME is not running as a primary database - only works on primary databases"
              exit 2
            fi     
          fi
          # Check if PDB exists in container
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" = "" ]
          then
            cecho r "  ERROR: The PDB $INPUT_PDB_NAME does not exist in the CDB database $INPUT_DATABASE_UNIQUE_NAME"
            exit 1
          fi
          ;;
        create)
          TEMP=`getopt -o "" --name "$0" --long useProfile:,pdbFriendlyName:,nlsLengthSemantics:,prepareForMigration,noStandbys,forceMultiplePdbs,pdbPlugFile:,pdbPrimaryServicename:,pdbStandbyServicename:,pdbName:,pdbFreeName:,pdbApplicationCode:,pdbEnvironment:,pdbDatePart:,databaseUniqueName:,useSGAMemory:,useCpuCount:,useStorageCapacity:,useStorageIops:,useStorageBandwidth:,useNodes: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --useNodes) USE_NODES=$2 ;shift 2 ;; 
              --useProfile) USE_PROFILE=$2 ;shift 2 ;; 
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --useSGAMemory) USE_SGA_MEMORY=$2; shift 2;;
              --useCpuCount) USE_CPU_COUNT=$2; shift 2;;                
              --useStorageCapacity) USE_STORAGE_CAPACITY=$2; shift 2;;                
              --useStorageIops) USE_STORAGE_IOPS=$2; shift 2;;                
              --useStorageBandwidth) USE_STORAGE_BANDWIDTH=$2; shift 2;;
              --pdbFriendlyName) PDB_FRIENDLY_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbFreeName) PDB_FREE_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbName) PDB_NAME=`convert_to_lower $2`;shift 2 ;;
              --pdbApplicationCode) PDB_APPLICATION_CODE=`convert_to_lower $2`;shift 2 ;;
              --pdbEnvironment) PDB_ENVIRONMENT=`convert_to_lower $2`;shift 2 ;;
              --pdbDatePart) PDB_DATE_PART=$2; shift 2;;
              --pdbPrimaryServicename) PDB_PRIMARY_SERVICE_NAME=$2; shift 2;;
              --pdbStandbyServicename) PDB_STANDBY_SERVICE_NAME=$2; shift 2;;
              --pdbAdminServiceName) PDB_ADMIN_SERVICE_NAME=$2; shift 2;;                
              --pdbPlugFile) PDB_PLUG_FILE=$2; shift 2;;
              --nlsLengthSemantics) PDB_NLS_LENGTH_SEMANTICS=`convert_to_lower $2`;shift 2 ;;
              --forceMultiplePdbs) INPUT_FORCE_MULTIPLE_PDBS="YES"; shift 1 ;;  
              --prepareForMigration) PDB_PREPARE_FOR_MIGRATION="YES"; shift 1 ;;
              --noStandbys) PDB_STANDBYS="NONE"; shift 1 ;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          if [ "$PDB_NLS_LENGTH_SEMANTICS" = "" ]
          then
            # Default value
            PDB_NLS_LENGTH_SEMANTICS="char"
          fi
          case $PDB_NLS_LENGTH_SEMANTICS in
            char|byte)
              :
              ;;
            *)
              cecho r "  ERROR: Parameter --nlsLengthSemantics should be one of [char|byte]"
              (( errors_found++ ))
              ;;
          esac
          if [ "$PDB_PLUG_FILE" != "" ]
          then
            if [ ! -f $PDB_PLUG_FILE ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: File given to parameter --pdbPlugFile does not exist"
              (( errors_found++ ))
            fi
          fi
          if [ "${PDB_DATE_PART}" != "" -o "${PDB_ENVIRONMENT}" != "" -o "${PDB_APPLICATION_CODE}" != "" -o "${PDB_FREE_NAME}" = "" -o "${PDB_FRIENDLY_NAME}" != "" ]
          then
            # OK He wants to use individual components and build the name himself
            # Check that the other parameters that could be used is not specified
            if [ "${PDB_NAME}" != "" ]
            then
              # Ouch you can't do both
              cecho r "  ERROR: Parameter --pdbName can't be used when one of --pdbFriendlyName --pdbDatePart  --pdbEnvironment, --pdbApplicationCode and --pdbFreeName specified"
              (( errors_found++ ))
            else
              # We know he want to use individual parts, chech taht he uses ether --pdbFriendlyName or -pdbFreeName and --pdbEnvironment
              if [ "$PDB_FRIENDLY_NAME" = "" -a  "$PDB_FREE_NAME" = "" ]
              then
                # Ouch need one
                cecho r "  ERROR: One of the parameters --pdbFriendlyName and --pdbFreeName needs to be specified"
                (( errors_found++ ))                
              else
                if [ "$PDB_FRIENDLY_NAME" != "" -a  "$PDB_FREE_NAME" != "" ]
                then
                  # Ouch you can't do both
                  cecho r "  ERROR: Only one of the parameter --pdbFriendlyName and --pdbFreeName can be specified"
                  (( errors_found++ ))                
                else
                  # Now we know that excatly one of --pdbFriendlyName and --pdbFreeName has been specified
                  if [ "$PDB_FRIENDLY_NAME" != "" ]
                  then
                    if [ "${PDB_ENVIRONMENT}" != "" ]
                    then
                    	cecho r "  ERROR: --pdbEnvironment  can not be specified together with --pdbFriendlyName"
                      (( errors_found++ ))
                    fi
                    if [ ${#PDB_FRIENDLY_NAME} -gt 11 ]
                    then
                    	cecho r "  ERROR: --pdbFriendlyName is to long, Max size is 11"
                      (( errors_found++ ))
                    fi
                    if [ ${#PDB_FRIENDLY_NAME} -lt 2 ]
                    then
                    	cecho r "  ERROR: --pdbFriendlyName is to short, Min size is 2"
                      (( errors_found++ ))
                    fi                   
                    # Get the FREE_NAME
                    PDB_FREE_NAME="${PDB_FRIENDLY_NAME%?}"
                    # Get the two parts and check them
                    PDB_ENVIRONMENT="${PDB_FRIENDLY_NAME: -1}"
                    case $PDB_ENVIRONMENT in
                      s|t|d|p)
                        :
                        ;;
                      *)
                        cecho r "  ERROR: Last character in --pdbFriendlyName need to be one off s|t|d|p"
                        (( errors_found++ ));;                          
                    esac
                  fi
                fi
              fi
            fi
          else
            # He Should use --pdbName to move on here 
            # Check that it's the only one used
            if [ "${PDB_NAME}" = "" ]
            then
              # Ouch Something needs to be specified
              cecho r "  ERROR: Parameter --pdbName or 'some of' --pdbFriendlyName, --pdbDatePart,  --pdbEnvironment, --pdbApplicationCode and -pdbFreeName has to be specified"
              (( errors_found++ ))
            else
              # OK he specified PDB_NAME and only that
              # Extract PDBNAME and environment from PDB_FREE_NAME
              #set -x
              regex_pdb_name='^p_([^_]*)_([^_]*)_([^_]*)_([^_]*$)'  
              [[ $PDB_NAME =~ $regex_pdb_name ]]
              PDB_FREE_NAME=${BASH_REMATCH[1]}
              PDB_APPLICATION_CODE=${BASH_REMATCH[2]}
              PDB_DATE_PART=${BASH_REMATCH[3]}
              PDB_ENVIRONMENT=${BASH_REMATCH[4]}
              if [ "$PDB_FREE_NAME" = "" -o "$PDB_APPLICATION_CODE" = "" -o "$PDB_DATE_PART" = "" -o "$PDB_ENVIRONMENT" = "" -o "$PDB_EXTRA_PART" != "" ]
              then
                cecho r "  ERROR: Parameter the --pdbName can not be split using the following model p_<pdb free name>_<pdb aplicaton code>_<pdb date part>_<environment>"
                (( errors_found++ ))
              fi
            fi
          fi
          # If we have issue here then bang out here as we can het "funny errors" fromhere if the pdb_name is not OK here
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          if [ "$PDB_DATE_PART" != "" ]
          then
            # Check format
            regex_pdb_date_part='^([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$)'
            [[ $PDB_DATE_PART =~ $regex_pdb_date_part ]]
            if [ $? -ne 0 ]
            then
              cecho r "  ERROR: Parameter the --pdbdatePart needs to consist of 8 numeric characters"
              (( errors_found++ ))
            fi    
          fi
          if [ "$PDB_FREE_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --pdbFreeName <free part of pluggable name> needs to be specified"
            (( errors_found++ ))
          fi
          if [ ${#PDB_FREE_NAME} -gt 10 ]
          then
          	cecho r "  ERROR: --pdbFreeName $PDB_FREE_NAME is to long, Max size is 10"
            (( errors_found++ ))
          fi
          if [ "$PDB_APPLICATION_CODE" == "" ]
          then
            cecho r "  ERROR: Parameter --pdbApplicationCode <free part of pluggable name> needs to be specified"
            (( errors_found++ ))
          fi
          if [ ${#PDB_APPLICATION_CODE} -gt 6 ]
          then
          	cecho r "  ERROR: --pdbApplicationCode $PDB_APPLICATION_CODE is to long, Max size is 6"
            (( errors_found++ ))
          fi          
          case ${PDB_ENVIRONMENT} in
            s)
              # OK
              PDB_ADMIN_HASH_PASSWORD="${SANDBOX_PDB_ADMIN_PASSWORD}"
              ;;
            t)
              # OK
              PDB_ADMIN_HASH_PASSWORD="${TEST_PDB_ADMIN_PASSWORD}"
              ;;
            d)
              # OK
              PDB_ADMIN_HASH_PASSWORD="${DEMO_PDB_ADMIN_PASSWORD}"
              ;;
            p)
              # OK
              PDB_ADMIN_HASH_PASSWORD="${PROD_PDB_ADMIN_PASSWORD}"
              ;;
            *)
              cecho r "  ERROR: Parameter --pdbEnvironment needs to be one of [s|t|d|p]"
              (( errors_found++ ))
              ;;
          esac
          #Check the environment given
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --databaseUniqueName <database unique name> needs to be specified"
            (( errors_found++ ))
          else
            #set -x
            # Here somehow check that we don't create pdbs in environments we should not
            # Business criticality is first character (eg s(td), h(a) or b(ca)
            CDB_BUSINESS_CRITICALITY="${DATABASE_UNIQUE_NAME:0:1}"
            if [[ "${CDB_BUSINESS_CRITICALITY}" != [zsfhb] ]]
            then
              cecho r "  ERROR: First character in --databaseUniqueName needs to be in the set [zsfhb]"
              (( errors_found++ ))
            fi
            # Get last character of DB Unique name which is environmet
            CDB_ENVIRONMENT=$(convert_to_lower "${DATABASE_UNIQUE_NAME:${#DATABASE_UNIQUE_NAME}-3:1}")
            if [[ "${CDB_ENVIRONMENT}" != [pdts] ]]
            then
              cecho r "  ERROR: Third last character in --databaseUniqueName needs to be in the following set [pdts]"
            fi
            DATACENTER_UNIQUE_NUMBER=$(convert_to_lower "${DATABASE_UNIQUE_NAME:${#DATABASE_UNIQUE_NAME}-2:1}")
            if [[ "${DATACENTER_UNIQUE_NUMBER}" != [1-9] ]]
            then
              cecho r "  ERROR: Second last character in --databaseUniqueName  needs to be in the set [1-9]"
              (( errors_found++ ))
            fi
            case $PDB_ENVIRONMENT in
              p)
                # Prod
                case $CDB_ENVIRONMENT in
                  p)
                    # OK
                    :
                    ;;
                  *)
                    # Not OK
                    cecho r "  ERROR: Not allowed to create PDB environment $PDB_ENVIRONMENT in CDB environment $CDB_ENVIRONMENT"
                    (( errors_found++ ))
                    ;;
                 esac
                ;;
              d)
                # Preprod
                case $CDB_ENVIRONMENT in
                  d)
                    # OK
                    :
                    ;;
                  *)
                    # Not OK
                    cecho r "  ERROR: Not allowed to create PDB environment $PDB_ENVIRONMENT in CDB environment $CDB_ENVIRONMENT"
                    (( errors_found++ ))
                    ;;
                 esac
                ;;
              t)
                # Test
                case $CDB_ENVIRONMENT in
                  t|s)
                    # OK
                    :
                    ;;
                  *)
                    # Not OK
                    cecho r "  ERROR: Not allowed to create PDB environment $PDB_ENVIRONMENT in CDB environment $CDB_ENVIRONMENT"
                    (( errors_found++ ))
                    ;;
                 esac
                ;;
              s)
                # Sandbox
                #No rules
                :
                ;;  
            esac
          fi
          #set -x
	        if [ "$USE_PROFILE" != "" ]
	        then
            # --useProfile is defined
  	        # Check that profile is a supported one and set parameters accordingly
            case $USE_PROFILE in
              pico)
                USE_CPU_COUNT=1
                USE_SGA_MEMORY=4gb
                USE_STORAGE_CAPACITY=2tb
                USE_STORAGE_IOPS=10000iops
                USE_STORAGE_BANDWIDTH=100000mbps
                ;;
              micro)
                USE_CPU_COUNT=2
                USE_SGA_MEMORY=8gb
                USE_STORAGE_CAPACITY=4tb
                USE_STORAGE_IOPS=20000iops
                USE_STORAGE_BANDWIDTH=200000mbps
                ;;
              tiny) 
                USE_CPU_COUNT=4
                USE_SGA_MEMORY=16gb
                USE_STORAGE_CAPACITY=10tb
                USE_STORAGE_IOPS=100000iops
                USE_STORAGE_BANDWIDTH=1gbps
                ;;
              small) 
                USE_CPU_COUNT=8
                USE_SGA_MEMORY=32gb
                USE_STORAGE_CAPACITY=20tb
                USE_STORAGE_IOPS=100000iops
                USE_STORAGE_BANDWIDTH=2gbps
                ;;
              medium) 
                USE_CPU_COUNT=16
                USE_SGA_MEMORY=64gb
                USE_STORAGE_CAPACITY=40tb
                USE_STORAGE_IOPS=200000iops
                USE_STORAGE_BANDWIDTH=4gbps
                ;;
              large)
                USE_CPU_COUNT=32
                USE_SGA_MEMORY=128gb
                USE_STORAGE_CAPACITY=100tb
                USE_STORAGE_IOPS=4000000iops
                USE_STORAGE_BANDWIDTH=10gbps
                ;;
              *)
                cecho r "  ERROR: --useProfile $USE_PROFILE not supported should be one of: pico,micro,tiny,small,medium,large"
                (( errors_found++ ))
                ;;
            esac         
          fi
          if [ "${USE_SGA_MEMORY}" = "" -o "${USE_CPU_COUNT}" = "" -o "${USE_STORAGE_CAPACITY}" = "" -o "${USE_STORAGE_IOPS}" = "" -o "${USE_STORAGE_BANDWIDTH}" = "" ]
          then
            cecho r "  ERROR: either --useProfile or ( --useSGAMemory, --useCpuCount, --useStorageCapacity, --useStorageIops and --useStorageBandwidth ) need to be specified"
            (( errors_found++ ))
          else
            # All --use* is specified, check tkeir values
            case ${USE_CPU_COUNT} in
              1|2|4|6|8|12|16|24|32|48|64)
                # Extract the number and build the profile name
                USE_CPU_COUNT_PROFILE="cpu_${USE_CPU_COUNT}"
                ;;
              *)
                cecho r "  ERROR: Parameter --useCpuCount needs to be one of [1|2|4|6|8|12|16|24|32|48|64]"
                (( errors_found++ ))
                ;;
            esac
            case ${USE_SGA_MEMORY} in
              1gb|2gb|4gb|6gb|8gb|12gb|16gb|24gb|32gb|48gb|64gb|96gb|128gb|192gb|256gb|384gb|512gb) 
                # Extract the number and build the profile name
                USE_SGA_MEMORY_PROFILE="memory_${USE_SGA_MEMORY//gb/_gb}"
                ;;
              *)
                cecho r "  ERROR: Parameter --useSGAMemory needs to be one of [1gb|2gb|4gb|6gb|8gb|12gb|16gb|24gb|32gb|48gb|64gb|96gb|128gb|192gb|256gb|384gb|512gb]"
                (( errors_found++ ))
                ;;
            esac
            case ${USE_STORAGE_CAPACITY} in
              100gb|200gb|400gb)
                # Extract the number and build the profile name
                USE_STORAGE_CAPACITY_PROFILE="storagecapacity_${USE_STORAGE_CAPACITY//gb/_gb}"
                ;;
              1tb|2tb|4tb|10tb|20tb|40tb|100tb|200tb|400tb)
                # Extract the number and build the profile name
                USE_STORAGE_CAPACITY_PROFILE="storagecapacity_${USE_STORAGE_CAPACITY//tb/_tb}"
                ;;
              *)
                cecho r "  ERROR: Parameter --useStorageCapacity needs to be one of [100gb|200gb|400gb|1tb|2tb|4tb|10tb|20tb|40tb|100tb|200tb|400tb]"
                (( errors_found++ ))
                ;;
            esac
            case ${USE_STORAGE_IOPS} in
              100iops|1000iops|10000iops|100000iops|1000000iops|200iops|2000iops|20000iops|200000iops|2000000iops|400iops|4000iops|40000iops|400000iops|4000000iops)
                # Extract the number and build the profile name
                USE_STORAGE_IOPS_PROFILE="storageiops_${USE_STORAGE_IOPS//iops/_iops}"
                ;;
              *)
                cecho r "  ERROR: Parameter --useStorageIops needs to be one of [100iops|1000iops|10000iops|100000iops|1000000iops|200iops|2000iops|20000iops|200000iops|2000000iops|400iops|4000iops|40000iops|400000iops|4000000iops]"
                (( errors_found++ ))
                ;;
            esac
            case ${USE_STORAGE_BANDWIDTH} in
              1mbps|10mbps|100mbps|2mbps|20mbps|200mbps|4mbps|40mbps|400mbps)
                # Extract the number and build the profile name
                USE_STORAGE_BANDWIDTH_PROFILE="storagebandwidth_${USE_STORAGE_BANDWIDTH//mbps/_mbps}"
                ;;
              1gbps|10gbps|2gbps|20gbps|4gbps|40gbps)
                # Extract the number and build the profile name
                USE_STORAGE_BANDWIDTH_PROFILE="storagebandwidth_${USE_STORAGE_BANDWIDTH//gbps/_gbps}"
                ;;
              *)
                cecho r "  ERROR: Parameter --useStorageBandwidth needa to be one of [1mbps|2mbps|4mbps|10mbps|20mbps|40mbps|100mbps|200mbps|200mbps|1gbps|2gbps|4gbps|10gbps|20gbps|40gbps]"
                (( errors_found++ ))
                ;;
            esac
          fi     
          case ${USE_NODES} in
            "")
              cecho r "  ERROR: Parameter --useNodes needs to be specified]"
              (( errors_found++ ))
              ;;
            1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16)
              # Do nothing
              :
              ;;
            *)
              cecho r "  ERROR: Parameter --useNodes needs to be one of [1-16]"
              (( errors_found++ ))
              ;;
          esac
          #set -x
          # Check service names length (30 characters?=
          if [ ${#PDB_PRIMARY_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbPrimaryServicename $PDB_PRIMARY_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi              
          # Check service names length (30 characters?=
          if [ ${#PDB_STANDBY_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbStandbyServicename $PDB_STANDBY_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi
          # Check service names length (30 characters?=
          if [ ${#PDB_ADMIN_SERVICE_NAME} -gt 30 ]
          then
          	cecho r "  ERROR: --pdbAdminServicename $PDB_ADMIN_SERVICE_NAME is to long, Max size is 30"
            (( errors_found++ ))
          fi             
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
          # OK evrything is supplied. Now the more logical checks/calculations that also involves asking the cluster for stuff
          if [ "$PDB_DATE_PART" = "" ]
          then
            # No date Part given, calculate
            PDB_DATE_PART=$(date +"%y%m%d%H")
          fi
          # Generate PDB_NAME and service names if not supplied
          PDB_NAME="p_${PDB_FREE_NAME}_${PDB_APPLICATION_CODE}_${PDB_DATE_PART}_${PDB_ENVIRONMENT}"
          if [ "${PDB_PRIMARY_SERVICE_NAME}" != "" ]
          then
            PDB_SERVICE="${PDB_PRIMARY_SERVICE_NAME}"
          else
            PDB_SERVICE="${PDB_FREE_NAME}${PDB_ENVIRONMENT}"
          fi
          if [ "${PDB_STANDBY_SERVICE_NAME}" != "" ]
          then
            PDB_SERVICE_RO="${PDB_STANDBY_SERVICE_NAME}"
          else
            PDB_SERVICE_RO="${PDB_FREE_NAME}${PDB_ENVIRONMENT}_ro"          
          fi    
          if [ "${PDB_ADMIN_SERVICE_NAME}" != "" ]
          then
            PDB_ADMIN_SERVICE="${PDB_ADMIN_SERVICE_NAME}"
          else
            PDB_ADMIN_SERVICE="s_${PDB_FREE_NAME}_${PDB_APPLICATION_CODE}_${PDB_DATE_PART}_${PDB_ENVIRONMENT}"
          fi
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          #set -x
          # Get number of nodes in cluster
          NUMBER_OFF_RAC_NODES=$($GRID_ORACLE_HOME/bin/olsnodes | wc -l)
          # Maybe check if its numeric and sucseeded
          # Now create list with instances to run on and to be availabale on
          # First we need to find all instances where the database runs
          # Find ORACLE_HOME of database selected for pluggabble
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          #set -x          
          # First find a node where it's configured
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
          # MAybe dubble check that stuff is actually found TBD
          # DB Should be primary
          # Check that this is a primary database
          last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_PRIMARY_SQL" "-S" )
          local last_error_code=$?
          if [ $last_error_code -ne 0 ]
          then
            # failed
            cecho r "  ERROR: Call to get primary database name on primary failed with code=$last_error_code and error text=$last_result"
            exit 1 
          else
            # success
            local PRIMARY_DB_NAME_ON_PRIMARY=$(echo ${last_result})
            if [ "$PRIMARY_DB_NAME_ON_PRIMARY" = "" ]
            then
              cecho r "  ERROR: $DATABASE_UNIQUE_NAME is not running as a primary database - can't create PDB's on anything else then a Primary database"
              exit 2
            else
              cecho g "     OK: $DATABASE_UNIQUE_NAME is running as a primary database"      
            fi     
          fi
          # Check that database is a container database
          # Now run SQL
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi  
          #set -x
          # Test if PDB exists
          FOUND_PDB_NAME_SQL="set heading off
          set feedback off
          select lower(name) from v\\\$pdbs where lower(NAME) = lower('${PDB_NAME}');
          "
          FOUND_PDB_NAME=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$FOUND_PDB_NAME_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          FOUND_PDB_NAME=$(echo ${FOUND_PDB_NAME})
          if [ "$FOUND_PDB_NAME" != "" ]
          then
            cecho r "  ERROR: The PDB $PDB_NAME does already exist in this database"
            exit 1
          fi
          # Test that we have no PBB's in preprod and prod unless --forceMultiplePdbs has beeb used to circumvent
          if [ "$INPUT_FORCE_MULTIPLE_PDBS" != "YES" ]
          then
            case $CDB_ENVIRONMENT in
              p|d)
                NUMBER_OF_PDBS_IN_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$NUMBER_OF_PDBS_IN_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
                # Filter out new lines using echo
                NUMBER_OF_PDBS_IN_CDB=$(echo ${NUMBER_OF_PDBS_IN_CDB})
                if [ $NUMBER_OF_PDBS_IN_CDB -gt 0 ]
                then
                  cecho r "  ERROR: Currently in Preprod and Prod we only allow one PDB for each CDB"
                  exit 1
                fi
                ;;
            esac
          fi
          #set -x
          # Check that services are not running here already
          ALL_SERVICES=$($GRID_ORACLE_HOME/bin/crsctl status res -w "TYPE == ora.service.type"| grep "NAME=")
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_SERVICE}\.svc" && { cecho r "  ERROR: Service ${PDB_SERVICE} is already configured in this cluster"; exit 1; }
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_SERVICE_RO}\.svc" && { cecho r "  ERROR: Service ${PDB_SERVICE_RO} is already configured in this cluster"; exit 1; }
          echo "${ALL_SERVICES}" | grep -q "\.${PDB_ADMIN_SERVICE}\.svc" && { cecho r "  ERROR: Service ${PDB_ADMIN_SERVICE} is already configured in this cluster"; exit 1; }
          #exit 99
          # Find all database instances that are "offline"
          DATABASE_INSTANCES_OFFLINE=($(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME  | sed -n "s/^Instance[[:blank:]]*\(.*\)[[:blank:]]*is not running on node.*/\1/p"))
          DATABASE_INSTANCES_OFFLINE_COUNT=${#DATABASE_INSTANCES_OFFLINE[@]}
          # Find instances that are "online"
          DATABASE_INSTANCES_ONLINE=($(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME  | sed -n "s/^Instance[[:blank:]]*\(.*\)[[:blank:]]*is running on node.*/\1/p"))
          #DATABASE_INSTANCES_ONLINE=$(echo $DATABASE_INSTANCES_ONLINE)          
          # Now do some logical check. If number of instances taht the user want the service to run on is larger than number of online services hen bang out
          #DATABASE_INSTANCES_ONLINE_COUNT=$(how_many "$DATABASE_INSTANCES_ONLINE")
          DATABASE_INSTANCES_ONLINE_COUNT=${#DATABASE_INSTANCES_ONLINE[@]}
          if [ $DATABASE_INSTANCES_ONLINE_COUNT -eq 0 ]
          then
            cecho r "  ERROR: There is no active database instances running for database $DATABASE_UNIQUE_NAME"
            exit 1
          fi
          if [ $USE_NODES -gt $DATABASE_INSTANCES_ONLINE_COUNT ]
          then
            cecho r "  ERROR: Parameter --useNodes needs to be between 1 and $(how_many "$DATABASE_INSTANCES_ONLINE_COUNT") (Number of active instances)"
            exit 1
          fi
          # Generate nmumber for first instance that service will run on - use the PDB name to get consisten numbers accros similar clusters (e.g same numer of nodes)
          PDB_NAME_CKSUM=$(cksum <<< "$PDB_NAME")
          PDB_NAME_CKSUM_INTEGER=$((0x${PDB_NAME_CKSUM%% *}))
          PDB_FIRST_INSTANCE=$((PDB_NAME_CKSUM_INTEGER%DATABASE_INSTANCES_ONLINE_COUNT))
          PDB_LAST_INSTANCE=$((PDB_FIRST_INSTANCE+USE_NODES))
          # Now loop over instances atrting with the beginning one
          #set -x
          for (( instance_counter=PDB_FIRST_INSTANCE; instance_counter < PDB_LAST_INSTANCE; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            modulus_value=$((instance_counter%DATABASE_INSTANCES_ONLINE_COUNT))
            #echo "modulus_value=$modulus_value"
            if [ "$PDB_PREFERRED_INSTANCES" = "" ]
            then
              PDB_PREFERRED_INSTANCES="${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            else
              PDB_PREFERRED_INSTANCES="$PDB_PREFERRED_INSTANCES,${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            fi            
          done
          #echo "PDB_PREFERRED_INSTANCES=$PDB_PREFERRED_INSTANCES"
          # Add avaiable instances as all others
          #echo "PDB_LAST_INSTANCE=$PDB_LAST_INSTANCE"
          #echo "DATABASE_INSTANCES_ONLINE_COUNT=$DATABASE_INSTANCES_ONLINE_COUNT"
          #echo "PDB_FIRST_INSTANCE=$PDB_FIRST_INSTANCE"
          #echo $((PDB_LAST_INSTANCE + DATABASE_INSTANCES_ONLINE_COUNT-USE_NODES ))
          #set -x
          #instance_counter=$((PDB_LAST_INSTANCE))
          for (( instance_counter=PDB_LAST_INSTANCE; instance_counter < PDB_LAST_INSTANCE + DATABASE_INSTANCES_ONLINE_COUNT-USE_NODES ; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            modulus_value=$((instance_counter%DATABASE_INSTANCES_ONLINE_COUNT))
            #echo "modulus_value=$modulus_value"
            if [ "$PDB_AVAILABLE_INSTANCES" = "" ]
            then
              PDB_AVAILABLE_INSTANCES="${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            else
              PDB_AVAILABLE_INSTANCES="$PDB_AVAILABLE_INSTANCES,${DATABASE_INSTANCES_ONLINE[modulus_value]}"
            fi
          done
          #echo "PDB_AVAILABLE_INSTANCES=$PDB_AVAILABLE_INSTANCES"
          # Add all offline to available
          for (( instance_counter=0; instance_counter < DATABASE_INSTANCES_OFFLINE_COUNT ; instance_counter++ ))
          do
            #echo "instance_counter=$instance_counter"
            if [ "$PDB_AVAILABLE_INSTANCES" = "" ]
            then
              PDB_AVAILABLE_INSTANCES="${DATABASE_INSTANCES_OFFLINE[instance_counter]}"
            else
              PDB_AVAILABLE_INSTANCES="$PDB_AVAILABLE_INSTANCES,${DATABASE_INSTANCES_OFFLINE[instance_counter]}"
            fi
          done          
          #echo "PDB_AVAILABLE_INSTANCES=$PDB_AVAILABLE_INSTANCES"         
          # Read PDB_ADMIN_PASSWORD
          #read_pdb_admin_password
        ;;
      esac;;
    database)
      check_for_permission oracle
      case $ACTION in
        setresources)
          TEMP=`getopt -o "" --name "$0" --long useProfile:,databaseUniqueName:,useSGAMemory:,useCpuCount:,useStorageCapacity:,useStorageIops:,useStorageBandwidth: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --useProfile) USE_PROFILE=$2 ;shift 2 ;; 
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --useSGAMemory) USE_SGA_MEMORY=$2; shift 2;;
              --useCpuCount) USE_CPU_COUNT=$2; shift 2;;                
              --useStorageCapacity) USE_STORAGE_CAPACITY=$2; shift 2;;                
              --useStorageIops) USE_STORAGE_IOPS=$2; shift 2;;                
              --useStorageBandwidth) USE_STORAGE_BANDWIDTH=$2; shift 2;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          errors_found=0
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --databaseUniqueName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "$PDB_NAME" == "" ]
          then
            cecho r "  ERROR: Parameter --pdbName needs to be specified"
            (( errors_found++ ))
          fi
          if [ "${USE_SGA_MEMORY}" != "" ]
          then
            # Verify values
            USE_SGA_MEMORY_PROFILE=$(check_sga_memory_profile "${USE_SGA_MEMORY}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_SGA_MEMORY_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_CPU_COUNT}" != "" ]
          then
            # Verify values
            USE_CPU_COUNT_PROFILE=$(check_cpu_count_profile "${USE_CPU_COUNT}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_CPU_COUNT_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_STORAGE_CAPACITY}" != "" ]
          then
            # Verify values
            USE_STORAGE_CAPACITY_PROFILE=$(check_storage_capacity_profile "${USE_STORAGE_CAPACITY}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_STORAGE_CAPACITY_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_STORAGE_IOPS}" != "" ]
          then
            # Verify values
            USE_STORAGE_IOPS_PROFILE=$(check_storage_iops_profile "${USE_STORAGE_IOPS}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_STORAGE_IOPS_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ "${USE_STORAGE_BANDWIDTH}" != "" ]
          then
            # Verify values
            USE_STORAGE_BANDWIDTH_PROFILE=$(check_storage_bandwidth_profile "${USE_STORAGE_BANDWIDTH}")
            if [ $? -ne 0 ]
            then 
              # Worng values, right values in return value
              cecho r "$USE_STORAGE_BANDWIDTH_PROFILE"
              (( errors_found++ ))
            fi
          fi
          if [ $errors_found -gt 0 ]
          then
          	exit 2
          fi
            
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          # Check that database exists and find Oracle home
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Cam't find database $DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # First find a first node where it exists
          node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
          # Then find instance on that node
          sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p") 
          IS_DB_CDB=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$IS_DB_CDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
          # Filter out new lines using echo
          IS_DB_CDB=$(echo ${IS_DB_CDB})
          if [ "$IS_DB_CDB" != "YES" ]
          then
            cecho r "  ERROR: The database $DATABASE_UNIQUE_NAME is not a cdb"
            exit 1
          fi
          ;;
        switchover)
          TEMP=`getopt -o "" --name "$0" --long autoFix:,databaseUniqueName:,sysPassword:,ignoreTests,dryRun,sysPasswordFile:,maxTransportLag:,maxApplyLag: -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --databaseUniqueName) INPUT_DATABASE_UNIQUE_NAME="$2";shift 2;;
              --sysPasswordFile) INPUT_SYS_PASSWORD_FILE="$2";shift 2;;
              --sysPassword) INPUT_SYS_PASSWORD="$2";shift 2;;
              --autoFix) INPUT_AUTO_FIX="$2";shift 2;;
              --maxTransportLag) INPUT_MAX_TRANSPORT_LAG="$2";shift 2;;
              --maxApplyLag) INPUT_MAX_APPLY_LAG="$2";shift 2;;
              --ignoreTests) INPUT_IGNORE_TESTS="YES";shift 1;;
              --dryRun) INPUT_DRY_RUN="YES";shift 1;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$INPUT_MAX_TRANSPORT_LAG" != "" ]
          then
            if ! [ $INPUT_MAX_TRANSPORT_LAG -eq $INPUT_MAX_TRANSPORT_LAG 2>/dev/null ]
            then 
              cecho r "  ERROR: value given to --maxTransportLag is not an integer"
              exit 1
            fi
          fi
          if [ "$INPUT_MAX_APPLY_LAG" != "" ]
          then
            if ! [ $INPUT_MAX_APPLY_LAG -eq $INPUT_MAX_APPLY_LAG 2>/dev/null ]
            then 
              cecho r "  ERROR: value given to --maxApplyLag is not an integer"
              exit 1
            fi
          fi
          if [ "${INPUT_AUTO_FIX}" != "" ]
          then
            # If ALL then set them implicit
            case $ENTRIES in 
              [Aa][Ll][Ll])
                ENTRIES="dataguard,spfile,tempfiles,services"
                ;;
            esac
            for ENTRY in ${INPUT_AUTO_FIX//,/ }
            do
              #echo "ENTRY:$ENTRY"
              case $ENTRY in
                [Dd][Aa][Tt][Aa][Gg][Uu][Aa][Rr][Dd])
                  INPUT_DATAGUARD_SPECIFIED="Y"
                  ;;
                [Ss][Pp][Ff][Ii][Ll][Ee])
                  INPUT_SPFILE_SPECIFIED="Y"
                  ;;
                [Tt][Ee][Mm][Pp][Ff][Ii][Ll][Ee][Ss])
                  INPUT_TEMPFILES_SPECIFIED="Y"
                  ;;
                [Ss][Ee][Rr][Vv][Ii][Cc][Ee][Ss])
                  INPUT_SERVICES_SPECIFIED="Y"
                  ;;
                *)    cecho r "  ERROR: --autoFix parameter $INPUT_AUTO_FIX not known. Should be one or more of dataguard,spfile,tempfiles,services or it should be all";exit 1;;
              esac  
            done
          fi
          if [ "$INPUT_DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi
          if [ "$INPUT_SYS_PASSWORD_FILE" != "" ]
          then
            if [ ! -f $INPUT_SYS_PASSWORD_FILE ]
            then
              # Ouch file needs to be there
              cecho r "  ERROR: File given to parameter --sysPasswordfile does not exist"
              exit 1
            else
              #Try to fetch password from file
              read -r INPUT_SYS_PASSWORD < $INPUT_SYS_PASSWORD_FILE
            fi
          fi
          if [ "$INPUT_SYS_PASSWORD" == "" ]
          then
            echo "   INFO: SYS password needs to be specified"
            read_sys_password "single"
            INPUT_SYS_PASSWORD=$SYS_PASSWORD
          fi
          # Ensure GRID_ORACLE__HOME is set
          set_grid_home
          # Check that the database exists
          ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${INPUT_DATABASE_UNIQUE_NAME}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
          if [ "$ORACLE_HOME" = "" ]
          then
            cecho r "  ERROR: Can't find database $INPUT_DATABASE_UNIQUE_NAME on this cluster"
            exit 1
          fi
          # We need to exit if not standby TBD
          # First find a node where it's configured
          local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
          if [ "$node_selected" = "" ]
          then
            cecho r "  ERROR: Can't get node where there is a instanse of ${INPUT_DATABASE_UNIQUE_NAME} running"
            exit 1
          fi
          # Then find instance on that node
          local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${INPUT_DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
          if [ "$node_selected" = "" ]
          then
            cecho r "  ERROR: Can't get a running instanse of ${INPUT_DATABASE_UNIQUE_NAME}"
            exit 1
          fi
          # DB Should be primary
          # Check that this is a standby database
          last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_STANDBY_SQL" "-S" )
          local last_error_code=$?
          if [ $last_error_code -ne 0 ]
          then
            # failed
            cecho r "  ERROR: Call to get primary database name on standby failed with code=$last_error_code and error text=$last_result"
            exit 1 
          else
            # success
            local PRIMARY_DB_NAME_ON_STANDBY=$(echo ${last_result})
            if [ "$PRIMARY_DB_NAME_ON_STANDBY" = "" ]
            then
              cecho r "  ERROR: $INPUT_DATABASE_UNIQUE_NAME is not running as a standby database - only works on standby databases"
              exit 2
            else
              cecho g "     OK: $INPUT_DATABASE_UNIQUE_NAME is running as a standby database"      
            fi     
          fi
          ;;                
        delete)
          TEMP=`getopt -o "" --name "$0" --long includingBackup,shutdownDatabase,databaseUniqueName:  -- "$@"`
          if [ $? -ne 0 ]
          then
            cecho r "  ERROR: Parameter parsing error"
            exit 1 
          fi
          eval set -- "$TEMP"
          while true ; do
            case "$1" in
              --shutdownDatabase) SHUTDOWN_DATABASE="YES";shift;;
              --databaseUniqueName) DATABASE_UNIQUE_NAME=`convert_to_lower $2`;shift 2 ;;
              --includingBackup) INCLUDING_BACKUP="YES";shift ;;
              --) shift ; break ;;
               *) cecho r "  ERROR: Internal error!" ; exit 1 ;;
            esac
          done
          if [ "$DATABASE_UNIQUE_NAME" == "" ]
          then
            cecho r "  ERROR: --databaseUniqueName <database unique name> needs to be specified"
            exit 1
          fi          
          ;;
        create)
          get_environment_names
          while [ $# -gt 0 ]
          do
            case $1 in
              --help|-h|-help) write_usage; exit 0;;
              --registerWithEm|-registerWithEm) SKIP_EM_CONFIGURATION="N";;
              --ignorePreReqs|-ignorePreReqs) IGNORE_PRE_REQS="-ignorePreReqs";;
              --oracleHome|-oracleHome) shift; ORACLE_HOME=$1;;
              --installOnNodes|-installOnNodes) shift; INSTALL_ON_NODES=$1;;
              --runOnNodes|-runOnNodes) shift; RUN_ON_NODES=$1;;
              --databaseType|-databaseType) shift; DATABASE_TYPE=`convert_to_lower $1`;;
              --useSGAMemory) shift; USE_SGA_MEMORY=$1;;
              --useCpuCount) shift; USE_CPU_COUNT=$1;;                
              --useStorageCapacity) shift; USE_STORAGE_CAPACITY=$1;;                
              --useStorageIops) shift; USE_STORAGE_IOPS=$1;;                
              --useStorageBandwidth) shift; USE_STORAGE_BANDWIDTH=$1;;   
              --useProfile) USE_PROFILE=$1 ;; 
        #      --runSingleInstance|-runSingleInstance) shift; SINGLE_INSTANCE="Y";;
              --configureDataGuard|-configureDataGuard) shift; USE_DATA_GUARD="Y";;
        #      --systemPassword|-systemPassword) shift; SYSTEM_PASSWORD=$1;;
        #      --sysPassword|-sysPassword) shift; SYS_PASSWORD=$1;;
        #      --asmSysPassword|-asmSysPassword) shift; ASM_SYS_PASSWORD=$1;;
        #      --dbsnmpPassword|-dbsnmpPassword) shift; DBSNMP_PASSWORD=$1;;
              --nlsLengthSemantics|-nlsLengthSemantics) shift; NLS_LENGTH_SEMANTICS=`convert_to_lower $1`;;
              --databaseName|-databaseName) shift; DATABASE_NAME=`convert_to_lower $1`;;
              --databaseUniqueName|-databaseUniqueName) shift; DATABASE_UNIQUE_NAME=`convert_to_lower $1`;;
              --characterSet|-characterSet) shift; CHARACTERSET=$1;;
              --nationalCharacterSet|-nationalCharacterSet) shift; NATIONAL_CHARACTERSET=$1;;
              --asmDataDiskGroup|-asmDataDiskGroup) shift; ASM_DATA_DISK_GROUP=`convert_to_upper $1`;;
              --asmRecoDiskGroup|-asmRecoDiskGroup) shift; ASM_RECO_DISK_GROUP=`convert_to_upper $1`;;
              --datacenterSite|-datacenterSite) shift; DATACENTER_SITE=$1;;
              --template|-template) shift; TEMPLATE=$1;;
              --datacenterUniqueNumber|-datacenterUniqueNumber) shift; DATACENTER_UNIQUE_NUMBER=$1;;
              --prepareAsStandby|-prepareAsStandby) PREPARE_AS_STANDBY="YES";;
              --primaryScanListener|-primaryScanListener) shift; PRIMARY_SCAN_LISTENER=$1;;
              --primaryDatabaseUniqueName) shift; PRIMARY_DATABASE_UNIQUE_NAME=$1;;
              --prepareAsPrimary|-prepareAsPrimary) PREPARE_AS_PRIMARY="YES";;
              --standbyScanListener|-standbyScanListener) shift; STANDBY_SCAN_LISTENER=$1;;
              --standbyDatabaseUniqueName|-standbyDatabaseUniqueName) shift; STANDBY_DATABASE_UNIQUE_NAME=$1;;
              --standbyVip|-standbyVip) shift; STANDBY_VIP=$1;;
              --standbyDuplicateNode|-standbyDuplicateNode) shift; STANDBY_DUPLICATE_NODE=$1;;
              --standbyAsmDataDiskGroup|-standbyAsmDataDiskGroup) shift; STANDBY_ASM_DATA_DISK_GROUP=`convert_to_upper $1`;;
              --standbyAsmRecoDiskGroup|-standbyAsmRecoDiskGroup) shift; STANDBY_ASM_RECO_DISK_GROUP=`convert_to_upper $1`;;
              --createAsContainer) CREATE_AS_CONTAINER="YES";;
              --skipTns) INPUT_SKIP_TNS="YES"; ;;  

              *)            cecho r "  ERROR: Parameter $1 given to script not recognized";exit 1;;
            esac;
            shift
          done
          create_database_check_arguments
          ;;
      esac
      ;;
  esac  
}
#
# get_environment_names
#
# Purpose: Get some environment initially
#
get_environment_names()
{
  # The hostname without domain
  SHORT_HOST_NAME=${HOSTNAME%%.*}
  # Domainame
  DOMAIN_NAME=${HOSTNAME#*.}
  # Build a couple of variable holding all the nodes or the
  # the ones that have been specified as parameter
  # Was CLUSTER_NODES explicitely not asked for?
  if [ "$CLUSTER_NODES" = "" ]
  then
    # Find the GRID ORACLE_HOME (maybe check it's not empty
    GRID_ORACLE_HOME=$(find_grid_home)
    # Get the cluster name
    GRID_CLUSTER_NAME=`$GRID_ORACLE_HOME/bin/cemutlo -n`
    # Get ASM Instance on this box
    GRID_ASM_INSTANCE=`ps -ef | grep pmon_+ASM | grep asm_ | sed -n "s/.*\(+ASM[0123456789][0123456789]*\)/\1/p"`
    # Get the information for some asm instance that we can use for sqlplus
    # THe asm node
    ACTIVE_ASM_NODE=$(${GRID_ORACLE_HOME}/bin/srvctl status ASM | sed -n "s/ASM[[:space:]]\+is[[:space:]]\+running[[:space:]]\+on[[:space:]]\+\([^,]*\).*/\1/p")
    #The ASM SID
    ACTIVE_ASM_SID=$(ssh -o 'StrictHostKeyChecking no' ${ACTIVE_ASM_NODE} ps -ef | grep pmon_+ASM | grep asm_ | sed -n "s/.*\(+ASM[0123456789][0123456789]*\)/\1/p")
    # Get a list of all nodes in cluster
    RAC_NODES=`$GRID_ORACLE_HOME/bin/olsnodes`
    RAC_NODES=`echo $RAC_NODES`
    for RAC_NODE in $RAC_NODES
    do
      if [ "$CLUSTER_NODES" = "" ]
      then
        CLUSTER_NODES="$RAC_NODE"
      else
        CLUSTER_NODES="$CLUSTER_NODES,$RAC_NODE"
      fi
    done
    INSTALL_ON_NODES=$CLUSTER_NODES
  else
    for RAC_NODE in ${CLUSTER_NODES//,/ }
    do
      if [ "$RAC_NODES" = "" ]
      then
        RAC_NODES="$RAC_NODE"
      else
        RAC_NODES="$RAC_NODES $RAC_NODE"
      fi
    done
  fi
  # Find the ASM disk groups on this cluster
  while read LINE; do
  	# If empty lines skip them
  	if [ "$LINE" = "" ]; then continue; fi 
  	# Parse the line
  	case $LINE in
  	  DATA*) ASM_DATA_DISK_GROUP="$LINE";;
  	  RECO*) ASM_RECO_DISK_GROUP="$LINE";;
  	  *_DATA) ASM_DATA_DISK_GROUP="$LINE";;
  	  *_RECO) ASM_RECO_DISK_GROUP="$LINE";;  
    esac
  done < <(ssh -o 'StrictHostKeyChecking no' ${ACTIVE_ASM_NODE} "export ORACLE_SID=${ACTIVE_ASM_SID}; export ORACLE_HOME=${GRID_ORACLE_HOME}; ${GRID_ORACLE_HOME}/bin/sqlplus -S / as sysdba <<EOF
$ASM_DISK_GROUPS_SQL
EOF
")
  case $GRID_CLUSTER_NAME in
  	dm00*) DATACENTER_SITE='h' ;;
  	dm11*) DATACENTER_SITE='h'; AUDIT_TRAIL="DB,EXTENDED" ;;
  	dm12*) DATACENTER_SITE='c'; AUDIT_TRAIL="DB,EXTENDED" ;;
  	dm13*) DATACENTER_SITE='h'; AUDIT_TRAIL="DB,EXTENDED" ;;
  	dm14*) DATACENTER_SITE='c'; AUDIT_TRAIL="DB,EXTENDED" ;;
  	dm15*) DATACENTER_SITE='h' ;;
  	dm16*) DATACENTER_SITE='c' ;;
  	dm17*) DATACENTER_SITE='h' ;;
  	dm18*) DATACENTER_SITE='c' ;;
  	dm19*) DATACENTER_SITE='h' ;;
  	dm20*) DATACENTER_SITE='c' ;;
  	dm21*) DATACENTER_SITE='h' ;;
  	dm22*) DATACENTER_SITE='c' ;;
  	db-e*) # New Exadata naming, parse data center site from db-s001oed-clu
  	       [[ $GRID_CLUSTER_NAME =~ db-e(.{3})(.{2})(.{1})-clu ]]
  	       if [ $? -eq 0 ]
  	       then
  	         case ${BASH_REMATCH[2]} in # Site
  	           oe) DATACENTER_SITE='o';;
  	           cb) DATACENTER_SITE='c';;
  	           hh) DATACENTER_SITE='h';;
  	           s1) DATACENTER_SITE='x';;
  	           s2) DATACENTER_SITE='y';;
  	           *) 
                   cecho r "  ERROR: Grid Site name in $GRID_CLUSTER_NAME is not one of <oe|hh|cb>"
                   exit 1;;
  	         esac  	   
  	       else
  	         cecho r "  ERROR: Grid Cluster Name $GRID_CLUSTER_NAME is not one of on the form db-s<3 digts><oe|hh|cb><p|d|t|s>-clu"
  	         exit 1
  	       fi;;
  	db-s*) # New SOP platform, parse data center site from db-s001oed-clu
  	       [[ $GRID_CLUSTER_NAME =~ db-s(.{3})(.{2})(.{1})-clu ]]
  	       if [ $? -eq 0 ]
  	       then
  	         case ${BASH_REMATCH[2]} in # Site
  	           oe) DATACENTER_SITE='o';;
  	           cb) DATACENTER_SITE='c';;
  	           hh) DATACENTER_SITE='h';;
  	           s1) DATACENTER_SITE='x';;
  	           s2) DATACENTER_SITE='y';;
  	           *) 
                   cecho r "  ERROR: Grid Site name in $GRID_CLUSTER_NAME is not one of <oe|hh|cb>"
                   exit 1;;
  	         esac  	   
  	         # Work arrround till i can find the diskgroups
  	         ASM_DATA_DISK_GROUP="s${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[3]}_data"
	           ASM_RECO_DISK_GROUP="s${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[3]}_reco"
  	       else
  	         cecho r "  ERROR: Grid Cluster Name $GRID_CLUSTER_NAME is not one of on the form db-s<3 digts><oe|hh|cb><p|d|t|s>-clu"
  	         exit 1
  	       fi;;
  	rac4) DATACENTER_SITE='s'
          AGENT_REGISTRATOR_USERNAME="$TEST_AGENT_REGISTRATOR_USERNAME"
          AGENT_REGISTRATOR_OMS_PORT="$TEST_AGENT_REGISTRATOR_OMS_PORT"
          AGENT_REGISTRATOR_OMS_HOST="$TEST_AGENT_REGISTRATOR_OMS_HOST"
  	  ;;
  	    *) cecho r "  ERROR: Grid Cluster Name $GRID_CLUSTER_NAME is not one of dm00, dm11*,dm12*,dm13*,dm14*,dm15*,dm16,dm17,dm18,dm19,dm20,dm21,dm22,db-e* or db-s*"; exit 1;;
  esac
  # Do we run in a shared tns_admin environment
  if [ -f ${CLUSTERED_TNS_ADMIN}/tnsnames.ora ]
  then
  	export TNS_ADMIN=${CLUSTERED_TNS_ADMIN}
  	USING_SHARED_TNS_ADMIN="Y"
  fi
  # Find agent oracle_home
  find_agent_oracle_home
  #echo $AGENT_ORACLE_HOME
}

#
# create_database_check_arguments
#
# Purpose: checks if all arguments given on command line is valid
#
create_database_check_arguments()
{
  errors_found=0
  if [ "$AGENT_ORACLE_HOME" = "" -a "$SKIP_EM_CONFIGURATION" = "N" ]
    then
      cecho r "  ERROR: No agent home found. Can't register with Enterprise Manager. Specify --skipEmConfiguration to skip registration"
      (( errors_found++ ))
    fi  
  if [ -z "${ORACLE_HOME}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --oracleHome has to be given or ORACLE_HOME env variable should be set"
    (( errors_found++ ))
  else
    if [ ! -f $ORACLE_HOME/bin/sqlplus ]
    then
      cecho r "  ERROR: $ORACLE_HOME/bin/sqlplus not found. Is Oracle Home specified correct?"
      (( errors_found++ ))
    fi
  fi
  if [ -z "${INSTALL_ON_NODES}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --installOnNodes has to be given or INSTALL_ON_NODES env variable should be set"
    (( errors_found++ ))
  fi
  if [ -z "${RUN_ON_NODES}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --runOnNodes has to be given or RUN_ON_NODES env variable should be set"
    (( errors_found++ ))
  fi
  # Set some initial old values to be able to create the database
  # We call both as the seconf primaryly makes a few values biger
  # After inital creation we will set the parameter values again
  set_tiny_parameters
  # Increase processes as this seemed to be to small on Exadata when creating database
  PROCESSES=700
  set_tiny_container_parameters 
  # If on develoment environment, lower som values
  case ${DATABASE_UNIQUE_NAME:${#DATABASE_UNIQUE_NAME} -1} in
    x|y) set_pico_parameters
         SGA_TARGET=4000000000
         SHARED_POOL_SIZE=400000000
         JAVA_POOL_SIZE=150000000
         LARGE_POOL_SIZE=150000000
         DB_CACHE_SIZE=1200000000
         REDO_LOG_FILE_SIZE_MB=64
         set_pico_container_parameters
         ;;
  esac
 
	if [ "$USE_PROFILE" != "" ]
	then
    # --useProfile is defined
    # Check that profile is a supported one and set parameters accordingly
    case $USE_PROFILE in
      pico)
        USE_CPU_COUNT=1
        USE_SGA_MEMORY=4gb
        USE_STORAGE_CAPACITY=2tb
        USE_STORAGE_IOPS=10000iops
        USE_STORAGE_BANDWIDTH=100000mbps
        ;;
      micro)
        USE_CPU_COUNT=2
        USE_SGA_MEMORY=8gb
        USE_STORAGE_CAPACITY=4tb
        USE_STORAGE_IOPS=20000iops
        USE_STORAGE_BANDWIDTH=200000mbps
        ;;
      tiny) 
        USE_CPU_COUNT=4
        USE_SGA_MEMORY=16gb
        USE_STORAGE_CAPACITY=10tb
        USE_STORAGE_IOPS=100000iops
        USE_STORAGE_BANDWIDTH=1gbps
        ;;
      small) 
        USE_CPU_COUNT=8
        USE_SGA_MEMORY=32gb
        USE_STORAGE_CAPACITY=20tb
        USE_STORAGE_IOPS=100000iops
        USE_STORAGE_BANDWIDTH=2gbps
        ;;
      medium) 
        USE_CPU_COUNT=16
        USE_SGA_MEMORY=64gb
        USE_STORAGE_CAPACITY=40tb
        USE_STORAGE_IOPS=200000iops
        USE_STORAGE_BANDWIDTH=4gbps
        ;;
      large)
        USE_CPU_COUNT=32
        USE_SGA_MEMORY=128gb
        USE_STORAGE_CAPACITY=100tb
        USE_STORAGE_IOPS=4000000iops
        USE_STORAGE_BANDWIDTH=10gbps
        ;;
      *)
        cecho r "  ERROR: --useProfile $USE_PROFILE not supported should be one of: pico,micro,tiny,small,medium,large"
        (( errors_found++ ))
        ;;
    esac         
  fi  
  # databasetype is not defined, --use** needs to be defined
  if [ "$USE_SGA_MEMORY" = "" -a "${USE_CPU_COUNT}" = "" -a "${USE_STORAGE_CAPACITY}" != "" ]
  then
    cecho r "  ERROR: either --useProfile or ( --useSGAMemory, --useCpuCount, --useStorageCapacity, --useStorageIops and --useStorageBandwidth ) need to be specified"
    (( errors_found++ ))
  else
    if [ "${USE_SGA_MEMORY}" = "" -o "${USE_CPU_COUNT}" = "" -o "${USE_STORAGE_CAPACITY}" = "" -o "${USE_STORAGE_IOPS}" = "" -o "${USE_STORAGE_BANDWIDTH}" = "" ]
    then
      cecho r "  ERROR: All parameters ( --useSGAMemory, --useCpuCount, --useStorageCapacity, --useStorageIops and --useStorageBandwidth ) need to be specified"
      (( errors_found++ ))
    else
      # All --use* is specified, check tkeir values
      case ${USE_CPU_COUNT} in
        1|2|4|6|8|12|16|24|32|48|64)
          # Extract the number and build the profile name
          USE_CPU_COUNT_PROFILE="cpu_${USE_CPU_COUNT}"
          ;;
        *)
          cecho r "  ERROR: Parameter --useCpuCount needs to be one of [1|2|4|6|8|12|16|24|32|48|64]"
          (( errors_found++ ))
          ;;
      esac
      case ${USE_SGA_MEMORY} in
        1gb|2gb|4gb|6gb|8gb|12gb|16gb|24gb|32gb|48gb|64gb|96gb|128gb|192gb|256gb|384gb|512gb) 
          # Extract the number and build the profile name
          USE_SGA_MEMORY_PROFILE="memory_${USE_SGA_MEMORY//gb/_gb}"
          ;;
        *)
          cecho r "  ERROR: Parameter --useSGAMemory needs to be one of [1gb|2gb|4gb|6gb|8gb|12gb|16gb|24gb|32gb|48gb|64gb|96gb|128gb|192gb|256gb|384gb|512gb]"
          (( errors_found++ ))
          ;;
      esac
      case ${USE_STORAGE_CAPACITY} in
        100gb|200gb|400gb)
          # Extract the number and build the profile name
          USE_STORAGE_CAPACITY_PROFILE="storagecapacity_${USE_STORAGE_CAPACITY//gb/_gb}"
          ;;
        1tb|2tb|4tb|10tb|20tb|40tb|100tb|200tb|400tb)
          # Extract the number and build the profile name
          USE_STORAGE_CAPACITY_PROFILE="storagecapacity_${USE_STORAGE_CAPACITY//tb/_tb}"
          ;;
        *)
          cecho r "  ERROR: Parameter --useStorageCapacity needs to be one of [100gb|200gb|400gb|1tb|2tb|4tb|10tb|20tb|40tb|100tb|200tb|400tb]"
          (( errors_found++ ))
          ;;
      esac
      case ${USE_STORAGE_IOPS} in
        100iops|1000iops|10000iops|100000iops|1000000iops|200iops|2000iops|20000iops|200000iops|2000000iops|400iops|4000iops|40000iops|400000iops|4000000iops)
          # Extract the number and build the profile name
          USE_STORAGE_IOPS_PROFILE="storageiops_${USE_STORAGE_IOPS//iops/_iops}"
          ;;
        *)
          cecho r "  ERROR: Parameter --useStorageIops needs to be one of [100iops|1000iops|10000iops|100000iops|1000000iops|200iops|2000iops|20000iops|200000iops|2000000iops|400iops|4000iops|40000iops|400000iops|4000000iops]"
          (( errors_found++ ))
          ;;
      esac
      case ${USE_STORAGE_BANDWIDTH} in
        1mbps|10mbps|100mbps|2mbps|20mbps|200mbps|4mbps|40mbps|400mbps)
          # Extract the number and build the profile name
          USE_STORAGE_BANDWIDTH_PROFILE="storagebandwidth_${USE_STORAGE_BANDWIDTH//mbps/_mbps}"
          ;;
        1gbps|10gbps|2gbps|20gbps|4gbps|40gbps)
          # Extract the number and build the profile name
          USE_STORAGE_BANDWIDTH_PROFILE="storagebandwidth_${USE_STORAGE_BANDWIDTH//gbps/_gbps}"
          ;;
        *)
          cecho r "  ERROR: Parameter --useStorageBandwidth needs to be one of [1mbps|2mbps|4mbps|10mbps|20mbps|40mbps|100mbps|200mbps|200mbps|1gbps|2gbps|4gbps|10gbps|20gbps|40gbps]"
          (( errors_found++ ))
          ;;
      esac
      # Now deduce the DATABASE_TYPE from USE_STORAGE_BANDWIDTH and USE_STORAGE_IOPS the db_performance_profile
      MBPS=${USE_STORAGE_BANDWIDTH//mbps/}
      MBPS=${MBPS//gbps/000}
      IOPS=${USE_STORAGE_IOPS//iops/}
      if [ $IOPS -lt 10000 -a $MBPS -lt 40 ]
      then
        DATABASE_TYPE='micro'
      else
        if [ $IOPS -lt 20000 -a $MBPS -lt 100 ]
        then
          DATABASE_TYPE='tiny'
        else
          if [ $IOPS -lt 100000 -a $MBPS -lt 400 ]
          then
            DATABASE_TYPE='small'
          else
            if [ $IOPS -lt 400000 -a $MBPS -lt 2000 ]
            then
              DATABASE_TYPE='medium'
            else
              DATABASE_TYPE='large'
            fi
          fi
        fi
      fi
    fi
  fi
#  if [ -z "${SYSTEM_PASSWORD}" ]  # Is this variable defined?
#  then
#    cecho r "  ERROR: --systemPassword has to be given or SYSTEM_PASSWORD env variable should be set"
#    (( errors_found++ ))
#  fi
#  if [ -z "${SYS_PASSWORD}" ]  # Is this variable defined?
#  then
#    cecho r "  ERROR: --sysPassword has to be given or SYS_PASSWORD env variable should be set"
#    (( errors_found++ ))
#  fi
#  if [ -z "${ASM_SYS_PASSWORD}" ]  # Is this variable defined?
#  then
#    cecho r "  ERROR: --asmSysPassword has to be given or ASM_SYS_PASSWORD env variable should be set"
#    (( errors_found++ ))
#  fi
#  if [ -z "${DBSNMP_PASSWORD}" ]  # Is this variable defined?
#  then
#    cecho r "  ERROR: --dbsnmpPassword has to be given or DBSNMP_PASSWORD env variable should be set"
#    (( errors_found++ ))
#  fi
  if [ -z "${DATABASE_NAME}" ]  # Is this variable defined?
  then
    # Check if database unique name is set and check that values are OK
    if [ -z "${DATABASE_UNIQUE_NAME}" ]  # Is this variable defined?
    then
      cecho r "  ERROR: --databaseName or --databaseUniqueName has to be given or DATABASE_NAME/DATABASE_UNIQUE_NAME env variable should be set"
      (( errors_found++ ))      
      if [[ "${DATABASE_NAME:${#DATABASE_NAME} -1}" != [pdts] ]]
      then
        cecho r "  ERROR: third last character in --databaseUniqueName (${DATABASE_NAME:${#DATABASE_NAME} -1}) needs to end on a character in the following set [pdts]"
      fi
    else
      # Now check if it's ok
      #<dbname>p|d|t|s<data center uniqe number 1-9><datacenter site>
      if [ ${#DATABASE_UNIQUE_NAME} -gt 8 ]
      then
      	cecho r "  ERROR: --databaseUniqueName $DATABASE_NAME is to long, Max size is 8"
        (( errors_found++ ))
      fi
      if [ "${DATABASE_UNIQUE_NAME:${#DATABASE_UNIQUE_NAME} -1}" != "$DATACENTER_SITE" ]
      then
        cecho r "  ERROR: last character in --databaseUniqueName (${DATABASE_UNIQUE_NAME:${#DATABASE_UNIQUE_NAME} -1}) does not match --datacenterSite ($DATACENTER_SITE)"
        (( errors_found++ ))
      fi
      local database_unique_name_minus_site="${DATABASE_UNIQUE_NAME%?}"
      if [[ "${database_unique_name_minus_site:${#database_unique_name_minus_site} -1}" != [1-9] ]]
      then
        cecho r "  ERROR: second last character (Datacenter Unique Number) in --databaseUniqueName (${database_unique_name_minus_site:${#database_unique_name_minus_site} -1}) does not match [1-9}"
        (( errors_found++ ))
      else
        # Extract the site number
        DATACENTER_UNIQUE_NUMBER="${database_unique_name_minus_site:${#database_unique_name_minus_site} -1}"
      fi
      DATABASE_NAME="${database_unique_name_minus_site%?}"
    fi
  else
    if [ ${#DATABASE_NAME} -gt 6 ]
    then
    	cecho r "  ERROR: --databaseName $DATABASE_NAME is to long, Max size is 6"
      (( errors_found++ ))
    fi
    if [[ "${DATABASE_NAME:${#DATABASE_NAME} -1}" != [pdts] ]]
    then
      cecho r "  ERROR: --databaseName $DATABASE_NAME needs to end on a character in the following set [pdts]"
      (( errors_found++ ))
    fi
    if [[ "${DATACENTER_UNIQUE_NUMBER}" != [1-9] ]]
    then
      cecho r "  ERROR: --datacenterUniqueNumber does not match [1-9]"
      (( errors_found++ ))
    fi    
  fi
  if [[ $DATABASE_NAME =~ ^[a-z].*[pdts]$ ]]
  then
    :
  else
    cecho r "  ERROR: Database name has to start with character [a-z]"
    (( errors_found++ ))
  fi
  if [[ $DATABASE_NAME =~ ^.([a-z]|[0-9])*[pdts]$ ]]
  then
    :
  else
    cecho r "  ERROR: Database name except first chaacter has to be made of characters [a-z] or [0-9]"
    (( errors_found++ ))
  fi
  # If character set - has been checked
  case ${DATABASE_NAME:${#DATABASE_NAME} -1} in
    p) set_password "p"
    	 # Maybe check if RAC and DG makes sense
    	 ;;
    d) set_password "d"
    	 # Maybe check if RAC and DG makes sense
    	 ;;
    t) set_password "t"
    	 # Maybe check if RAC and DG makes sense
    	 ;;
    s) set_password "s"
    	 # Maybe check if RAC and DG makes sense
    	 ;;
  esac    
  if [ -z "${CHARACTERSET}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --characterSet has to be given or CHARACTERSET env variable should be set"
    (( errors_found++ ))
  fi
  if [ -z "${NATIONAL_CHARACTERSET}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --nationalCharacterSet has to be given or NATIONAL_CHARACTERSET env variable should be set"
    (( errors_found++ ))
  fi
  if [ -z "${NLS_LENGTH_SEMANTICS}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --nlsLengthSemantics has to be given or NLS_LENGTH_SEMANTICS env variable should be set"
    (( errors_found++ ))
  else
  	case ${NLS_LENGTH_SEMANTICS} in
  	  byte) : ;;
  	  char) : ;;
  	  *)  (( errors_found++ ))
  	  	  cecho r "  ERROR: --nlsLengthSemantics $NLS_LENGTH_SEMANTICS needs to either BYTE or CHAR"
  	esac
  fi
  if [ -z "${ASM_DATA_DISK_GROUP}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --asmDataDiskGroup has to be given or ASM_DATA_DISK_GROUP env variable should be set"
    (( errors_found++ ))
  fi
  if [ -z "${ASM_RECO_DISK_GROUP}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --asmRecoDiskGroup has to be given or ASM_RECO_DISK_GROUP env variable should be set"
    (( errors_found++ ))
  fi
  if [ -z "${DATACENTER_SITE}" ]  # Is this variable defined?
  then
    cecho r "  ERROR: --datacenterSite has to be given or DATACENTER_SITE env variable should be set"
    (( errors_found++ ))
  fi
  # Check standby/primary parameters
  if [ "$PREPARE_AS_STANDBY" == "YES" -a "$PREPARE_AS_PRIMARY" = "YES" ]
  then
    cecho r "  ERROR: --prepareAsStandby and  --prepareAsPrimary can not both be specified"
    (( errors_found++ ))
  fi
  # Check Standby parameters
  if [ "$PREPARE_AS_STANDBY" == "YES"  ]
  then
    # Need to check that parameters needed are given
    if [ "$PRIMARY_SCAN_LISTENER" !=  "" -o "$PRIMARY_DATABASE_UNIQUE_NAME" !=  "" -o "$STANDBY_DUPLICATE_NODE" !=  "" ]
    then
      if [ "$PRIMARY_SCAN_LISTENER" ==  "" ]
      then
        cecho r "  ERROR: --primaryScanListener needs to be specified when --prepareAsStandby is specified"
        (( errors_found++ ))
      fi
      if [ "$PRIMARY_DATABASE_UNIQUE_NAME" ==  "" ]
      then
        cecho r "  ERROR: --primaryDatabaseUniqueName needs to be specified when --prepareAsStandby is specified"
        (( errors_found++ ))
      fi
      if [ "$STANDBY_DUPLICATE_NODE" ==  "" ]
      then
        cecho r "  ERROR: --standbyDuplicateNode needs to be specified when --prepareAsStandby is specified"
        (( errors_found++ ))
      fi
    fi
    # Check that STANDBY_DUPLICATE_NODE is one of the run nodes in this cluster
    total_nodes_found=0
    for run_node in  ${RUN_ON_NODES//,/ }
    do
      if [ "$STANDBY_DUPLICATE_NODE" = "$run_node" ]
      then
    	  (( total_nodes_found++ ))
      fi
    done   
    if [ $total_nodes_found -ne 1 ]
    then
      cecho r "  ERROR: The node (${STANDBY_DUPLICATE_NODE}) given to --standbyDuplicateNode is not one of the nodes in $RUN_ON_NODES"
      exit 1
    fi
  else
    if [ "$STANDBY_DUPLICATE_NODE" != "" ]
    then
      cecho r "  ERROR: --standbyDuplicateNode can only be specified when --prepareAsStandby is specified"
      (( errors_found++ ))
    fi
    if [ "$PRIMARY_SCAN_LISTENER" != "" ]
    then
      cecho r "  ERROR: --primaryScanListener can only be specified when --prepareAsStandby is specified"
      (( errors_found++ ))
    fi
    if [ "$PRIMARY_DATABASE_UNIQUE_NAME" != "" ]
    then
      cecho r "  ERROR: --primaryDatabaseUniqueName can only be specified when --prepareAsStandby is specified"
      (( errors_found++ ))
    fi
  fi
  # Check standby parameters
  if [  "$PREPARE_AS_PRIMARY" = "YES" ]
  then
    # Check that needed parameters are there
    if [ "$STANDBY_SCAN_LISTENER" =  "" -a "$STANDBY_DATABASE_UNIQUE_NAME" =  "" -a "$STANDBY_VIP" =  "" ]
    then
      cecho r "  ERROR: --standbyScanListener, --standbyDatabaseUniqueName and --standbyVip needs to be specified when --prepareAsPrimary is specified "
      (( errors_found++ ))
    fi
    # If any of the 3 parameters are specified they all need to be there
    if [ "$STANDBY_SCAN_LISTENER" !=  "" -o "$STANDBY_DATABASE_UNIQUE_NAME" !=  "" -o "$STANDBY_VIP" !=  "" ]
    then
      if [ "$STANDBY_SCAN_LISTENER" ==  "" ]
      then
        cecho r "  ERROR: --standbyScanListener needs to be specified together with --standbyDatabaseUniqueName and --standbyVip"
        (( errors_found++ ))
      fi
      if [ "$STANDBY_DATABASE_UNIQUE_NAME" ==  "" ]
      then
        cecho r "  ERROR: --standbyDatabaseUniqueName needs to be specified together with --standbyScanListener and --standbyVip"
        (( errors_found++ ))
      fi
      if [ "$STANDBY_VIP" ==  "" ]
      then
        cecho r "  ERROR: --standbyVip needs to be specified together with --standbyDatabaseUniqueName and --standbyScanListener"
        (( errors_found++ ))
      fi
    fi
  else
    if [ "$STANDBY_SCAN_LISTENER" != "" ]
    then
      cecho r "  ERROR: --standbyScanListener can only be specified when --prepareAsPrimary is specified"
      (( errors_found++ ))
    fi
    if [ "$STANDBY_DATABASE_UNIQUE_NAME" != "" ]
    then
      cecho r "  ERROR: --standbyDatabaseUniqueName can only be specified when --prepareAsPrimary is specified"
      (( errors_found++ ))
    fi
    if [ "$STANDBY_VIP" != "" ]
    then
      cecho r "  ERROR: --standbyVip can only be specified when --prepareAsPrimary is specified"
      (( errors_found++ ))
    fi
    if [ "$STANDBY_ASM_DATA_DISK_GROUP" != "" ]
    then
      cecho r "  ERROR: --standbyAsmDataDiskGroup can only be specified when --prepareAsPrimary is specified"
      (( errors_found++ ))
    fi
    if [ "$STANDBY_ASM_RECO_DISK_GROUP" != "" ]
    then
      cecho r "  ERROR: --standbyAsmRecoDiskGroup can only be specified when --prepareAsPrimary is specified"
      (( errors_found++ ))
    fi    
  fi
  if [ $errors_found -gt 0 ]
  then
  	exit 2
  fi
  # Check that RUN_ON_NODES is one of the nodes in this cluster
  total_nodes_found=0
  for run_node in  ${RUN_ON_NODES//,/ }
  do
  	(( total_nodes_found++ ))
  	ALL_RUN_ON_NODES[$total_nodes_found]=$run_node
  	found="N"
    for install_node in ${INSTALL_ON_NODES//,/ }
    do
      if [ "$install_node" = "$run_node" ]
      then
        # It's OK
        found="Y"
      fi
    done
    if [ "$found" = "N" ]
    then
      cecho r "  ERROR: The node $run_node is not one of the nodes in $INSTALL_ON_NODES"
      exit 1
    fi
  done  
  if [ $total_nodes_found -gt $MAX_INSTANCES_TO_RUN_ON ]
  then
    cecho r "  ERROR: Want to run on $total_nodes_found nodes, but database type \"${DATABASE_TYPE}\" only allows to run on max $MAX_INSTANCES_TO_RUN_ON node(s)"
    exit 1
  fi
  

  # Generate some random number that points to the index of one of the run_node
  node_selected_for_service=$(( RANDOM % total_nodes_found + 1 ))
  # Pick the node
  RUN_NODE_FOR_APP_SERVICE=${ALL_RUN_ON_NODES[node_selected_for_service]}
}

#
# create_database_build_environment_names
#
# Purpose: Build some environment names based on parameters
#          given to script plus other variables needed
#
create_database_build_environment_names()
{
  DB_NAME=$DATABASE_NAME
  DATABASE_UNIQUE_NAME="${DATABASE_NAME}${DATACENTER_UNIQUE_NUMBER}${DATACENTER_SITE}"
  ORACLE_BASE=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/orabase)
  DATABASE_INSTANCE=$DATABASE_UNIQUE_NAME
  # Find version of oracle_home
  ORACLE_HOME_VERSION=`export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/sqlplus -version | sed -n "s/.*elease[[:space:]]\([^ \t].*\)[[:space:]].*/\1/p"`
  # Look up if we are running in HA og BCA environment
  local nordea_availability_level=$(get_configuration_parameter "nordea_availability_level")
  # Check value can be handled
  local rac_nonrac=""
  case $nordea_availability_level in
    ha)
      rac_nonrac="nonrac"
      ORACLE_INSTANCE_TYPE='SINGLE'
      ;;
    bca)
      rac_nonrac="exadata"
      ORACLE_INSTANCE_TYPE='RAC'
      ;;
    *)
      echo "   ERROR: Parameter nordea_availability_level in ${NORDEA_ENVIRONMENT_FILE} should be one of ha or bca"
      exit 1;;
  esac
  if [[ "$ORACLE_HOME_VERSION" =~ ^11\.2.* ]]; then
    ORACLE_MAJOR_VERSION=11.2
    if [ "$TEMPLATE" = "" ]
    then
      TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_112}"
    fi
  fi
  if [[ "$ORACLE_HOME_VERSION" =~ ^12\.1.* ]]; then
    ORACLE_MAJOR_VERSION=12.1
    if [ "$TEMPLATE" = "" ]
    then
      TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_121}"
    fi
  fi  
  if [[ "$ORACLE_HOME_VERSION" =~ ^12\.2.* ]]; then
    ORACLE_MAJOR_VERSION=12.2
    if [ "$TEMPLATE" = "" ]
    then
      if [ "$CREATE_AS_CONTAINER" = "YES" ]
      then
        TEMPLATE=$TEMPLATE_122_CONTAINER
        TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_122_CONTAINER}"
      else
        TEMPLATE=$TEMPLATE_122
        TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_122}"
      fi
    fi
  fi  
  if [[ "$ORACLE_HOME_VERSION" =~ ^18.* ]]; then
    ORACLE_MAJOR_VERSION=18
    if [ "$TEMPLATE" = "" ]
    then
      if [ "$CREATE_AS_CONTAINER" = "YES" ]
      then
        TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_18_CONTAINER}"
      else
        TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_18}"
      fi
    fi
  fi  
  if [[ "$ORACLE_HOME_VERSION" =~ ^19.* ]]; then
    ORACLE_MAJOR_VERSION=19
    if [ "$TEMPLATE" = "" ]
    then
      if [ "$CREATE_AS_CONTAINER" = "YES" ]
      then
        TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_19_CONTAINER}"
      else
        TEMPLATE="nordea_${rac_nonrac}_${TEMPLATE_19}"
      fi
    fi
  fi  
  if [ "$ORACLE_MAJOR_VERSION" == "" ]
  then
    echo " ERROR: Oracle Home version ${ORACLE_HOME_VERSION} not supported"
    exit 1    
  else
    echo "    OK: Oracle Home major version=$ORACLE_MAJOR_VERSION"
  fi
}

print_environment()
{
  echo "        Grid cluster name: $GRID_CLUSTER_NAME"
  echo "         Nodes in cluster: $CLUSTER_NODES"
  echo "Found ASM DATA disk group: $ASM_DATA_DISK_GROUP"
  echo "Found ASM RECO disk group: $ASM_RECO_DISK_GROUP"
}

write_usage()
{
  # Removed until script is cleaned up to allow this correctly
  #$script_name prepare primary
  #  --databaseUniqueName <unique name of database>  
  cat << EOF
$0 is used to create standard nordea databases on Exadata.
The script will create a database and create a number of services for accessing
the database. Also it can be used in helping setting up an initial 2 site
data guard setup.

Usage:
  $script_name prepatch standby
    --databaseUniqueName <unique name of database>
    --newOracleHome <Path to the Oracle Home where we want the database to run from>
    [--dryRun]
    [--verbose]
  $script_name patch primary
    --databaseUniqueName <unique name of database>
    --newOracleHome <Path to the Oracle Home where we want the database to run from>   
    [--dryRun]
    [--verbose]
    [--dontReloadListener]
  $script_name postpatch standby
    --databaseUniqueName <unique name of database>
    [--dryRun]
    [--verbose]
    [--dontReloadListener]
  $script_name status standby
    [--databaseUniqueNameRegex <Regex to specify unique names of databases>]
  $script_name create pdb
    [--pdbName |
       --pdbApplicationCode <value>
       [--pdbDatePart]
       [--pdbFriendlyName <value><s|t|d|p> |
          [--pdbFreeName <value>
           --pdbEnvironment <s|t|d|p>]]]
    --databaseUniqueName <unique name of database>  
    --useCpuCount <number>
    --useSGAMemory <value>
    --useStorageCapacity <value>
    --useStorageIops <value>
    --useStorageBandwidth <value>
    --useNodes <number>
    [--pdbPrimaryServicename <free service name>
       --pdbStandbyServicename <free service name>
       --pdbAdminServiceName <free service name>]
    [--pdbPlugFile <full path to pdb file containing unplugged pdb>]
    [--nlsLengthSemantics char|byte]
    [--forceMultiplePdbs]
    [--prepareForMigration]
    [--noStandbys]
#  $script_name setresources pdb
#    --pdbName <pdb name>
#    --databaseUniqueName <unique name of database>  
#    --useCpuCount <number>
#    --useSGAMemory <value>
#    --useStorageCapacity <value>
#    --useStorageIops <value>
#    --useStorageBandwidth <value>
#  $script_name setresources database
#    --databaseUniqueName <unique name of database>  
#    --useCpuCount <number>
#    --useSGAMemory <value>
#    --useStorageCapacity <value>
#    --useStorageIops <value>
#    --useStorageBandwidth <value>
  $script_name create services
    --pdbName <pdb name>
    --databaseUniqueName <unique name of database>  
    [--pdbPrimaryServiceName <free service name> 
       --pdbStandbyServiceName <free service name>
       --pdbAdminServiceName <free service name>
       --useNodes <number>]   
  $script_name dgfinish pdb
    --pdbName <pdb name>
    --databaseUniqueName <unique name of database>  
    [--primaryTnsServiceName <TNS entry to contact primary>] # Will default be set to --primaryDatabaseUniqueName
    [--pdbPrimaryServiceName <free service name> 
       --pdbStandbyServiceName <free service name>
       --pdbAdminServiceName <free service name>
       --useNodes <number>]
#  $script_name create stdpdbservices
#    {--pdbName <value>} |
#      {--pdbFreeName <value> 
#      --pdbApplicationCode <value> 
#      --pdbEnvironment <s|t|d|p>
#      --pdbDatePart <8 digigts>}
#    --useNodes <number>  
#      [--pdbPrimaryServicename <free service name>
#       --pdbStandbyServicename <free service name>]      
  $script_name delete pdb
    --databaseUniqueName <unique name of database>  
    --pdbName <value>
  $script_name create plugfile
    --databaseUniqueName <unique name of database>  
    --pdbName <value>
    [--pdbPlugFile <filename of pdb file, should end on .pdb>]
  $script_name delete services
    --databaseUniqueName <unique name of database>  
  $script_name snapshot services
    --databaseUniqueName <unique name of database>  
  $script_name harden pdb
    --databaseUniqueName <unique name of database>  
    --pdbName <value>
    [--fixStaticGrants]
  $script_name list pdb
    --databaseUniqueName <unique name of database>  
    --pdbName <value>
#  $script_name check pdb
#    --databaseUniqueName <unique name of database>  
#    --pdbName <value>
#    --checks [<one or more of space,services with comma between>
#    --tryFix
  $script_name switchover database # Should be called on standby site
    --databaseUniqueName <unique name of database to switchover to>
    [--sysPassword <sys users password>]
    [--sysPasswordFile <file with sys password> ]
    [--ignoreTests]
    [--maxTransportLag <lag in seconds> ]
    [--maxApplyLag <lag in seconds> ]
    [--dryRun]
    [--autoFix <one or more of dataguard,spfile,tempfiles,services with comma between>]
  $script_name prepare standby
    --databaseUniqueName <unique name of database>   
    --standbyDuplicateNode <node name to start instance in mount mode>
  $script_name duplicate standby
    --databaseUniqueName <unique name of database>
    --standbyDatabaseUniqueName <database unique name of the standby database>
    [--sysPassword <sys users password>]
    [--sysPasswordFile <file with sys password> ]
    [--switchOver]
  $script_name finish standby
    --databaseUniqueName <unique name of database>
    --standbyDatabaseUniqueName <database unique name of the standby database>
    [--sysPassword <sys users password>]
    [--switchOver]
  $script_name prepare rman
    --databaseUniqueName <unique name of database>     
  $script_name demultiplex standbylog
    --databaseUniqueName <unique name of database>    
  $script_name distribute passwordfile
    --databaseUniqueName <unique name of database>    
  $script_name delete database
    --databaseUniqueName <unique name of database>
    [--shutdownDatabase]
    [--includingBackup]
  $script_name create database
    --oracleHome <Path to the Oracle Home where the database should run from>
    --runOnNodes <The nodes on which the datbase will be created>
    [--databaseType <The database type that will be created> | 
      [ --useCpuCount <number>  --useSGAMemory <value> --useStorageCapacity <value>
        --useStorageIops <value> --useStorageBandwidth <value>]] 
    --databaseName <The raw database name>|--databaseUniqueName <unique name of database>
    [--registerWithEm]
    [--createAsContainer]
    [--ignorePreReqs]
    [--skipTns ] 
    [--characterSet <Characterset to use >]
    [--nationalCharacterSet <National Characterset to use>]
    [--nlsLengthSemantics char|byte]
    [--installOnNodes <Comma separated list of node names>]
    [--asmDataDiskGroup <The ASM diskgroup for data>]
    [--asmRecoDiskGroup <The ASM diskgroup for Recovery files etc>] 
    [--datacenterUniqueNumber <single digit>]
    [--datacenterSite <single letter>]
    [--prepareAsStandby 
      [--primaryScanListener <scan listener dns of primary db>
       --primaryDatabaseUniqueName <database unique name of the primary database>
      ]|[--prepareAsPrimary 
      [--standbyScanListener <scan listener dns of standby db>
       --standbyDatabaseUniqueName <database unique name of the standby database>
       --standbyVip <vip name of standby database where we will duplicate to>
       [--standbyAsmDataDiskGroup <The ASM diskgroup for data on standby site>]
       [--standbyAsmRecoDiskGroup <The ASM diskgroup for reco on standby site>]
      ]   
    ]

More explanation of parameters
--oracleHome   <Path to the Oracle Home where the database should run from>
--runOnNodes   <Comma separated list of node names the database will actively
               run on after the install>
--databaseType <The database type that will be created>. Can be one of pico,micro,
               tiny,small,medium or large or variable. Will set various sizing
               parameters differently. If the two parameters
               --useSGAMemory or --useCpuCount has is set parameters will be 
               calculated dynamically based on theese values.
--databaseName <The database name to create. This should NOT include the
               datacenter sites "letter" as that will be added by other means.
               Also be aware the the last letter has to be one of (s=sandbox,
               t=test,p=production,d=development)
--characterSet <Characterset to use when creating the database>. If not
               specified it will default to AL32UTF8>
--nationalCharacterSet
               <National Characterset to use when creating the database>. If
               not specified it will default to AL16UTF16>
--nlsLengthSemantics
               <enables you to create CHAR and VARCHAR2 columns using either
               byte or character length semantics. Default is char, possible
               values are [byte|char]>
--installOnNodes
               <What nodes will the database instances be registered on.
               Normally we will prepare running instances on all nodes which
               is the default if the parameter is not specified.
--asmDataDiskGroup
               <The ASM diskgroup for data. If not specified will default to
               the diskgroup on the cluster that starts with DATA>
--asmRecoDiskGroup
               <The ASM diskgroup for Recovery files etc. If not specified will
               default to the diskgroup on the cluster that starts with RECO
--datacenterUniqueNumber
               <A single digit that identifies a unique number of the database
               on a specific site. Normally 1, but if a standby database is 
               created on the same site this option needs to be specified. The
               number specified should be different than all other numbers used
               for this database on this site.
               Default value 1.
--datacenterSite
               <The single letter that identifies the datacenter (c,h or o).
               Will default try to find the site the cluster is located on>
--prepareAsStandby
               Will prepare the database to be a standby database. That is it
               will create the database and then clean it out. Enable dataguard
               broker and start it an instance in mount mode.
--primaryScanListener
               <scan listenere of the primary database> Can be used when 
               specifying  --prepareAsStandby. If this and
               --primaryDatabaseUniqueName is specified tns entries will be
               created automtically for a two site data guard setup.
--primaryDatabaseUniqueName
               <database unique name of the primary database>  Can be used when 
               specifying  --prepareAsStandby. If this and
               --primaryScanListener is specified tns entries will be
               created automtically for a two site data guard setup.
--prepareAsPrimary
               Will prepare the database to be a primary database. That is it
               will create the database and create standby log files. Enable
               dataguard broker and start the database. Will print needed
               information to be used when finalizing the Data Guard setup.
--standbyScanListener
               <scan listenere of the standby database> Can be used when 
               specifying  --prepareAsPrimary. If this and --standbyVip and
               --standbyDatabaseUniqueName is specified tns entries will be
               created automtically for a two site data guard setup.
--standbyDatabaseUniqueName
               <database unique name of the standby database> Can be used when 
               specifying  --prepareAsPrimary. If this and --standbyVip and
               --standbyScanListener is specified tns entries will be
               created automtically for a two site data guard setup.
--standbyVip 
               <vip name of standby database where we will duplicate to>  Can be
               used when specifying  --prepareAsPrimary. If this and 
               --standbyDatabaseUniqueName and --standbyScanListener is
               specified tns entries will be created automtically for a two site
               data guard setup.
--standbyAsmDataDiskGroup
               <The ASM diskgroup for data on standby site> Can be
               used when specifying --prepareAsPrimary. Will help generate rman
               scripts and dataguard broker entries.
--standbyAsmRecoDiskGroup
               <The ASM diskgroup for reco on standby site> Can be
               used when specifying --prepareAsPrimary. Will help generate rman
               scripts and dataguard broker entries.
--registerWithEm
               Will register the database in Enterprise Manager
--ignorePreReqs
               Will ignore DBCA's prerequisite checks. Only use if there are 
               "known" failures in the checks.
--forceMultiplePdbs
               Will allow to install more than one PDB in a preprod and Prod CDB
--pdbPlugFile
               <full path to pdb file containing unplugged pdb> Van be used for
               using another pdb as basis for a new one. Normally used ehen creating 
               PDB's with another characterset than AL32UTF8 in a AL32UTF8 CDB.
--dryRun       Only do checks and maybe print what would have been done. Will 
               return error if any of the checks fails.
--dontReloadListener
               Used to avoid reload the listener.ora when the static configuration are
               changed. Typically used when patching a lot of databases. Remember
               at the end of patching then to maually reload the listeners (with 75s
               between)
--sysPasswordFile
               A file with single line in it that contains sys password. Use this
               to having sys pasword being shown in ps commands
EOF
}


delete_database_report()
{
  # We will now create some logs about what we have deleted
  # Make sure log directory is there
  mkdir -p $LOG_DIRECTORY
  echo "Script Version: $SVERSION" >$LOG_DIRECTORY/report.txt
  echo "Probably executed by: $(logname)"
  echo "Database name: ${DATABASE_UNIQUE_NAME}"
  echo "Command Line parameters:  CMD_LINE_PARAMS" >>$LOG_DIRECTORY/report.txt
}

create_database_report()
{
  # We will now create some logs about what we have build
  # Make sure log directory is there
  mkdir -p $LOG_DIRECTORY
  echo "Script Version: $SVERSION" >$LOG_DIRECTORY/report.txt
  echo "Probably executed by: $(logname)">>$LOG_DIRECTORY/report.txt
  echo "Database name: ${DATABASE_NAME}"
  echo "Command Line parameters:  $CMD_LINE_PARAMS" >>$LOG_DIRECTORY/report.txt
  echo "Config Database ($ORACLE_HOME/bin/srvctl config database -d $DATABASE_UNIQUE_NAME -v -a):">>$LOG_DIRECTORY/report.txt
  echo "===Config Database START===">>$LOG_DIRECTORY/report.txt
  $ORACLE_HOME/bin/srvctl config database -d $DATABASE_UNIQUE_NAME -v -a >>$LOG_DIRECTORY/report.txt
  echo "===Config Database END===">>$LOG_DIRECTORY/report.txt
  echo "Status Database ($ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME -v -f):">>$LOG_DIRECTORY/report.txt
  echo "===Status Database START===">>$LOG_DIRECTORY/report.txt
  $ORACLE_HOME/bin/srvctl status database -d $DATABASE_UNIQUE_NAME -v -f >>$LOG_DIRECTORY/report.txt
  echo "===Status Database END===">>$LOG_DIRECTORY/report.txt
  echo "Status Service ($ORACLE_HOME/bin/srvctl status service -d $DATABASE_UNIQUE_NAME -v):">>$LOG_DIRECTORY/report.txt
  echo "===Status Service START===">>$LOG_DIRECTORY/report.txt
  $ORACLE_HOME/bin/srvctl status service -d $DATABASE_UNIQUE_NAME -v >>$LOG_DIRECTORY/report.txt
  echo "===Status Service END===">>$LOG_DIRECTORY/report.txt
  # Find artifacts and put them in catalog as zip file including the report.txt
  # $LOG_DIRECTORY/report.txt
  # $COMMON_TEMPLATES_DIRECTORY
  database_name_uppercase=$(convert_to_upper ${DATABASE_NAME})
  database_name_lowercase=$(convert_to_lower ${DATABASE_NAME})
  database_unique_name_lowercase=$(convert_to_lower ${DATABASE_UNIQUE_NAME})
  ssh -o 'StrictHostKeyChecking no' $node_selected mv ${dbca_logs_directory}/${database_unique_name_lowercase} ${LOG_DIRECTORY} 
  ssh -o 'StrictHostKeyChecking no' $node_selected mv ${LIB_LOG_LOCATION}/${database_name_uppercase}* ${LIB_LOG_LOCATION}/${database_name_lowercase}* ${LOG_DIRECTORY}
  ssh -o 'StrictHostKeyChecking no' $node_selected mv ${LOG_DIRECTORY} ${LOG_DIRECTORY}_${database_unique_name_lowercase}
}

#set_grid_home()
#{
#  local ORA_TAB=/etc/oratab
#  if [ -f $ORA_TAB ]
#  then
#    local ASM_TAB_LINE=`grep "+ASM" $ORA_TAB`
#    GRID_ORACLE_SID=${ASM_TAB_LINE%%:*}
#    local ASM_TAB_LINE=${ASM_TAB_LINE#*:}
#    GRID_ORACLE_HOME=${ASM_TAB_LINE%%:*}
#  fi
#}


set_grid_home()
{
  local ORAINST_LOC="/etc/oraInst.loc"
  if [ -f $ORAINST_LOC ]
  then
    local ORAINVENTORY_LOCATION=`cat $ORAINST_LOC 2>>/dev/null | sed -n -e 's/inventory_loc=\(.*\)/\1/p' 2>>/dev/null`
    if [ "$ORAINVENTORY_LOCATION" != "" ]
    then
      GRID_ORACLE_HOME=`grep -v ".*REMOVED=\"T" ${ORAINVENTORY_LOCATION}/ContentsXML/inventory.xml 2>>/dev/null | sed -n -e '/<HOME NAME=.*CRS="true"/s/.*LOC=\"\([^\"]*\)\".*CRS="true".*/\1/p' 2>>/dev/null`
    fi
  fi
  # Get ASM Instance on this box
  GRID_ORACLE_SID=`ps -ef | grep pmon_+ASM | grep asm_ | sed -n "s/.*\(+ASM[0123456789][0123456789]*\)/\1/p"`
}


delete_database()
{
  #set -x
  local database_unique_name="$1"
  local shutdown_database="$2"
  local including_backup="$3"
  local status
  local database_oracle_home
  #echo "database_unique_name=$database_unique_name"
  #echo "shutdown_database=$shutdown_database"
  # Set grid environment
  set_grid_home
  # First Check if database exists
  # Find databases Oracle_home
  DB_ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${database_unique_name}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  if [ "$DB_ORACLE_HOME" == "" ]
  then
    # Does not exists as we can't find connected home
    cecho r "  ERROR: Database ${database_unique_name} is not configured on this cluster"
    exit 1
  fi
  # First find a node where it's running
  local node_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get node where there is a instanse of ${database_unique_name} running"
    exit 1
  fi
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get a running instanse of ${database_unique_name}"
    exit 1
  fi
  # We need to test if we run RAC or NOT
  CHECK_CLUSTER_DB_SQL="set heading off
set feedback off
WHENEVER SQLERROR EXIT SQL.SQLCODE
select upper(value) from v\\\$parameter where name = 'cluster_database';
exit;"
  CHECK_CLUSTER_DB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CHECK_CLUSTER_DB_SQL\" | $DB_ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_CHECK_CLUSTER_DB=$?
  CHECK_CLUSTER_DB_RESULT=$(trim ${CHECK_CLUSTER_DB_RESULT})
  if [ $RESULT_FROM_CHECK_CLUSTER_DB -ne 0 ]
  then
    cecho r "  ERROR: Problem Checking if Database runs RAC. SQL*plus returned Error code $RESULT_FROM_CHECK_CLUSTER_DB."
    cecho r "${CHECK_CLUSTER_DB_RESULT}"
    exit 1
  fi
  #echo "CHECK_CLUSTER_DB_RESULT=$CHECK_CLUSTER_DB_RESULT"
  # If non cluster database
  if [ "$CHECK_CLUSTER_DB_RESULT" == "FALSE" ]
  then
    # Now get password location as as we migth need to delete this for NON RAC databases later
    ORAPWD_FILE=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl config database -d $database_unique_name |  sed -n "s/^Database instance\(s\)\{0,1\}:\(.*\)/\2/p")
    ORAPWD_FILE=$(trim ${ORAPWD_FILE})
    echo "ORAPWD_FILE=$ORAPWD_FILE"
  fi
  status=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name})
  if [ $? -ne 0 ]
  then
    # Does not exists
    cecho r "  ERROR: Database ${database_unique_name} is not configured on this cluster"
    exit 1
  fi
  # TBD Figure out if we run data guard and if we are primary or standby
  # If promary then remove configuration
  # If standby remove standby database from configuration
  # Are instances running?
  echo "$status" | grep "is running">/dev/null
  if [ $? -eq 0 ]
  then
    # Instances are running
    # Check that we have shudown_database="YES" before continuing
    if [ "$shutdown_database" == "YES" ]
    then
      # We will try to stop it
      status=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl stop database -d ${database_unique_name})
      if [ $? -ne 0 ]
      then
        # Ouch we can't stop it
        cecho r "  ERROR: Can't stop database ${database_unique_name} - manuel intervention required"
        exit 1
      fi
    else
      # We are not allowed to stop it
      cecho r "  ERROR: Database ${database_unique_name} is running, Can't be deleted while running"
      exit 1
    fi
  fi
  # Evrything is shudown
  # We want to delete backups to?
  if [ "$including_backup" = "YES" ]
  then
    # First find a first node where it exists but is not nessecarily started (don't grep for running)
    node_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
    # Then find instance on that node
    sid_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p") 
    # On specific node startup in restricted mode
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"startup mount exclusive restrict;\" | $DB_ORACLE_HOME/bin/sqlplus / as sysdba"
    # Then diasble dataguard broker,  and make database non rac
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"alter system set dg_broker_start=false scope=both;\nALTER SYSTEM SET CLUSTER_DATABASE=FALSE SCOPE=SPFILE;\nshutdown immediate;\" | $DB_ORACLE_HOME/bin/sqlplus / as sysdba"
    # On specific node startup in restricted mode
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"startup mount exclusive restrict;\" | $DB_ORACLE_HOME/bin/sqlplus / as sysdba"    
    # Use rman to delete evrything
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"DROP DATABASE INCLUDING BACKUPS NOPROMPT;\" | $DB_ORACLE_HOME/bin/rman target /"
    # Remove cluster configuration
    (export ORACLE_HOME=$DB_ORACLE_HOME; $DB_ORACLE_HOME/bin/srvctl remove database -d ${database_unique_name} -f)
  else
    # Ok now delete the bastard using the dbca command in the databases home catalog
    # Do the delete in a subshell
    (export ORACLE_HOME=$DB_ORACLE_HOME; $DB_ORACLE_HOME/bin/dbca -silent -deleteDatabase -sourceDB ${database_unique_name})
  fi
  # Clean out other OS files
  # If non cluster database
  if [ "$CHECK_CLUSTER_DB_RESULT" == "FALSE" ]
  then
    # In non RAC this file may be lying arround - only do this for NON RAC TBD
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; $DB_ORACLE_HOME/bin/orapwd delete=y file=\"${ORAPWD_FILE}\""
  fi
  # Maybe call the grid user to have him fully clean out the ASM data  
}

generate_pdb_sql()
{
  #set -x
  local GUID=$1
  local DATA_ONLY=$2
  local where_clause
  local statement
  local sql_plus_preamble
  if [ "$GUID" = "" ]
  then
    where_clause="pdb.pdb_name not in (''PDB\\\$SEED'')"
  else
    where_clause="pdb.guid = ''$GUID''"
  fi  
  if [ "$DATA_ONLY" != "YES" ]
  then
    sql_plus_preamble="set heading off
set pagesize 0
set linesize 80
set feedback off
COLUMN DB_UNIQUE_NAME FORMAT A12
COLUMN GUID FORMAT A32
COLUMN PDB_NAME FORMAT A32"
    statement="v_pdbs_exist_statement varchar2(2000) := 'select vdb.DB_UNIQUE_NAME, pdb.guid ,lower(pdb.pdb_name) PDB_NAME 
                              from v\\\$database vdb, DBA_PDBS pdb
                              where ${where_clause}';"
  else
    sql_plus_preamble="set heading off
set pagesize 0
set feedback off"
    statement="v_pdbs_exist_statement varchar2(2000) := 'select vdb.DB_UNIQUE_NAME||'':''|| pdb.guid||'':''||lower(pdb.pdb_name) 
                              from v\\\$database vdb, DBA_PDBS pdb
                              where ${where_clause}';"
  fi

  echo "$sql_plus_preamble
VARIABLE v_pdb_mappings REFCURSOR
DECLARE
  v_suppports_pdbs number;
  $statement
BEGIN
  select count(*)
  into v_suppports_pdbs
  from all_objects
  where object_type in ('TABLE','VIEW')
  and object_name = 'DBA_PDBS';
  IF v_suppports_pdbs > 0
  THEN
    open :v_pdb_mappings FOR v_pdbs_exist_statement;
  ELSE
    open :v_pdb_mappings FOR select NULL from dual where 2=3;
  END IF;
END;
/
print v_pdb_mappings
"
}



delete_pdb()
{
  #set -x
  local PDB_NAME=$1
  local DATABASE_UNIQUE_NAME=$2
  local ORACLE_HOME=$3
  PDB_RUNNING_SERVICES=$(export ORACLE_HOME=${ORACLE_HOME};$ORACLE_HOME/bin/srvctl status service -d ${DATABASE_UNIQUE_NAME} -pdb  ${PDB_NAME} | sed -n "s/Service[[:blank:]]\(.*\)[[:blank:]]*is running.*/\1/p")
  PDB_SERVICES=$(export ORACLE_HOME=${ORACLE_HOME};$ORACLE_HOME/bin/srvctl status service -d ${DATABASE_UNIQUE_NAME} -pdb  ${PDB_NAME} | sed -n "s/Service[[:blank:]]\(.*\)[[:blank:]]*is.*/\1/p")
  for service in $PDB_RUNNING_SERVICES
  do
    echo "   INFO: Stoping Service ${service}"
    $(export ORACLE_HOME=${ORACLE_HOME};${ORACLE_HOME}/bin/srvctl stop  service -db ${DATABASE_UNIQUE_NAME} -service ${service})
  done
  for service in $PDB_SERVICES
  do
    echo "   INFO: Removing Service ${service}"
    $(export ORACLE_HOME=${ORACLE_HOME};${ORACLE_HOME}/bin/srvctl remove service -db ${DATABASE_UNIQUE_NAME} -service ${service}) 
  done
  #set -x
  DELETE_PDB_SQL="set serveroutput on
--WHENEVER SQLERROR CONTINUE
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
   PDB_ALREADY_CLOSED EXCEPTION; 
   PRAGMA EXCEPTION_INIT (PDB_ALREADY_CLOSED, -65020); 
BEGIN
  execute immediate 'ALTER PLUGGABLE DATABASE ${PDB_NAME} CLOSE IMMEDIATE INSTANCES = ALL';
EXCEPTION
  WHEN PDB_ALREADY_CLOSED THEN
    --Ignore if it's already closed
    NULL;
END;
/
begin    
  FOR restore_points IN (select vrp.name restore_point, vpdbs.name con_name
    from
      v\\\$restore_point vrp,
      v\\\$pdbs vpdbs
    where
      vrp.con_id=vpdbs.con_id
      and lower(vpdbs.name)=lower('$PDB_NAME')
    )
  LOOP
    dbms_output.put_line( 'DROP RESTORE POINT '||restore_points.restore_point||' for pluggable database '|| restore_points.con_name||';' );
    EXECUTE IMMEDIATE 'DROP RESTORE POINT '||restore_points.restore_point||' for pluggable database '|| restore_points.con_name;
  END LOOP;
end;
/
WHENEVER SQLERROR EXIT SQL.SQLCODE
DROP PLUGGABLE DATABASE ${PDB_NAME} INCLUDING DATAFILES;  
"
  DELETE_PDB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$DELETE_PDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_DELETION=$?
  if [ $RESULT_FROM_DELETION -ne 0 ]
  then
    echo "${DELETE_PDB_RESULT}"
    cecho r "  ERROR: Problem deleting PDB. SQL*plus returned Error code $RESULT_FROM_DELETION."
    exit 1
  fi
  cecho g "     OK: Deleted PDB ${PDB_NAME}"
}


create_plugfile()
{
  #set -x
  local DATABASE_UNIQUE_NAME=$1
  local PDB_NAME=$2
  local PDB_PLUG_FILE=$3
  CREATE_PLUG_FILE_SQL="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE
ALTER PLUGGABLE DATABASE ${PDB_NAME} CLOSE IMMEDIATE INSTANCES = ALL;
ALTER PLUGGABLE DATABASE ${PDB_NAME} UNPLUG INTO '${PDB_PLUG_FILE}';
"
  CREATE_PLUG_FILE_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CREATE_PLUG_FILE_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_CREATE_PLUGFILE=$?
  if [ $RESULT_FROM_CREATE_PLUGFILE -ne 0 ]
  then
    echo "${CREATE_PLUG_FILE_RESULT}"
    cecho r "  ERROR: Problem creating plug file from PDB. SQL*plus returned Error code $RESULT_FROM_CREATE_PLUGFILE."
    exit 1
  fi
  cecho g "     OK: create plug file ${PDB_PLUG_FILE}"
}

harden_pdb()
{
  #set -x
  local PDB_NAME=$1
  local DATABASE_UNIQUE_NAME=$2
  local ORACLE_HOME=$3
  local PDB_FIX_STATIC_GRANTS=$4
  #set -x
  HARDEN_PDB_SQL="set serveroutput on
--WHENEVER SQLERROR CONTINUE
WHENEVER SQLERROR EXIT SQL.SQLCODE
ALTER PLUGGABLE DATABASE ${PDB_NAME} CLOSE IMMEDIATE INSTANCES = ALL;
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
  P_PDBNAME VARCHAR2(200);
BEGIN
  P_PDBNAME := '$PDB_NAME';
  DBMGMT.HARDEN_PDB(
    P_PDBNAME => P_PDBNAME
  );
  IF '$PDB_FIX_STATIC_GRANTS' = 'YES'
  THEN
    DBMGMT.FIX_REVOKED_GRANTS_PDB(
      P_PDBNAME => P_PDBNAME
    );
  END IF;
--rollback; 
END;"
  HARDEN_PDB_SQL=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$DELETE_PDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_HARDENING=$?
  if [ $RESULT_FROM_HARDENING -ne 0 ]
  then
    echo "${HARDEN_PDB_SQL}"
    cecho r "  ERROR: Problem Hardening PDB. SQL*plus returned Error code $RESULT_FROM_HARDENING."
  fi
  cecho g "     OK: Deleted PDB ${PDB_NAME}"
}


create_stdpdbservices()
{
  local DATABASE_UNIQUE_NAME=$1
  local USE_NODES=$2
  local PDB_PRIMARY_SERVICE_NAME=$3
  local PDB_STANDBY_SERVICE_NAME=$4
}

snapshot_services()
{
  local DATABASE_UNIQUE_NAME=$1
  local ORACLE_HOME=$2
  local SYS_PASSWORD=$3 # If given we will allow standby to upload to primary
  local PRIMARY_DB_NAME_ON_STANDBY=$4 # If given we will allow standby to upload to primary
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "ORACLE_HOME=$ORACLE_HOME"
  #echo "SYS_PASSWORD=$SYS_PASSWORD"
  if [ "$SYS_PASSWORD" != "" ]
  then
    # we want to run this on STANDBY and upload to primary
    local WE_RUN_AS_STANDBY="YES"
  fi
  # First find a node where it's configured
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get node where there is a instanse of ${DATABASE_UNIQUE_NAME} running"
    exit 1
  fi
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get a running instanse of ${DATABASE_UNIQUE_NAME}"
    exit 1
  fi
  # Now start more logical checks that can be done while the above was successfull
  local errors_found=0
  local last_result=""
  local last_error_code=0

  # Check that this is a primary/standby database database depending on SYS password given
  # We should have checked this before coming here
  #last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_STANDBY_SQL" "-S" )
  #last_error_code=$?
  #if [ $last_error_code -ne 0 ]
  #then
  #  # failed
  #  cecho r "  ERROR: Call to get primary database name on primary failed with code=$last_error_code and error text=$last_result"
  #  (( errors_found++ ))    
  #else
  #  # success
  #  local PRIMARY_DB_NAME_ON_STANDBY=$(echo ${last_result})
  #  if [ "$PRIMARY_DB_NAME_ON_STANDBY" = "" ]
  #  then
  #    # We are on a primary
  #    if [ "$WE_RUN_AS_STANDBY" = "YES" ] 
  #    then
  #      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is running as a primary database"
  #      (( errors_found++ ))
  #    else
  #      cecho g "     OK: $DATABASE_UNIQUE_NAME is running as a primary database"      
  #    fi
  #  else
  #    # We are on a standby
  #    if [ "$WE_RUN_AS_STANDBY" = "YES" ] 
  #    then
  #      cecho g "     OK: $DATABASE_UNIQUE_NAME is running as a standby database"
  #    else
  #      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is running as a standby database"
  #      (( errors_found++ ))
  #    fi
  #  fi     
  #fi
  # Now we have checked as much as we can
  # If any errors found, then abort

  # Just to make sure we don't have invalid packages - as we typically run this every night
  if [ "$WE_RUN_AS_STANDBY" != "YES" ] 
  then  
    # Recompile invalid objects
    last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "@$ORACLE_HOME/rdbms/admin/utlrp.sql;" "-S" )
    last_error_code=$?
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to recompile all sys packages in $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
      (( errors_found++ ))    
    else
      # success
      cecho g "     OK: Call to recompile all sys packages in $DATABASE_UNIQUE_NAME succeeded"      
    fi
  fi
  
  if [ $errors_found -ne 0 ]
  then
    cecho r "  ERROR: $errors_found errors found in precheck - will exit with error"
    exit 1
  fi  
  echo "   INFO: Collecting info about all services on $DATABASE_UNIQUE_NAME - can take some time"
  ALL_SERVICES_INFO=$(export ORACLE_HOME=${ORACLE_HOME};${ORACLE_HOME}/bin/srvctl config  service -db ${DATABASE_UNIQUE_NAME})
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get all services for database $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$ALL_SERVICES_INFO"
    exit 2
  fi
  ##echo "$ALL_SERVICES_INFO"
  local active_record="NO"
  local service_name=""
  local SRVCTL_CONFIG_SERVICES_SQL="set serveroutput on
WHENEVER SQLERROR CONTINUE
--drop table c##nordeasystem.snapshot_srvctl_config_service purge;
--WHENEVER SQLERROR EXIT SQL.SQLCODE
create table c##nordeasystem.snapshot_srvctl_config_service
(
COLLECTION_DATE                date DEFAULT SYSDATE,
DB_UNIQUE_NAME                 varchar2(128),
SERVICE_NAME                   varchar2(128),
SERVER_POOL                    varchar2(128),
CARDINALITY                    varchar2(128),
SERVICE_ROLE                   varchar2(128),
MANAGEMENT_POLICY              varchar2(128),
DTP_TRANSACTION                varchar2(128),
AQ_HA_NOTIFICATIONS            varchar2(128),
GLOBAL                         varchar2(128),
COMMIT_OUTCOME                 varchar2(128),
FAILOVER_TYPE                  varchar2(128),
FAILOVER_METHOD                varchar2(128),
TAF_FAILOVER_RETRIES           varchar2(128),
TAF_FAILOVER_DELAY             varchar2(128),
FAILOVER_RESTORE               varchar2(128),
CONNECTION_LOAD_BALANCING_GOAL varchar2(128),
RUNTIME_LOAD_BALANCING_GOAL    varchar2(128),
TAF_POLICY_SPECIFICATION       varchar2(128),
EDITION                        varchar2(128),
PLUGGABLE_DATABASE_NAME        varchar2(128),
MAXIMUM_LAG_TIME               varchar2(128),
SQL_TRANSLATION_PROFILE        varchar2(128),
RETENTION                      varchar2(128),
REPLAY_INITIATION_TIME         varchar2(128),
DRAIN_TIMEOUT                  varchar2(128),
STOP_OPTION                    varchar2(128),
SESSION_STATE_CONSISTENCY      varchar2(128),
GSM_FLAGS                      varchar2(128),
SERVICE_IS                     varchar2(128),
PREFERRED_INSTANCES            varchar2(128),
AVAILABLE_INSTANCES            varchar2(128),
CSS_CRITICAL                   varchar2(128)
);                                       
WHENEVER SQLERROR EXIT SQL.SQLCODE
delete from c##nordeasystem.snapshot_srvctl_config_service
where upper(db_unique_name)=upper('$DATABASE_UNIQUE_NAME');
"
  IFS=":"
  while read -r key value
  do
    # Check if key is empty
    if [ "$key" = "" ]
    then
      #echo "KEY IS EMPTY - new record"
      if [ "$active_record" = "YES" ]
      then
        # We have active data
        # Do stuff to add record
        #echo "Would write record for service name=$read_Service_name"
        NEW_RECORD="INSERT INTO c##nordeasystem.snapshot_srvctl_config_service (
    db_unique_name,
    service_name,
    server_pool,
    cardinality,
    service_role,
    management_policy,
    dtp_transaction,
    aq_ha_notifications,
    global,
    commit_outcome,
    failover_type,
    failover_method,
    taf_failover_retries,
    taf_failover_delay,
    failover_restore,
    connection_load_balancing_goal,
    runtime_load_balancing_goal,
    taf_policy_specification,
    edition,
    pluggable_database_name,
    maximum_lag_time,
    sql_translation_profile,
    retention,
    replay_initiation_time,
    drain_timeout,
    stop_option,
    session_state_consistency,
    gsm_flags,
    service_is,
    preferred_instances,
    available_instances,
    css_critical
) VALUES (
    '$DATABASE_UNIQUE_NAME',
    '$read_Service_name',
    '$read_Server_pool',
    '$read_Cardinality',
    '$read_Service_role',
    '$read_Management_policy',
    '$read_DTP_transaction',
    '$read_AQ_HA_notifications',
    '$read_Global',
    '$read_Commit_Outcome',
    '$read_Failover_type',
    '$read_Failover_method',
    '$read_TAF_failover_retries',
    '$read_TAF_failover_delay',
    '$read_Failover_restore',
    '$read_Connection_Load_Balancing_Goal',
    '$read_Runtime_Load_Balancing_Goal',
    '$read_TAF_policy_specification',
    '$read_Edition',
    '$read_Pluggable_database_name',
    '$read_Maximum_lag_time',
    '$read_SQL_Translation_Profile',
    '$read_Retention',
    '$read_Replay_Initiation_Time',
    '$read_Drain_timeout',
    '$read_Stop_option',
    '$read_Session_State_Consistency',
    '$read_GSM_Flags',
    '$read_Service_is',
    '$read_Preferred_instances',
    '$read_Available_instances',
    '$read_CSS_critical'
);
"
        SRVCTL_CONFIG_SERVICES_SQL="${SRVCTL_CONFIG_SERVICES_SQL}${NEW_RECORD}"
        # Then reset active_record
        active_record="NO"
        read_Service_name=""
        read_Server_pool=""
        read_Cardinality=""
        read_Service_role=""
        read_Management_policy=""
        read_DTP_transaction=""
        read_AQ_HA_notifications=""
        read_Global=""
        read_Commit_Outcome=""
        read_Failover_type=""
        read_Failover_method=""
        read_TAF_failover_retries=""
        read_TAF_failover_delay=""
        read_Failover_restore=""
        read_Connection_Load_Balancing_Goal=""
        read_Runtime_Load_Balancing_Goal=""
        read_TAF_policy_specification=""
        read_Edition=""
        read_Pluggable_database_name=""
        read_Maximum_lag_time=""
        read_SQL_Translation_Profile=""
        read_Retention=""
        read_Replay_Initiation_Time=""
        read_Drain_timeout=""
        read_Stop_option=""
        read_Session_State_Consistency=""
        read_GSM_Flags=""
        read_Service_is=""
        read_Preferred_instances=""
        read_Available_instances=""
        read_CSS_critical=""
      fi
    else
      # Process stuff
      # Remove leading whitespace
      value="${value#"${value%%[![:space:]]*}"}"
      case $key in
        "Service name") 
          # IF key is "Service name" then activate record and store service name
          active_record="YES"
          read_Service_name="$value"
          echo "   INFO: Processing service $read_Service_name"          
          ;;
        "Server pool")                    read_Server_pool="$value";;
        "Cardinality")                    read_Cardinality="$value";;
        "Service role")                   read_Service_role=$(sort_comma_separated_list "$value");;
        "Management policy")              read_Management_policy="$value";;
        "DTP transaction")                read_DTP_transaction="$value";;
        "AQ HA notifications")            read_AQ_HA_notifications="$value";;
        "Global")                         read_Global="$value";;
        "Commit Outcome")                 read_Commit_Outcome="$value";;
        "Failover type")                  read_Failover_type="$value";;
        "Failover method")                read_Failover_method="$value";;
        "TAF failover retries")           read_TAF_failover_retries="$value";;
        "TAF failover delay")             read_TAF_failover_delay="$value";;
        "Failover restore")               read_Failover_restore="$value";;
        "Connection Load Balancing Goal") read_Connection_Load_Balancing_Goal="$value";;
        "Runtime Load Balancing Goal")    read_Runtime_Load_Balancing_Goal="$value";;
        "TAF policy specification")       read_TAF_policy_specification="$value";;
        "Edition")                        read_Edition="$value";;
        "Pluggable database name")        read_Pluggable_database_name="$value";;
        "Maximum lag time")               read_Maximum_lag_time="$value";;
        "SQL Translation Profile")        read_SQL_Translation_Profile="$value";;
        "Retention")                      read_Retention="$value";;
        "Replay Initiation Time")         read_Replay_Initiation_Time="$value";;
        "Drain timeout")                  read_Drain_timeout="$value";;
        "Stop option")                    read_Stop_option="$value";;
        "Session State Consistency")      read_Session_State_Consistency="$value";;
        "GSM Flags")                      read_GSM_Flags="$value";;
        "Service is enabled")             read_Service_is="enabled";;
        "Service is disabled")            read_Service_is="disabled";;
        "Preferred instances")            read_Preferred_instances=$(sort_comma_separated_list "$value");;
        "Available instances")            read_Available_instances=$(sort_comma_separated_list "$value");;
        "CSS critical")                   read_CSS_critical="$value";;          
      esac
    fi
  done <<< "$ALL_SERVICES_INFO"
  unset IFS
  # IF active_record add this also
  if [ "$active_record" = "YES" ]
  then
    # We have active data
    # Do stuff to add record
    #echo "Would write record for service name=$service_name"
    NEW_RECORD="INSERT INTO c##nordeasystem.snapshot_srvctl_config_service (
    db_unique_name,
    service_name,
    server_pool,
    cardinality,
    service_role,
    management_policy,
    dtp_transaction,
    aq_ha_notifications,
    global,
    commit_outcome,
    failover_type,
    failover_method,
    taf_failover_retries,
    taf_failover_delay,
    failover_restore,
    connection_load_balancing_goal,
    runtime_load_balancing_goal,
    taf_policy_specification,
    edition,
    pluggable_database_name,
    maximum_lag_time,
    sql_translation_profile,
    retention,
    replay_initiation_time,
    drain_timeout,
    stop_option,
    session_state_consistency,
    gsm_flags,
    service_is,
    preferred_instances,
    available_instances,
    css_critical
) VALUES (
    '$DATABASE_UNIQUE_NAME',
    '$read_Service_name',
    '$read_Server_pool',
    '$read_Cardinality',
    '$read_Service_role',
    '$read_Management_policy',
    '$read_DTP_transaction',
    '$read_AQ_HA_notifications',
    '$read_Global',
    '$read_Commit_Outcome',
    '$read_Failover_type',
    '$read_Failover_method',
    '$read_TAF_failover_retries',
    '$read_TAF_failover_delay',
    '$read_Failover_restore',
    '$read_Connection_Load_Balancing_Goal',
    '$read_Runtime_Load_Balancing_Goal',
    '$read_TAF_policy_specification',
    '$read_Edition',
    '$read_Pluggable_database_name',
    '$read_Maximum_lag_time',
    '$read_SQL_Translation_Profile',
    '$read_Retention',
    '$read_Replay_Initiation_Time',
    '$read_Drain_timeout',
    '$read_Stop_option',
    '$read_Session_State_Consistency',
    '$read_GSM_Flags',
    '$read_Service_is',
    '$read_Preferred_instances',
    '$read_Available_instances',
    '$read_CSS_critical'
);
"
    SRVCTL_CONFIG_SERVICES_SQL="${SRVCTL_CONFIG_SERVICES_SQL}${NEW_RECORD}"
    # Then reset active_record
    active_record="NO"
  fi
  # Recreate table and insert data for srvctl config services
  #echo "$SRVCTL_CONFIG_SERVICES_SQL"
  if [ "$WE_RUN_AS_STANDBY" = "YES" ] 
  then
    # Upload using sys password
    #echo "will upload using sys password $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba"
    last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${SRVCTL_CONFIG_SERVICES_SQL}\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba")
  else
    # Just do local inserts
    last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$SRVCTL_CONFIG_SERVICES_SQL" "-L -S" )
  fi
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Problem creating snapshot of srvctl config services on primary. Failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))
  else
    cecho g "     OK: Created snapshot of srvctl config services on primary"    
  fi    
}

delete_services()
{
  local PDB_NAME=$1
  local DATABASE_UNIQUE_NAME=$2
  local ORACLE_HOME=$3    
  #echo "PDB_NAME=$PDB_NAME"
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "ORACLE_HOME=$ORACLE_HOME"  
  PDB_RUNNING_SERVICES=$(export ORACLE_HOME=${ORACLE_HOME};$ORACLE_HOME/bin/srvctl status service -d ${DATABASE_UNIQUE_NAME} -pdb  ${PDB_NAME} | sed -n "s/Service[[:blank:]]\(.*\)[[:blank:]]*is running.*/\1/p")
  PDB_SERVICES=$(export ORACLE_HOME=${ORACLE_HOME};$ORACLE_HOME/bin/srvctl status service -d ${DATABASE_UNIQUE_NAME} -pdb  ${PDB_NAME} | sed -n "s/Service[[:blank:]]\(.*\)[[:blank:]]*is.*/\1/p")
  for service in $PDB_RUNNING_SERVICES
  do
    echo "   INFO: Stoping Service ${service}"
    $(export ORACLE_HOME=${ORACLE_HOME};${ORACLE_HOME}/bin/srvctl stop  service -db ${DATABASE_UNIQUE_NAME} -service ${service})
  done
  for service in $PDB_SERVICES
  do
    echo "   INFO: Removing Service ${service}"
    $(export ORACLE_HOME=${ORACLE_HOME};${ORACLE_HOME}/bin/srvctl remove service -db ${DATABASE_UNIQUE_NAME} -service ${service}) 
  done  
}

patch_primary()
{
  local DATABASE_UNIQUE_NAME=$1
  local NEW_ORACLE_HOME=$2
  local DRY_RUN=$3
  local DONT_RELOAD_LISTENER=$4
  local VERBOSE=$5
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "NEW_ORACLE_HOME=$NEW_ORACLE_HOME"
  #echo "DRY_RUN=$DRY_RUN"
  local LOG_DIRECTORY="${DBPATCH_CLUSTERED_LOG_LOCATION}/$DATABASE_UNIQUE_NAME"
  if [ "$DRY_RUN" = "YES" ]
  then
    local LOG_FILE="${LOG_DIRECTORY}/dry_run_patch_primary_${DATABASE_UNIQUE_NAME}_${now}.log"
  else
    local LOG_FILE="${LOG_DIRECTORY}/patch_primary_${DATABASE_UNIQUE_NAME}_${now}.log"
  fi
  # Let's create log directory
  mkdir -p ${LOG_DIRECTORY}
  # Let's log every normal screen output to log file also
  exec   > >(tee -ia $LOG_FILE)
  exec  2> >(tee -ia $LOG_FILE >& 2)
  # We have tested that new home is different then old home and that new home exists
  # Let's create log directory
  # We have tested that new home is different then old home and that new home exists
  # Find database Oracle_home
  local ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${DATABASE_UNIQUE_NAME}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  # First find a node where it's configured
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get node where there is a instanse of ${DATABASE_UNIQUE_NAME} running"
    exit 1
  fi
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get a running instanse of ${DATABASE_UNIQUE_NAME}"
    exit 1
  fi
  # Now start more logical checks that can be done while the above was successfull
  local errors_found=0
  local warnings_found=0
  local last_result=""
  local last_error_code=0
  
  # Recompile invalid objects
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "@$ORACLE_HOME/rdbms/admin/utlrp.sql;" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to recompile all sys packages in $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    cecho g "     OK: Call to recompile all sys packages in $DATABASE_UNIQUE_NAME succeeded"      
  fi
    
  # Check that all components are valid
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$INVALID_COMPONENTS_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get Primary database component status failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    local INVALID_COMPONENTS=$(echo ${last_result})
    if [ "$INVALID_COMPONENTS" != "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having invalid components $last_result"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is having valid components"      
    fi     
  fi


  # Check that all sys objects are valid
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$INVALID_SYS_OBJECTS_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get Primary database SYS objects status failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    local INVALID_OBJECTS=$(echo ${last_result})
    if [ "$INVALID_OBJECTS" != "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having invalid SYS objects $last_result"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is having valid SYS components"      
    fi     
  fi  

  # Check that there is no pdb plugin violations
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PDB_PLUG_IN_VIOLATIONS_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get PDB plugin violations failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    local PDB_PLUG_IN_VIOLATIONS=$(echo ${last_result})
    if [ "$PDB_PLUG_IN_VIOLATIONS" != "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having PDB plugin violations $last_result"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is having no PDB plugn violations"      
    fi     
  fi  

  # Check that this is a primary database
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_PRIMARY_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get primary database name on primary failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    local PRIMARY_DB_NAME_ON_PRIMARY=$(echo ${last_result})
    if [ "$PRIMARY_DB_NAME_ON_PRIMARY" = "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is not running as a primary database"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is running as a primary database"      
    fi     
  fi 
  
  # Now maybe check if we are "real primary" e.g. in a data guard setup, we should not move on unless all transports are off
  # Check if database has standbys and if they have apply-off
  #dgmgrl -silent / "show configuration" | sed -n "s/[[:space:]]*\(.*\)[[:space:]]*-[[:space:]]*.*standby database/\1/p"  
  # Check Transport lag is less than 10 seconds
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show configuration" "-silent")
  last_error_code=$?
  # Used later to determine if we should handle a dataguard setup
  local STANDBYS_ACTIVE="NO"
  if [ $last_error_code -ne 0 ]
  then
    # failed
    # maybe no data guard configuration exists, then assume no data guard is setup
    local broker_unavailable_found=$( echo "$last_result" | grep  -i "ORA-16525")
    if [ "$broker_unavailable_found" != "" ]
    then
      # Assume there is no dataguard - silent ignore
      echo "   INFO: $DATABASE_UNIQUE_NAME dataguard broker not available - probably not configured - we assume no Data Guard"
    else
      cecho r "  ERROR: Call to dgmgrl to show configuration failed with code=$last_error_code and error text=$last_result"
      (( errors_found++ ))
    fi
  else  
    local STDBY_UNIQUE_NAMES=$( echo "$last_result" | sed -n "s/[[:space:]]*\(.*\)[[:space:]]*-[[:space:]]*.*standby database/\\1/p")
    if [ "$STDBY_UNIQUE_NAMES" != "" ]
    then
      echo "   INFO: $DATABASE_UNIQUE_NAME have standby databases"
      STANDBYS_ACTIVE="yes"
      for stdby_unique_name in $STDBY_UNIQUE_NAMES
      do      
        last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show database $stdby_unique_name" "-silent")
        last_error_code=$?
        if [ $last_error_code -ne 0 ]
        then
          # failed
          cecho r "  ERROR: Call to dgmgrl to show database failed with code=$last_error_code and error text=$last_result"
          (( errors_found++ ))    
        else
          local APPLY_MODE=$( echo "$last_result" | sed -n "s/[[:space:]]*Intended State:[[:space:]]*\\(.*\\)\$/\\1/p")
          last_error_code=$?
          if [ $last_error_code -ne 0 ]
          then
            # failed
            cecho r "  ERROR: Call to sed to extract apply mode failed with code=$last_error_code and error text=$last_result"
            (( errors_found++ ))    
          else  
            if [ "$APPLY_MODE" != "APPLY-OFF" ]
            then
              (( warnings_found++ ))
              cecho p "WARNING: Apply mode of standby database $stdby_unique_name is $APPLY_MODE, should be APPLY-OFF. Have you run prepatch on standby database?"
            else
              cecho g "     OK: Apply mode of standby database $stdby_unique_name is APPLY-OFF"
            fi
          fi
        fi
      done
    fi
  fi
  
  # Now we have checked as much as we can
  # If any errors found, then abort
  if [ $errors_found -ne 0 ]
  then
    cecho r "  ERROR: $errors_found errors found in precheck - will exit with error"
    exit 1
  else
    if [ "$DRY_RUN" = "YES" ]
    then
      if [ $warnings_found -ne 0 ]
      then
        cecho p "WARNING: $warnings_found warnings found in precheck and using --dryRun"
        echo "         Will continue as warnings can't be avoided if standby is running"
      fi
    else
      if [ $warnings_found -ne 0 ]
      then
        cecho r "  ERROR: $warnings_found warnings found in precheck and we will not accept warnings when doing actual work"
        exit 1
      else
        cecho g "     OK: No errors found in precheck - will continue"
      fi
    fi
  fi
  
  # Only do this if Dataguard setup
  if [ "$STANDBYS_ACTIVE" = "yes" ]
  then
    # On specific node run dgmgrl script to turn apply off
    LOG_TRANSPORT_OFF_DGMGRL="edit database ${DATABASE_UNIQUE_NAME} set state='LOG-TRANSPORT-OFF';"
    last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$LOG_TRANSPORT_OFF_DGMGRL" "-silent" "$DRY_RUN" )
    last_error_code=$?
    if [ "$DRY_RUN" = "YES" ]
    then
      if [ "$VERBOSE" = "YES" ]
      then
        echo "   INFO: Would run command to turn transport off: $last_result"
      fi
    else
      if [ $last_error_code -ne 0 ]
      then
        # failed - exit immediately as we need to be able to do this
        cecho r "  ERROR: Turn transport off for $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
        exit 2    
      else  
        cecho g "     OK: Turn transport off for $DATABASE_UNIQUE_NAME succeeded"
      fi
    fi 
  fi

 
  # Now stop primary database
  # This is often not happening as the datbase won't go down - don't know why. 
  # We wil set a timer, if the timer triggers
  # then we will go to all nodes where the instance was running and do an abort
  # Before starting get all nodes,instances where db is running
  local nodes_instances_running=$(find_all_database_run_node_comma_sid $DATABASE_UNIQUE_NAME)
  #echo ">>>$nodes_instances_running<<<"
  local read_node_name=""
  local read_instance_name=""
  local seconds_to_wait=120
  if [ "$nodes_instances_running" != "" ]
  then
    # Ok some are running, prepare background stuff
    # submit to each server a job that will wait some time and then abort the instance
    for node_instance_pair in ${nodes_instances_running}
    do
      read_node_name=${node_instance_pair%,*}
      read_instance_name=${node_instance_pair#*,}
      #echo "read_node_name=$read_node_name"
      #echo "read_instance_name=$read_instance_name"
      if [ "$DRY_RUN" = "YES" ]
      then
        echo "   INFO: Would have started job that will wait $seconds_to_wait seconds and then try to abort instanse $read_instance_name"
      else
        echo "   INFO: Will start job that will wait $seconds_to_wait seconds and then try to abort instanse $read_instance_name if it have not been shutdown nicely before"
        echo "   INFO: Will start job that will wait $seconds_to_wait seconds and then try to abort instanse $read_instance_name if it have not been shutdown nicely before" >/tmp/${read_node_name}_${read_instance_name}
        ssh -o 'StrictHostKeyChecking no' $read_node_name "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$read_instance_name; sleep $seconds_to_wait; echo -e \"connect / as sysdba\nshutdown abort;\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba;"  >/tmp/${read_node_name}_${read_instance_name} 2>&1 &
      fi
    done
  fi
  last_result=$(call_srvctl "$ORACLE_HOME" "stop database -db ${DATABASE_UNIQUE_NAME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to stop database: $last_result"
    fi
  else
    # Before moving on make sure we kill all background "shutdown abort" jobs immediate as we have 
    # either successfully shutdown the database or they have shutdown aborted the instanses
    # Wait first a litle to make sure they all have evnetually had a chance to do sutdown abort
    sleep 4
    # Then kill remaining ones
    kill $(jobs -p)
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Stopping database ${DATABASE_UNIQUE_NAME} failed with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Stopping database ${DATABASE_UNIQUE_NAME} succeeded"
    fi
  fi
  
  # Modify Oracle Home
  last_result=$(call_srvctl "$ORACLE_HOME" "modify database -db ${DATABASE_UNIQUE_NAME} -o ${NEW_ORACLE_HOME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to modify ORACLE_HOME in cluster registry: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Modify ORACLE_HOME for ${DATABASE_UNIQUE_NAME} in cluster registry failed  with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Modify ORACLE_HOME for ${DATABASE_UNIQUE_NAME} in cluster registry succeeded"
    fi
  fi

  # Start database on single node
  last_result=$(call_sql_plus_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "startup open;" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to start Primary database on single node via SQL*Plus: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to start Primary database on single node via SQL*Plus failed with code=$last_error_code and error text=$last_result"
      exit 2
    else
      cecho g "     OK: Call to start Primary database on single node via SQL*Plus succeeded"      
    fi
  fi

  # Try to open all PDB's
  last_result=$(call_sql_plus_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "alter pluggable database all open;" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to start all PDB's: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to start all PDB's failed with code=$last_error_code and error text=$last_result"
      exit 2
    else
      cecho g "     OK: Call to start all PDB's succeeded"      
    fi
  fi

  # Run Datapatch
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run datapatch command: (ssh -o 'StrictHostKeyChecking no' $node_selected \"export ORACLE_HOME=$NEW_ORACLE_HOME;export ORACLE_SID=$sid_selected; cd $NEW_ORACLE_HOME/OPatch;  ./datapatch -verbose\")"
    fi
  else
    last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$NEW_ORACLE_HOME;export ORACLE_SID=$sid_selected; cd $NEW_ORACLE_HOME/OPatch;  ./datapatch -verbose")
    last_error_code=$?
    if [ $last_error_code -ne 0 ]
    then
      # failed first time
      cecho y "WARNING: Datapatch failed with code=$last_error_code and error text=$last_result - will retry"
      # Wait a litle
      sleep 2
      last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$NEW_ORACLE_HOME;export ORACLE_SID=$sid_selected; cd $NEW_ORACLE_HOME/OPatch;  ./datapatch -verbose")
      last_error_code=$?
      if [ $last_error_code -ne 0 ]
      then
        # failed Second time - abort
        cecho r "  ERROR: Datapatch failed with code=$last_error_code and error text=$last_result"
        exit 2
      else
        cecho g "     OK: Datapatch succeeded"
      fi
    else
      cecho g "     OK: Datapatch succeeded"      
    fi
  fi
  # Run datapatch
  
  # Recompile invalid objects
  last_result=$(call_sql_plus_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "@$NEW_ORACLE_HOME/rdbms/admin/utlrp.sql;" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to recompile all invalid objects: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to recompile all invalid objects failed with code=$last_error_code and error text=$last_result"
      exit 2
    else
      cecho g "     OK: Call to recompile all invalid objects succeeded"      
    fi
  fi
  
  # Now stop primary database
  # TBD sometimes seen that this hangs. Maybe add some steps to detect that and 
  # do a forcefull shutdown
  last_result=$(call_srvctl "$NEW_ORACLE_HOME" "stop database -db ${DATABASE_UNIQUE_NAME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to stop database: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Stopping database ${DATABASE_UNIQUE_NAME} failed with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Stopping database ${DATABASE_UNIQUE_NAME} succeeded"
    fi
  fi

  # Now start primary database
  last_result=$(call_srvctl "$NEW_ORACLE_HOME" "start database -db ${DATABASE_UNIQUE_NAME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to start database: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Starting database ${DATABASE_UNIQUE_NAME} failed with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Starting database ${DATABASE_UNIQUE_NAME} succeeded"
    fi
  fi

  # Only do this if Dataguard setup
  if [ "$STANDBYS_ACTIVE" = "yes" ]
  then
    # On specific node run dgmgrl script to turn apply ON
    LOG_TRANSPORT_ON_DGMGRL="edit database ${DATABASE_UNIQUE_NAME} set state='ONLINE';"
    last_result=$(call_dgmgrl_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "$LOG_TRANSPORT_ON_DGMGRL" "-silent" "$DRY_RUN" )
    last_error_code=$?
    if [ "$DRY_RUN" = "YES" ]
    then
      if [ "$VERBOSE" = "YES" ]
      then
        echo "   INFO: Would run command to turn transport on: $last_result"
      fi
    else
      if [ $last_error_code -ne 0 ]
      then
        # failed - exit immediately as we need to be able to do this
        cecho r "  ERROR: Turn transport on for $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
        exit 2    
      else  
        cecho g "     OK: Turn transport on for $DATABASE_UNIQUE_NAME succeeded"
      fi
    fi 
  fi

  # Register in tables in cdb the new Oracle Home
  UPDATE_PATCH_HELPER_SQL="set serveroutput on
  WHENEVER SQLERROR CONTINUE
  --drop table c##nordeasystem.PATCH_HELPER;
  CREATE TABLE c##nordeasystem.PATCH_HELPER 
  (
    KEY VARCHAR2(64) NOT NULL 
  , VALUE VARCHAR2(2000) NOT NULL 
  );
  delete from c##nordeasystem.PATCH_HELPER
  where KEY = 'PRIMARY_DB_ORACLE_HOME';
  insert into  c##nordeasystem.PATCH_HELPER 
  (
    KEY, 
    VALUE 
  )
  VALUES(
  'PRIMARY_DB_ORACLE_HOME',
  '$NEW_ORACLE_HOME'
  );
  COMMIT;
"      
  last_result=$(call_sql_plus_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "$UPDATE_PATCH_HELPER_SQL" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command Register in tables in cdb the new Oracle Home: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to Register in tables in cdb the new Oracle Home failed with code=$last_error_code and error text=$last_result"
      exit 2
    else
      cecho g "     OK: Call Register in tables in cdb the new Oracle Home succeeded"      
    fi
  fi

  # Now we are done do some after checks
  
  # Check that all components are valid
  last_result=$(call_sql_plus_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "$INVALID_COMPONENTS_SQL" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run to get Standby database component status: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to get Standby database component status failed with code=$last_error_code and error text=$last_result"
      (( errors_found++ ))    
    else
      # success
      local INVALID_COMPONENTS=$(echo ${last_result})
      if [ "$INVALID_COMPONENTS" != "" ]
      then
        cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having invalid components $last_result"
        (( errors_found++ ))
      else
        cecho g "     OK: $DATABASE_UNIQUE_NAME is having valid components"      
      fi      
    fi  
  fi

  # Check that all sys objects are valid
  last_result=$(call_sql_plus_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "$INVALID_SYS_OBJECTS_SQL" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run to get if all SYS objetcs are valid: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to get if all SYS objetcs are valid failed with code=$last_error_code and error text=$last_result"
      (( errors_found++ ))    
    else
      # success
      local INVALID_COMPONENTS=$(echo ${last_result})
      if [ "$INVALID_COMPONENTS" != "" ]
      then
        cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having invalid SYS objects $last_result"
        (( errors_found++ ))
      else
        cecho g "     OK: $DATABASE_UNIQUE_NAME is having valid SYS objetcs"      
      fi      
    fi  
  fi

  # Check that there is no pdb plugin violations
  last_result=$(call_sql_plus_as_sys "$node_selected" "$NEW_ORACLE_HOME" "$sid_selected" "$PDB_PLUG_IN_VIOLATIONS_SQL" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run to get if PDB'a have violations: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to get Primary database PDB violations failed with code=$last_error_code and error text=$last_result"
      (( errors_found++ ))    
    else
      # success
      local PDB_PLUG_IN_VIOLATIONS=$(echo ${last_result})
      if [ "$PDB_PLUG_IN_VIOLATIONS" != "" ]
      then
        cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having PDB plugin violations $last_result"
        (( errors_found++ ))
      else
        cecho g "     OK: $DATABASE_UNIQUE_NAME is having no PDB plugin violations"      
      fi     
    fi
  fi
  
  # Only do this if Dataguard setup
  if [ "$STANDBYS_ACTIVE" = "yes" ]
  then  # Update static listener data
    if [ "$DRY_RUN" != "YES" ]
    then
      # Now maybe check that the version of the ORACLE_HOME is the same as the one nstalled on primary
      # TBD - does it make sense, maybe other checks also
      # Check if DONT_RELOAD_LISTENER is YES
      if [ "$DONT_RELOAD_LISTENER" = "YES" ]
      then
        #Run ndtnsctl to fix listener.ora 
        echo "   INFO: Will update static data in listener.ora and NOT restart listener"  
        ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME} --dontReloadListener
        # Can we check if it failed?
      else
        #Run ndtnsctl to fix listener.ora 
        echo "   INFO: Will update static data in listener.ora and restart listener"  
        ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME}
        # Can we check if it failed?
      fi
    else
      if [ "$DONT_RELOAD_LISTENER" = "YES" ]
      then
        if [ "$VERBOSE" = "YES" ]
        then
          echo "   INFO: Would update static data in listener.ora and restart listener with command: ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME} --dontReloadListener"
        fi
      else
        if [ "$VERBOSE" = "YES" ]
        then
          echo "   INFO: Would update static data in listener.ora and restart listener with command: ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME}"
        fi
      fi
    fi
  fi
  
  # Now we have checked as much as we can
  # If any errors found, then exit with error (not during --dryRun)
  if [ "$DRY_RUN" != "YES" ]
  then
    if [ $errors_found -ne 0  ]
    then
      cecho r "  ERROR: $errors_found errors found in postcheck - will exit with error"
      exit 3
    else
      cecho g "     OK: No errors found in postcheck"    
    fi
  fi
}

run_dg_property_tasks()
{
  local node_selected="$1"
  local ORACLE_HOME="$2"
  local sid_selected="$3"
  local DATABASE_UNIQUE_NAME="$4"
  local AUTO_FIX_DATAGUARD_SPECIFIED="$5"
  # Test that we don't have issues with Inconsistent Properties on primary
  #DGMGRL_PRIMARY_INCONSISTENT_PROPERTIES_COMMANDS="connect sys/${SYS_PASSWORD}
  #show database ${PRIMARY_DB_NAME_ON_STANDBY} InconsistentProperties;
  #exit"
  local -A dg_properties_dgmgrl dg_properties_err_text
  local properties_fix_dgmgrl
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "  show database ${DATABASE_UNIQUE_NAME} InconsistentProperties" "-silent")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to dgmgrl to show database incosistent properties for $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
    exit 1
  else
    # OK We have some data, or nothing loop arround it and checke
    #local INCONSISTENT_PROPERTIES=$(echo ${last_result})
    local filtered_result="$( echo "$last_result" | sed -e"/[[:space:]]*INCONSISTENT PROPERTIES.*/d" -e "/[[:space:]]*INSTANCE_NAME[[:space:]]*PROPERTY_NAME.*/d" -e "/^DGMGRL>.*/d" -e "/Connected to.*/d")"
    if [ "$filtered_result" = "" ]
    then
      cecho g "     OK: Data Guard Broker Properties consistent on $DATABASE_UNIQUE_NAME "
    else
      while read -r read_instance_name read_property_name read_memory_value read_spfile_value read_broker_value
      do
        dg_properties_err_text[$read_property_name]="REM Property ${read_property_name} is inconsistent between broker and init parameter
REM Memory value=${read_memory_value},Spfile value=${read_spfile_value}, Broker value=${read_broker_value}
REM Suggested fix to be run in dgmgrl is shown below
EDIT DATABASE '${DATABASE_UNIQUE_NAME}' SET PROPERTY '${read_property_name}'=${read_spfile_value};"
        dg_properties_dgmgrl[$read_property_name]="EDIT DATABASE '${DATABASE_UNIQUE_NAME}' SET PROPERTY '${read_property_name}'=${read_spfile_value};"
      done <<< "$filtered_result"
      # Now build fix_string
      for each_property_err_text in "${dg_properties_err_text[@]}"
      do
        each_property_err_text="${each_property_err_text}
${each_property_dgmgrl}"
      done
      # Now check if we should autofix
      if [ "$AUTO_FIX_DATAGUARD_SPECIFIED" = "Y" ]
      then
        # Try Fix
        echo "   INFO: Will try to fix properties in Data Guard by executing:"
        echo "$each_property_err_text"
        for each_property_dgmgrl in "${dg_properties_dgmgrl[@]}"
        do
          last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "${each_property_dgmgrl}" "")
          last_error_code=$?
          if [ $last_error_code -ne 0 ]
          then
            # failed
            cecho r "  ERROR: Call to dgmgrl to fix data Guard property value on $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
            (( errors_found++ ))  
          else  
            cecho g "     OK: Call to fix data Guard property value on $DATABASE_UNIQUE_NAME succeeded"
          fi
        done
        echo "   INFO: We have done changes to Data Guard broker configuration.As status is delayed you might"
        echo "         still get that Data Guard have \"serious issues\". Wait a minute an run the command again."
      else
        # Give eror
        cecho r "  ERROR: Problems with Data Guard Properties"
        cecho r "$each_property_err_text"
        exit 1
      fi
    fi
  fi
}



switchover_database()
{
  local DATABASE_UNIQUE_NAME=$(convert_to_lower $1)
  local SYS_PASSWORD="$2"
  local IGNORE_TESTS="$3"
  local MAX_TRANSPORT_LAG="$4"
  local MAX_APPLY_LAG="$5"
  local AUTO_FIX="$6"
  local DRY_RUN="$7"
  local LOG_DIRECTORY="${SWITCHOVER_CLUSTERED_LOG_LOCATION}/$DATABASE_UNIQUE_NAME"
  if [ "$DRY_RUN" = "YES" ]
  then
    local LOG_FILE="${LOG_DIRECTORY}/dry_run_switchover_database_${DATABASE_UNIQUE_NAME}_${now}.log"
  else
    local LOG_FILE="${LOG_DIRECTORY}/switchover_database_${DATABASE_UNIQUE_NAME}_${now}.log"
  fi
  # Let's create log directory
  mkdir -p ${LOG_DIRECTORY}
  # Let's log every normal screen output to log file also
  exec   > >(tee -ia $LOG_FILE)
  exec  2> >(tee -ia $LOG_FILE >& 2)
  echo "   INFO: Switchover to ${DATABASE_UNIQUE_NAME} analysis started ($(date +"%F_%T"))"
  for ENTRY in ${AUTO_FIX//,/ }
  do
    #echo "ENTRY:$ENTRY"
    case $ENTRY in
      [Dd][Aa][Tt][Aa][Gg][Uu][Aa][Rr][Dd])
        local AUTO_FIX_DATAGUARD_SPECIFIED="Y"
        ;;
      [Ss][Pp][Ff][Ii][Ll][Ee])
        local AUTO_FIX_SPFILE_SPECIFIED="Y"
        ;;
      [Tt][Ee][Mm][Pp][Ff][Ii][Ll][Ee][Ss])
        local AUTO_FIX_TEMPFILES_SPECIFIED="Y"
        ;;
      [Ss][Ee][Rr][Vv][Ii][Cc][Ee][Ss])
        local AUTO_FIX_SERVICES_SPECIFIED="Y"
        ;;
      *)    cecho r "  ERROR: --autoFix parameter $INPUT_AUTO_FIX not known. Should be one or more of spfile,tempfiles,services";exit 1;;
    esac  
  done
  if [ "$MAX_TRANSPORT_LAG" = "" ]
  then
    MAX_TRANSPORT_LAG=10
  fi
  if [ "$MAX_APPLY_LAG" = "" ]
  then
    MAX_APPLY_LAG=30
  fi
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "SYS_PASSWORD=$SYS_PASSWORD"
  #echo "IGNORE_TESTS=$IGNORE_TESTS"
  #echo "MAX_TRANSPORT_LAG=$MAX_TRANSPORT_LAG"
  #echo "MAX_APPLY_LAG=$MAX_APPLY_LAG"
  #echo "AUTO_FIX=$AUTO_FIX"
  #echo "DRY_RUN=$DRY_RUN"
  # The switch over command to use
  DGMGRL_SWITCHOVER_COMMANDS="connect sys/${SYS_PASSWORD}
  switchover to ${DATABASE_UNIQUE_NAME};
  exit"
  # First we want to find serious issues and bang out if they occur
  # Find database Oracle_home
  local ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${DATABASE_UNIQUE_NAME}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  # First find a node where it's configured
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get node where there is a instanse of ${DATABASE_UNIQUE_NAME} running"
    exit 1
  fi
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
  if [ "$sid_selected" = "" ]
  then
    cecho r "  ERROR: Can't get a running instanse of ${DATABASE_UNIQUE_NAME}"
    exit 1
  fi
  # Now start more logical checks that can be done while the above was successfull
  local errors_found=0
  local last_result=""
  local last_error_code=0

  # Test that Oracle Home is not one of the ones that we know give us problems
  case $ORACLE_HOME in
  /u01/app/oracle/product/12.2.0.1/db180717a*)
    cecho p "WARNING: The database is running out of $ORACLE_HOME which has issues with this tool. Please upgrade to newer version"
    ;;     
  /u01/app/oracle/product/12.2.0.1/db180717b*)
    cecho p "WARNING: The database is running out of $ORACLE_HOME which has issues with this tool. Please upgrade to newer version"
    ;;     
  /u01/app/oracle/product/12.2.0.1/db180717c*)
    cecho p "WARNING: The database is running out of $ORACLE_HOME which has issues with this tool. Please upgrade to newer version"
    ;;     
  /u01/app/oracle/product/12.2.0.1/db180717d*)
    cecho p "WARNING: The database is running out of $ORACLE_HOME which has issues with this tool. Please upgrade to newer version"
    ;;     
  /u01/app/oracle/product/12.2.0.1/db180717e*)
    cecho p "WARNING: The database is running out of $ORACLE_HOME which has issues with this tool. Please upgrade to newer version"
    ;;     
  *)
    cecho g "     OK: The database is running out of $ORACLE_HOME which works with this tool"
    ;;     
  esac
  
  # Test that sys password is correct
  last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"exit;\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$DATABASE_UNIQUE_NAME as sysdba")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Check SYS password failed. Failed with code=$last_error_code and error text=$last_result"
    exit 1
  fi    

  # Check that this is a standby database 
  # We should have done that efore comming here will only give error if needed
  # Try to get primary database name, if that is empty we are not running as standby
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_STANDBY_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get Primary database name failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    # Filter out new lines using echo
    local PRIMARY_DB_NAME_ON_STANDBY=$(echo ${last_result})
    if [ "$PRIMARY_DB_NAME_ON_STANDBY" = "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is not running as a standby database"
      exit 1
    #else
    #  cecho g "     OK: $DATABASE_UNIQUE_NAME is running as a standby database"      
    fi     
  fi  

  # Test that we can reach primary
  last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"exit;\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Can't login to primary database TNS=$PRIMARY_DB_NAME_ON_STANDBY. Failed with code=$last_error_code and error text=$last_result"
    exit 1
  else
    cecho g "     OK: Primary database $PRIMARY_DB_NAME_ON_STANDBY can be connected to"    
  fi      

 
  run_dg_property_tasks "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_STANDBY" "$AUTO_FIX_DATAGUARD_SPECIFIED"  
  run_dg_property_tasks "$node_selected" "$ORACLE_HOME" "$sid_selected" "$DATABASE_UNIQUE_NAME" "$AUTO_FIX_DATAGUARD_SPECIFIED"  
#  # Test that we don't have issues with Inconsistent Properties on primary
#  #DGMGRL_PRIMARY_INCONSISTENT_PROPERTIES_COMMANDS="connect sys/${SYS_PASSWORD}
#  #show database ${PRIMARY_DB_NAME_ON_STANDBY} InconsistentProperties;
#  #exit"
#  local -A dg_properties_dgmgrl dg_properties_err_text
#  local properties_fix_dgmgrl
#  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "  show database ${PRIMARY_DB_NAME_ON_STANDBY} InconsistentProperties" "-silent")
#  last_error_code=$?
#  if [ $last_error_code -ne 0 ]
#  then
#    # failed
#    cecho r "  ERROR: Call to dgmgrl to show primary database incosistent properties failed with code=$last_error_code and error text=$last_result"
#    exit 1
#  else
#    # OK We have some data, or nothing loop arround it and checke
#    #local INCONSISTENT_PROPERTIES=$(echo ${last_result})
#    local filtered_result="$( echo "$last_result" | sed -e"/[[:space:]]*INCONSISTENT PROPERTIES.*/d" -e "/[[:space:]]*INSTANCE_NAME[[:space:]]*PROPERTY_NAME.*/d" -e "/^DGMGRL>.*/d" -e "/Connected to.*/d")"
#    if [ "$filtered_result" = "" ]
#    then
#      cecho g "     OK: Data Guard Broker Properties consistent on primary db"
#    else
#      while read -r read_instance_name read_property_name read_memory_value read_spfile_value read_broker_value
#      do
#        dg_properties_err_text[$read_property_name]="REM Property ${read_property_name} is inconsistent between broker and init parameter
#REM Memory value=${read_memory_value},Spfile value=${read_spfile_value}, Broker value=${read_broker_value}
#REM Suggested fix to be run in dgmgrl is shown below
#EDIT DATABASE '${PRIMARY_DB_NAME_ON_STANDBY}' SET PROPERTY '${read_property_name}'=${read_spfile_value};"
#        dg_properties_dgmgrl[$read_property_name]="EDIT DATABASE '${PRIMARY_DB_NAME_ON_STANDBY}' SET PROPERTY '${read_property_name}'=${read_spfile_value};"
#      done <<< "$filtered_result"
#      # Now build fix_string
#      for each_property_err_text in "${dg_properties_err_text[@]}"
#      do
#        each_property_err_text="${each_property_err_text}
#${each_property_dgmgrl}"
#      done
#      # Now check if we should autofix
#      if [ "$AUTO_FIX_DATAGUARD_SPECIFIED" = "Y" ]
#      then
#        # Try Fix
#        echo "   INFO: Will try to fix properties in Data Guard by executing:"
#        echo "$each_property_err_text"
#        for each_property_dgmgrl in "${dg_properties_dgmgrl[@]}"
#        do
#          last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "${each_property_dgmgrl}" "")
#          last_error_code=$?
#          if [ $last_error_code -ne 0 ]
#          then
#            # failed
#            cecho r "  ERROR: Call to dgmgrl to fix data Guard property value on primary failed with code=$last_error_code and error text=$last_result"
#            (( errors_found++ ))  
#          else  
#            cecho g "     OK: Call to fix data Guard property value on primary succeeded"
#          fi
#        done
#        echo "   INFO: We have done changes to Data Guard broker configuration.As status is delayed you might"
#        echo "         still get that Data Guard have \"serious issues\". Wait a minute an run the command again."
#      else
#        # Give eror
#        cecho r "  ERROR: Problems with Data Guard Properties"
#        cecho r "$each_property_err_text"
#        exit 1
#      fi
#    fi
#  fi
  #local 
  #echo -e "connect /\nshow database h9001s1h InconsistentProperties\n" | dgmgrl -silent | sed -e"/[[:space:]]*INCONSISTENT PROPERTIES.*/d" -e "/[[:space:]]*INSTANCE_NAME[[:space:]]*PROPERTY_NAME.*/d" -e "/^DGMGRL>.*/d" -e "/Connected to.*/d"
  
  # Test that data guard broker is working - not realy sure how to do that but tis is a start!!!
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show configuration" "-silent")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to dgmgrl to show configuration failed with code=$last_error_code and error text=$last_result"
    exit 1
  else  
    # See if we have ora- errors
    local DG_ERRORS_FOUND=$( echo "$last_result" | grep  -i "ORA-")
    last_error_code=$?
    if [ "$DG_ERRORS_FOUND" != "" ]
    then
      # OK we have serious issues
      cecho r "  ERROR: Data Guard have serious issues, manual intervention required. Errors found=$DG_ERRORS_FOUND"
      exit 1
    else
      cecho g "     OK: Data Guard seems to be working overall"      
    fi
  fi
  
  # Now we tink we can continue the more regular preparations
  # Test that services collect on primary is not to old (25 hours max)
  HOURS_SINCE_SERVICE_COLLECTION_SQL="set heading off
set feedback off
WHENEVER SQLERROR EXIT SQL.SQLCODE
SET LINESIZE 32767
SELECT
    round((sysdate - MIN(collection_date)) * 1440/60)
FROM
    c##nordeasystem.snapshot_srvctl_config_service
WHERE
    db_unique_name = '$PRIMARY_DB_NAME_ON_STANDBY';
"
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$HOURS_SINCE_SERVICE_COLLECTION_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get hours since last colection of services on primary failed with code=$last_error_code and error text=$last_result"
    cecho r "         Probably nddbctl snapshot service command has not been run as the CDB can be very new."
    cecho r "         Please run the following on primary node"
    cecho r "         nddbctl snapshot services --databaseUniqueName $PRIMARY_DB_NAME_ON_STANDBY"
    exit 1    
  else
    # success
    local HOURS_SINCE_SERVICE_COLLECTION=$(echo ${last_result})
    if [ "$HOURS_SINCE_SERVICE_COLLECTION" = "" ]
    then
      # No collection done at all
      cecho r "  ERROR: No service information have been collected on primary. Try to run this on a node on primary cluster."
      cecho r "         nddbctl snapshot services --databaseUniqueName $PRIMARY_DB_NAME_ON_STANDBY"
      exit 1
    fi
    if [ $HOURS_SINCE_SERVICE_COLLECTION -gt 24 ]
    then
      # No collection done at all
      cecho r "  ERROR: Service information on primary older than 25 hours. Try to run this on a node on primary cluster."
      cecho r "         nddbctl snapshot services --databaseUniqueName $PRIMARY_DB_NAME_ON_STANDBY"
      exit 1
    else
      cecho g "     OK: service information on Primary collected $HOURS_SINCE_SERVICE_COLLECTION hours ago"
    fi
  fi

  
  # check parameters - we do it now as it might take some time to flow to standby
  CREATE_SNAPSHOT_SP_PARAMETER_SQL="set serveroutput on
WHENEVER SQLERROR CONTINUE
--ALTER session set parallel_force_local=true
drop table c##nordeasystem.snapshot_v\\\$spparameter PURGE;
WHENEVER SQLERROR EXIT SQL.SQLCODE
create table c##nordeasystem.snapshot_v\\\$spparameter as select * from v\\\$spparameter;
"
  # Create snapshot of srvctl config services  on standby and upload to primary
  snapshot_services "$DATABASE_UNIQUE_NAME" "$ORACLE_HOME" "$SYS_PASSWORD" "$PRIMARY_DB_NAME_ON_STANDBY"
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Problem creating snapshot of srvctl config services on standby. Failed with code=$last_error_code and error text=$last_result"
    exit 1
  else
    cecho g "     OK: snapshot of srvctl config services on standby done"    
  fi  

  # Create snapshot of spfile we can read from standby
  last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${CREATE_SNAPSHOT_SP_PARAMETER_SQL}\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Problem creating snapshot of v\$spfile on primary. Failed with code=$last_error_code and error text=$last_result"
    exit 1
  else
    cecho g "     OK: snapshot of v\$spfile created on primary"    
  fi  

  # TEMP TABLESPACES files etc snapshots - we do it now as it might take some time to flow to standby
  CREATE_SNAPSHOT_CDB_TEMP_FILES_SQL="set serveroutput on
WHENEVER SQLERROR CONTINUE
--ALTER session set parallel_force_local=true
drop table c##nordeasystem.snapshot_cdb_temp_files PURGE;
WHENEVER SQLERROR EXIT SQL.SQLCODE
create table c##nordeasystem.snapshot_cdb_temp_files as select * from cdb_temp_files;
"
  # Create snapshot of cdb_temp_files we can read from standby
  last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${CREATE_SNAPSHOT_CDB_TEMP_FILES_SQL}\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Problem creating snapshot of cdb_temp_files on primary. Failed with code=$last_error_code and error text=$last_result"
    exit 1
  else
    cecho g "     OK: snapshot of cdb_temp_files created on primary"    
  fi  

  # TABLESPACES files etc snapshots - we do it now as it might take some time to flow to standby
  CREATE_SNAPSHOT_CDB_TABLESPACES_SQL="set serveroutput on
WHENEVER SQLERROR CONTINUE
--ALTER session set parallel_force_local=true
drop table c##nordeasystem.snapshot_cdb_tablespaces PURGE;
WHENEVER SQLERROR EXIT SQL.SQLCODE
create table c##nordeasystem.snapshot_cdb_tablespaces as select * from cdb_tablespaces;
"
  # Create snapshot of cdb_tablespaces we can read from standby
  last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${CREATE_SNAPSHOT_CDB_TABLESPACES_SQL}\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Problem creating snapshot of cdb_tablespaces on primary. Failed with code=$last_error_code and error text=$last_result"
    exit 1
  else
    cecho g "     OK: snapshot of cdb_tablespaces created on primary"    
  fi    
  
  # Services  snapshots - we do it now as it might take some time to flow to standby
  CREATE_SNAPSHOT_GV_SERVICES_SQL="set serveroutput on
WHENEVER SQLERROR CONTINUE
--ALTER session set parallel_force_local=true
drop table c##nordeasystem.snapshot_gv\\\$services PURGE;
WHENEVER SQLERROR EXIT SQL.SQLCODE
create table c##nordeasystem.snapshot_gv\\\$services as select * from gv\\\$services;
"
  # Create snapshot of cdpb_tablespaces we can read from standby
  last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${CREATE_SNAPSHOT_GV_SERVICES_SQL}\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    cecho r "  ERROR: Problem creating snapshot of gv\$services on primary. Failed with code=$last_error_code and error text=$last_result"
    exit 1
  else
    cecho g "     OK: snapshot of gv\$services created on primary"    
  fi    

  
  # Test that our parameters on primary and standby are "alike"
  # Check Transport lag is less than 10 seconds
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show database $DATABASE_UNIQUE_NAME" "-silent")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to dgmgrl to show database failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else  
    local TRANSPORT_LAG=$( echo "$last_result" | sed -n "s/[[:space:]]*Transport Lag:[[:space:]]*\\([0-9]*\\).*\$/\\1/p")
    if [ "$TRANSPORT_LAG" = "" ]
    then
      # We have no value for transport lag
      cecho r "  ERROR: Transport lag can not be determined."
      exit 1   
    else  
      # We got some value
      local timelag_seconds=$(convert_dgmgrl_time_to_seconds "$TRANSPORT_LAG")
      WAIT_TIME_LAG=$timelag_seconds
      if [ $timelag_seconds -gt $MAX_TRANSPORT_LAG ]
      then
        # We have lags on transport
        cecho r "  ERROR: Transport lag for $DATABASE_UNIQUE_NAME is to big ($timelag_seconds seconds) should be less than $MAX_TRANSPORT_LAG"
        (( errors_found++ ))    
      else
        cecho g "     OK: Transport lag ($timelag_seconds seconds) for $DATABASE_UNIQUE_NAME is below $MAX_TRANSPORT_LAG"
      fi
    fi
  fi
  
  # Check we are applying logs 
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show database $DATABASE_UNIQUE_NAME" "-silent")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to dgmgrl to show database failed with code=$last_error_code and error text=$last_result"
    exit 1   
  else
    local APPLY_MODE=$( echo "$last_result" | sed -n "s/[[:space:]]*Intended State:[[:space:]]*\\(.*\\)\$/\\1/p")
    last_error_code=$?
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to sed to extract apply mode failed with code=$last_error_code and error text=$last_result"
      exit 1    
    else  
      case $APPLY_MODE in
        APPLY-ON)
          cecho g "     OK: Apply mode of standby database $DATABASE_UNIQUE_NAME is $APPLY_MODE";;
        APPLY-OFF)          
          cecho r "  ERROR: Apply mode of standby database $DATABASE_UNIQUE_NAME is $APPLY_MODE, should be APPLY-ON."
          exit 1;;
        *)
          cecho r "  ERROR: Apply mode of standby database $DATABASE_UNIQUE_NAME is ""$APPLY_MODE"", which is not understood."
          exit 1;;
      esac
    fi
  fi

  
  # Check we don't have huge apply lag 
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show database $DATABASE_UNIQUE_NAME" "-silent")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to dgmgrl to show database failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    #  Apply Lag:          38 days 10 minutes 54 seconds (computed 0 seconds ago)
    #  Apply Lag:          1 day(s) 14 hours 55 minutes 13 seconds
    #  Apply Lag:          0 seconds (computed 9 seconds ago)
    local APPLY_LAG=$( echo "$last_result" | sed -n "s/[[:space:]]*Apply Lag:[[:space:]]*\\(.*\\)(computed.*\$/\\1/p")
    last_error_code=$?
    if [ "$APPLY_LAG" = "" ]
    then
      # We have no value for apply lag
      cecho r "  ERROR: Apply lag can not be determined."
      exit 1   
    else      
      local timelag_seconds=$(convert_dgmgrl_time_to_seconds "$APPLY_LAG")
      WAIT_APPLY_LAG=$timelag_seconds 
      if [ $timelag_seconds -lt $MAX_APPLY_LAG ]
      then
        cecho g "     OK: Apply lag of standby database $DATABASE_UNIQUE_NAME is $timelag_seconds seconds (should be less than $MAX_APPLY_LAG)"
      else
        cecho r "  ERROR: Apply lag of standby database $DATABASE_UNIQUE_NAME is $timelag_seconds seconds (should be less than $MAX_APPLY_LAG)"
        exit 1
      fi
    fi
  fi
  
  if [ $((WAIT_APPLY_LAG+WAIT_TRANSPORT_LAG)) -gt $((MAX_APPLY_LAG+MAX_TRANSPORT_LAG)) ]
  then
    cecho r "  ERROR: Apply lag plus Transport lag "$((WAIT_APPLY_LAG+WAIT_TRANSPORT_LAG))" is more than "$((MAX_APPLY_LAG+MAX_TRANSPORT_LAG))" seconds seconds a lot"
    echo "         of the folllowing operations might fail, as we won't wait for sync between primary and standby"   
  else
    # Wait APPLY LAG + TRANSPORT_LAG
    # Added extra wait as we often saw stuf was not comming over
    #echo "   INFO: Will wait "$((WAIT_APPLY_LAG+WAIT_TRANSPORT_LAG+10))" seconds to allow standby to be in sync - hopefully!"
    #sleep $((WAIT_APPLY_LAG+WAIT_TRANSPORT_LAG+10))
    echo "   INFO: Will wait for sync between standby and primary ( probably around "$((WAIT_APPLY_LAG+WAIT_TRANSPORT_LAG))" seconds )"
    last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "ALTER SESSION SYNC WITH PRIMARY;" "-S" )
    last_error_code=$?
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to get sync with primary failed with code=$last_error_code and error text=$last_result"
      exit 1    
    else
      cecho g "     OK: Call to get sync with primary succeeded - we are in sync"
    fi
  fi
  # Check that primary parameters have issues
  CHECK_PRIMARY_PARAMETER_SQL="set heading off
set feedback off
SET LINESIZE 32767
column error format A32767
--ALTER session set parallel_force_local=true
with agg_spparameter as (
  SELECT name, LISTAGG(value, ',') WITHIN GROUP (ORDER BY value desc) AS value
  FROM c##nordeasystem.snapshot_v\\\$spparameter GROUP BY name)
SELECT
    '  ERROR: '||name||' = '
    || value
    || '  - no upper limit on PGA resources for database - not allowed' error
FROM
    agg_spparameter
WHERE
    value = '0'
    AND name = 'pga_aggregate_limit'
union
SELECT
    '  ERROR: '||name||' = '
    || value
    || '  - No instance caging for database - not allowed' error
FROM
    agg_spparameter
WHERE
    value = '0'
    AND name = 'cpu_count'
union
SELECT
    '  ERROR: '||name||' = '
    || nvl(value,'NULL')
    ||' - No instance caging for database - not allowed' error
FROM
    agg_spparameter
WHERE
    value is null
    AND name = 'resource_manager_plan'    
union
SELECT
    '  ERROR: '||name||' = '
    || nvl(value,'NULL')
    ||' - has to be set to NULL to insist that SGA goes to huge pages - not allowed' error
FROM
    agg_spparameter
WHERE
    value is not null
    AND name = 'memory_max_target'    
union
SELECT
    '  ERROR: '||name||' = '
    || nvl(value,'NULL')
    ||' - has to be set to NULL to insist that SGA goes to huge pages - not allowed' error
FROM
    agg_spparameter
WHERE
    value is not null
    AND name = 'memory_target'   
union
SELECT
    '  ERROR: '||name||' = '
    || nvl(value,'NULL')
    ||' - has to be set to ONLY to insist that SGA goes to huge pages - not allowed' error
FROM
    agg_spparameter
WHERE
    value != 'ONLY'
    AND name = 'use_large_pages'
union
SELECT
    '  ERROR: '||name||' = '
    || nvl(value,'NULL')
    ||' - has to be set to TRUE to enable sys auditing - not allowed' error
FROM
    agg_spparameter
WHERE
    value != 'TRUE'
    AND name = 'audit_sys_operations'
union
SELECT
    '  ERROR: '||name||' = '
    || nvl(value,'NULL')
    ||' - has to be set to XML,EXTENDED or DB,EXTENDED - not allowed' error
FROM
    agg_spparameter
WHERE
    value != 'XML,EXTENDED'
    AND name = 'audit_trail'
union
SELECT
    '  ERROR: '||name||' = '
    || nvl(value,'NULL')
    ||' - has to be set to /u01/app/oracle/admin/<db unique name>/adump - not allowed' error
FROM
    agg_spparameter
WHERE
    value not like '/u01/app/oracle/admin/%/adump'
    AND name = 'audit_file_dest';
"
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$CHECK_PRIMARY_PARAMETER_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to sanity check parameters from primary snapshot failed with code=$last_error_code and error text=$last_result"
    exit 1    
  else
    # success
    local PROBLEM_PARAMETERS=$(echo ${last_result})
    if [ "$PROBLEM_PARAMETERS" != "" ]
    then
      cecho r "  ERROR: Primary database parameters failed to pass sanity checks"
      cecho r "$last_result"
      (( errors_found++ ))
      # Remember, as we wont do autofix then
      local PARAMETER_SANITY_CHECK_PASSED="N"
    else
      cecho g "     OK: Primary database parameters pass sanity checks"      
    fi     
  fi     
  
  # Check for values that are "bigger" on standby than on primary and warn about that
  CHECK_SUSPICIOUS_NUMERIC_PARAMETERS_SQL="set heading off
set feedback off
SET LINESIZE 32767
column error format A32767
--ALTER session set parallel_force_local=true
with suspicious_numeric_parameters as
(SELECT
    s_parm.name name ,s_parm.value standby_value ,p_parm.value primary_value
FROM
    v\\\$spparameter s_parm,c##nordeasystem.snapshot_v\\\$spparameter p_parm
WHERE
    s_parm.type = 'integer'
    and p_parm.sid='*'
    and s_parm.sid='*'
    and s_parm.name = p_parm.name
    and (to_number(s_parm.value) > to_number(p_parm.value)
      or (p_parm.value is NULL and p_parm.value is not null))
)
--select * from suspicious_numeric_parameters
SELECT
    '-----------------------------------------'
    || chr(10)
    ||'-- Parameter '
    || sp.name
    || ' is bigger on standby ('
    || sp.standby_value
    || ') than on primary ('
    || sp.primary_value
    || ').'
    || chr(10)
    || '-----------------------------------------' error_text
from suspicious_numeric_parameters sp;
"  
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$CHECK_SUSPICIOUS_NUMERIC_PARAMETERS_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to check suspicious numeric parameters (parameters bigger on standby than on primary) failed with code=$last_error_code and error text=$last_result"
    exit 1    
  else
    # success
    local SUSPICIOUS_NUMERIC_PARAMETERS=$(echo ${last_result})
    if [ "$SUSPICIOUS_NUMERIC_PARAMETERS" != "" ]
    then
      cecho p "WARNING: There are supsicious parameters (parameters bigger on standby than on primary)"
      cecho p "$last_result"
    else
      cecho g "     OK: All numeric parameters are bigger on primary than on standby"      
    fi     
  fi     

  
  # Ckeck that parameters are alike
  CHECK_PARAMETER_DIFFERENCES_SQL="set heading off
set feedback off
SET LINESIZE 32767
column fix_text format A32767
--ALTER session set parallel_force_local=true
WITH different_parameters AS (
    SELECT
        *
    FROM
        (
            SELECT
                sid,
                name,
                value
            FROM
                v\\\$spparameter
            MINUS
            SELECT
                sid,
                name,
                value
            FROM
                c##nordeasystem.snapshot_v\\\$spparameter
        )
    WHERE
        name NOT IN (
            'audit_file_dest',
            'control_files',
            'db_recovery_file_dest',
            'dispatchers',
            'log_file_name_convert',
            'thread',
            'instance_number',
            'undo_tablespace',
            'log_archive_trace',
            'log_archive_config',
            'remote_listener',
            'db_unique_name'
        )
        AND sid = '*' -- Only common parameters
        AND name NOT LIKE 'db_create%'
        AND name NOT LIKE 'dg_broker_config%'
        AND name NOT LIKE 'fal%'
        AND name NOT LIKE 'log_archive_dest%'
        AND name NOT LIKE 'log_archive_format%'
)
SELECT
    '-----------------------------------------'
    || chr(10)
    ||'-- Parameter '
    || dp.name
    || ' differ '
    || dp.value
    || ' on standby and '
    || primaryparm.value
    || ' on primary. Try run this on standby database to fix (the escaped gnyf should be replaced with a gnyf):'
    || CHR(10)
    || 'alter system set \\\\\\\"'
    || dp.name
    || '\\\\\\\"='
    || CASE primaryparm.type WHEN 'string' THEN '''' ELSE '' END
    || primaryparm.value
    || CASE primaryparm.type WHEN 'string' THEN '''' ELSE '' END
    || ' comment='''
    || primaryparm.update_comment||''''    
    || ' sid ='''
    || dp.sid
    || ''' scope=spfile;'
    || chr(10)
    || '-----------------------------------------' fix_text
FROM
    different_parameters                     dp,
    c##nordeasystem.snapshot_v\\\$spparameter   primaryparm
WHERE
    dp.name = primaryparm.name
    AND dp.sid = primaryparm.sid;
"  
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$CHECK_PARAMETER_DIFFERENCES_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get difference of paramaters on primary and standby failed with code=$last_error_code and error text=$last_result"
    exit 1    
  else
    # success
    local PROBLEM_PARAMETERS=$(echo ${last_result})
    if [ "$PROBLEM_PARAMETERS" != "" ]
    then
      # Now check if we should autofix
      if [ "$AUTO_FIX_SPFILE_SPECIFIED" = "Y" ]
      then
        # Check if we are allowed to run autofix
        if [ "$PARAMETER_SANITY_CHECK_PASSED" = "N" ]
        then
          # Ouch we don't allow that
          # Report Errors
          cecho r "  ERROR: Primary and standby database has different parameter values and"
          cecho r "         auto fix not alowed because serious problems with parameters exists"
          cecho r "$last_result"
          (( errors_found++ ))
        else
          # Yes we can try to Autofix, by executing SQL returned
          echo "   INFO: Will try to fix spfile parameters by executing: $last_result"
          local PARAMETERS_FIX_SQL="WHENEVER SQLERROR EXIT SQL.SQLCODE
$last_result"
          # Execute SQL returned
          last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PARAMETERS_FIX_SQL" "-S" )
          last_error_code=$?
          if [ $last_error_code -ne 0 ]
          then
            # failed
            cecho r "  ERROR: Call to fix parameter values on standby failed with code=$last_error_code and error text=$last_result"
            (( errors_found++ ))   
          else
            cecho g "     OK: Call to fix parameter values on standby succeeded"
          fi
        fi
      else  
        # Report Errors
        cecho r "  ERROR: Primary and standby database has different parameter values"
        cecho r "$last_result"
        (( errors_found++ ))
      fi
    else
      cecho g "     OK: Primary and standby database has equal parameter values"      
    fi     
  fi    

  #TBD Check that temp files are OK
  # Ckeck that parameters are alike
#  CHECK_TEMP_FILES_SQL="set heading off
#set feedback off
#SET LINESIZE 32767
#column fix_text format A32767
#with temp_tablespaces_without_equal_files as (
#select tablespace_name,con_id,count(file_name) number_of_files_missing from c##nordeasystem.snapshot_cdb_temp_files group by tablespace_name,con_id
#minus
#select tablespace_name,con_id,count(file_name) number_of_files_missing from cdb_temp_files group by tablespace_name,con_id 
#)
#select 'Tablespace '||ttwef.tablespace_name||' in PDB '||pdbs.name||' has '||ttwef.number_of_files_missing||' missing datafile(s) in standby' from temp_tablespaces_without_equal_files ttwef, v\\\$pdbs pdbs
#where ttwef.con_id = pdbs.con_id(+);
#"
  CHECK_TEMP_FILES_SQL="set heading off
set feedback off
SET LINESIZE 32767
column fix_text format A32767
--ALTER session set parallel_force_local=true
WITH temp_tablespaces_missing_files AS (
    SELECT DISTINCT
        tablespace_name,
        con_id
    FROM
        c##nordeasystem.snapshot_cdb_temp_files
    MINUS
    SELECT DISTINCT
        tablespace_name,
        con_id
    FROM
        cdb_temp_files
), temp_tablespaces_missing_files_pdb AS (
    SELECT
        ttmf.tablespace_name,
        pdbs.name,
        pdbs.con_id
    FROM
        temp_tablespaces_missing_files   ttmf,
        v\\\$pdbs                           pdbs
    WHERE
        ttmf.con_id = pdbs.con_id (+)
), filenames_missing AS (
    SELECT
        sctf.file_name
    FROM
        temp_tablespaces_missing_files_pdb        ttmfp,
        c##nordeasystem.snapshot_cdb_temp_files   sctf
    WHERE
        ttmfp.con_id = sctf.con_id
        AND ttmfp.tablespace_name = sctf.tablespace_name
), generate_add_file AS (
SELECT
    sctf.file_name,
        nvl2(pdbs.name, '-- Temp file is missing for '
                        || sct.tablespace_name
                        || ' on PDB '
                        || pdbs.name
                        || '. Try to run following on standby database to fix'
                        || CHR(10)
                        ||'-----------------------------------------'
                        || CHR(10)
                        ||'BEGIN'
                        || CHR(10)
                        || '  C##NORDEASYSTEM.TOOLS.PRIVATEEXECUTESQL('
                        || CHR(10)
                        || '    DYNAMIC_SQL => ''ALTER TABLESPACE ""'
                        || sct.tablespace_name
                        || '"" ADD TEMPFILE SIZE '
                        || sctf.bytes
                        ||
            CASE sctf.autoextensible
                WHEN 'YES' THEN
                    ' AUTOEXTEND ON NEXT '
                    || sctf.increment_by * sct.block_size
                ELSE
                    ''
            END
                        || ' MAXSIZE '
                        || sctf.maxbytes
                        || ''','
                        || CHR(10)
                        || '    PDB_NAME => '''
                        || pdbs.name
                        || ''','
                        || CHR(10)
                        || '    DATABASE_ROLE_NEEDED => ''PHYSICAL STANDBY'','
                        || CHR(10)
                        || '    OPEN_MODE_NEEDED => ''READ ONLY'','
                        || CHR(10)
                        || '    IGNORE_ERRORS => FALSE'
                        || CHR(10)
                        || '    );'
                        || CHR(10)
                        || 'END;'
                        || CHR(10)
                        || '/'
                        || CHR(10)
                        ||'-----------------------------------------', '')
        || nvl2(pdbs.name, '', 'ALTER TABLESPACE ""'
                               || sct.tablespace_name
                               || '"" ADD TEMPFILE SIZE '
                               || sctf.bytes
                               ||
            CASE sctf.autoextensible
                WHEN 'YES' THEN
                    ' AUTOEXTEND ON NEXT '
                    || sctf.increment_by * sct.block_size
                ELSE
                    ''
            END
                               || ' MAXSIZE '
                               || sctf.maxbytes
                               || ';') sql_line2
    FROM
        c##nordeasystem.snapshot_cdb_temp_files    sctf,
        c##nordeasystem.snapshot_cdb_tablespaces   sct,
        v\\\$pdbs                                     pdbs
    WHERE
        sctf.tablespace_name = sct.tablespace_name
        AND sctf.con_id = sct.con_id
        AND sctf.con_id = pdbs.con_id (+)
        AND pdbs.name <> 'PDB\\\$SEED'
)
--select * from generate_add_file gaf
--where gaf.file_name in ( select file_name from filenames_missing )
SELECT
    LISTAGG(sql_line2, '') WITHIN GROUP(
        ORDER BY
            sql_line2
    ) AS fix_text
FROM
    generate_add_file gaf
WHERE
    gaf.file_name IN (
        SELECT
            file_name
        FROM
            filenames_missing
    );
"
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$CHECK_TEMP_FILES_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get missing temp datafiles on standby failed with code=$last_error_code and error text=$last_result"
    exit 1    
  else
    # success
    local PROBLEM_TEMPFILES=$(echo ${last_result})
    if [ "$PROBLEM_TEMPFILES" != "" ]
    then
      # Now check if we should autofix
      if [ "$AUTO_FIX_TEMPFILES_SPECIFIED" = "Y" ]
      then
        # Try to fix
        echo "   INFO: Will try to fix temp files by executing: $last_result"
        TEMPFILES_FIX_SQL="WHENEVER SQLERROR EXIT SQL.SQLCODE
$last_result"
        # Execute SQL returned
        #set -x
        last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$TEMPFILES_FIX_SQL" "-S" )
        last_error_code=$?
        if [ $last_error_code -ne 0 ]
        then
          # failed
          cecho r "  ERROR: Call to fix missing temp datafiles on standby failed with code=$last_error_code and error text=$last_result"
          (( errors_found++ ))
        else
          cecho g "     OK: Call to fix missing temp datafiles on standby succeeded"
        fi
        #set +x
      else
        # Report errors
        cecho r "  ERROR: Standby is missing temp files temp files"
        cecho r "$last_result"
        (( errors_found++ ))
      fi
    else
      cecho g "     OK: Standby database has all the temp files of Primary"      
    fi     
  fi   

  # Check tempfiles on primary are OK - silly test, but sometimes we seen some missing
  
  CHECK_PRIMARY_TEMP_FILES_SQL="set heading off
set feedback off
SET LINESIZE 32767
column fix_text format A32767
--ALTER session set parallel_force_local=true
WITH temp_tablespaces_missing_files AS (
    SELECT DISTINCT
        tablespace_name,
        con_id
    FROM
        cdb_temp_files
    MINUS
    SELECT DISTINCT
        tablespace_name,
        con_id
    FROM
        c##nordeasystem.snapshot_cdb_temp_files
), temp_tablespaces_missing_files_pdb AS (
    SELECT
        ttmf.tablespace_name,
        pdbs.name,
        pdbs.con_id
    FROM
        temp_tablespaces_missing_files   ttmf,
        v\\\$pdbs                           pdbs
    WHERE
        ttmf.con_id = pdbs.con_id (+)
), filenames_missing AS (
    SELECT
        sctf.file_name
    FROM
        temp_tablespaces_missing_files_pdb        ttmfp,
        c##nordeasystem.snapshot_cdb_temp_files   sctf
    WHERE
        ttmfp.con_id = sctf.con_id
        AND ttmfp.tablespace_name = sctf.tablespace_name
), generate_add_file AS (
SELECT
    sctf.file_name,
        nvl2(pdbs.name, '-- Temp file is missing for '
                        || sct.tablespace_name
                        || ' on PDB '
                        || pdbs.name
                        || '. Try to run following on primary database to fix'
                        || CHR(10)
                        ||'-----------------------------------------'
                        || CHR(10)
                        ||'BEGIN'
                        || CHR(10)
                        || '  C##NORDEASYSTEM.TOOLS.PRIVATEEXECUTESQL('
                        || CHR(10)
                        || '    DYNAMIC_SQL => ''ALTER TABLESPACE ""'
                        || sct.tablespace_name
                        || '"" ADD TEMPFILE SIZE '
                        || sctf.bytes
                        ||
            CASE sctf.autoextensible
                WHEN 'YES' THEN
                    ' AUTOEXTEND ON NEXT '
                    || sctf.increment_by * sct.block_size
                ELSE
                    ''
            END
                        || ' MAXSIZE '
                        || sctf.maxbytes
                        || ''','
                        || CHR(10)
                        || '    PDB_NAME => '''
                        || pdbs.name
                        || ''','
                        || CHR(10)
                        || '    DATABASE_ROLE_NEEDED => ''PRIMARY'','
                        || CHR(10)
                        || '    OPEN_MODE_NEEDED => ''READ WRITE'','
                        || CHR(10)
                        || '    IGNORE_ERRORS => FALSE'
                        || CHR(10)
                        || '    );'
                        || CHR(10)
                        || 'END;'
                        || CHR(10)
                        || '/'
                        || CHR(10)
                        ||'-----------------------------------------', '')
        || nvl2(pdbs.name, '', 'ALTER TABLESPACE ""'
                               || sct.tablespace_name
                               || '"" ADD TEMPFILE SIZE '
                               || sctf.bytes
                               ||
            CASE sctf.autoextensible
                WHEN 'YES' THEN
                    ' AUTOEXTEND ON NEXT '
                    || sctf.increment_by * sct.block_size
                ELSE
                    ''
            END
                               || ' MAXSIZE '
                               || sctf.maxbytes
                               || ';') sql_line2
    FROM
        c##nordeasystem.snapshot_cdb_temp_files    sctf,
        c##nordeasystem.snapshot_cdb_tablespaces   sct,
        v\\\$pdbs                                     pdbs
    WHERE
        sctf.tablespace_name = sct.tablespace_name
        AND sctf.con_id = sct.con_id
        AND sctf.con_id = pdbs.con_id (+)
)
--select * from generate_add_file gaf
--where gaf.file_name in ( select file_name from filenames_missing )
SELECT
    LISTAGG(sql_line2, '') WITHIN GROUP(
        ORDER BY
            sql_line2
    ) AS fix_text
FROM
    generate_add_file gaf
WHERE
    gaf.file_name IN (
        SELECT
            file_name
        FROM
            filenames_missing
    );
"
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$CHECK_PRIMARY_TEMP_FILES_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get missing temp datafiles on primary failed with code=$last_error_code and error text=$last_result"
    exit 1    
  else
    # success
    local PROBLEM_TEMPFILES=$(echo ${last_result})
    if [ "$PROBLEM_TEMPFILES" != "" ]
    then
      # Now check if we should autofix
      if [ "$AUTO_FIX_TEMPFILES_SPECIFIED" = "Y" ]
      then
        # Try to fix
        echo "   INFO: Will try to fix temp files by executing: $last_result"
        local TEMPFILES_FIX_SQL="WHENEVER SQLERROR EXIT SQL.SQLCODE
$last_result"
        # Execute SQL returned
        # last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$TEMPFILES_FIX_SQL" "-S" )
        # Do thgis on remote database (primary)
        last_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${TEMPFILES_FIX_SQL}\" | $ORACLE_HOME/bin/sqlplus -L -S sys/$SYS_PASSWORD@$PRIMARY_DB_NAME_ON_STANDBY as sysdba")

        last_error_code=$?
        if [ $last_error_code -ne 0 ]
        then
          # failed
          cecho r "  ERROR: Call to fix missing temp datafiles on primary failed with code=$last_error_code and error text=$last_result"
          (( errors_found++ ))
        else
          cecho g "     OK: Call to fix missing temp datafiles on primary succeeded"
        fi
      else
        # Report errors
        cecho r "  ERROR: Primary is missing tempfile files"
        cecho r "$last_result"
        (( errors_found++ ))
      fi
    else
      cecho g "     OK: Primary database has all the temp files of Standby"      
    fi     
  fi   
  
  
  
  
  
  
  #TBD Check that services are OK
  CHECK_SERVICE_ISSUES_SQL="set heading off
set feedback off
SET LINESIZE 32767
column fix_text format A32767
--ALTER session set parallel_force_local=true
-- Used to find difference
WITH services_relevant_columns AS (
    SELECT
        srcs_p.service_name,
        srcs_p.pluggable_database_name,
        srcs_p.db_unique_name   db_unique_name_primary,
        srcs_s.db_unique_name   db_unique_name_standby,
        srcs_p.service_role     service_role_primary,
        srcs_s.service_role     service_role_standby,
        length(srcs_p.preferred_instances) - length(replace(srcs_p.preferred_instances, ',', '')) + 1 count_preferred_primary,
        length(srcs_s.preferred_instances) - length(replace(srcs_s.preferred_instances, ',', '')) + 1 count_preferred_standby,
        length(srcs_p.available_instances) - length(replace(srcs_p.available_instances, ',', '')) + 1 count_available_primary,
        length(srcs_s.available_instances) -
        length(replace(srcs_s.available_instances, ',', '')) + 1 count_available_standby,
        regexp_replace(srcs_p.preferred_instances, '${PRIMARY_DB_NAME_ON_STANDBY}([^,])*', '\1') instances_preferred_primary,
        regexp_replace(srcs_s.preferred_instances, '${DATABASE_UNIQUE_NAME}([^,])*', '\1') instances_preferred_standby,
        regexp_replace(srcs_p.available_instances, '${PRIMARY_DB_NAME_ON_STANDBY}([^,])*', '\1') instances_available_primary,
        regexp_replace(srcs_s.available_instances, '${DATABASE_UNIQUE_NAME}([^,])*', '\1') instances_available_standby,
        srcs_p.service_is       service_is_primary,
        srcs_s.service_is       service_is_standby
    FROM
        c##nordeasystem.snapshot_srvctl_config_service   srcs_p,
        c##nordeasystem.snapshot_srvctl_config_service   srcs_s
    WHERE
        srcs_p.db_unique_name = '${PRIMARY_DB_NAME_ON_STANDBY}'
        AND srcs_s.db_unique_name = '${DATABASE_UNIQUE_NAME}'
        AND srcs_p.service_name = srcs_s.service_name
        AND srcs_p.pluggable_database_name = srcs_s.pluggable_database_name
), services_different AS (
    SELECT
        *
    FROM
        services_relevant_columns
    WHERE
        ( count_preferred_primary != count_preferred_standby )
        OR ( count_available_primary != count_available_standby )
        OR ( service_role_primary != service_role_standby )
        OR ( instances_preferred_primary != instances_preferred_standby )
        OR ( instances_available_primary != instances_available_standby )
        OR ( service_is_primary != service_is_standby )
), services_missing AS (
    SELECT
        service_name,
        pluggable_database_name
    FROM
        c##nordeasystem.snapshot_srvctl_config_service
    WHERE
        db_unique_name = '${PRIMARY_DB_NAME_ON_STANDBY}'
        AND service_name != 'rman_' || '${PRIMARY_DB_NAME_ON_STANDBY}'
    MINUS
    SELECT
        service_name,
        pluggable_database_name
    FROM
        c##nordeasystem.snapshot_srvctl_config_service
    WHERE
        db_unique_name = '${DATABASE_UNIQUE_NAME}'
        AND service_name != 'rman_' || '${DATABASE_UNIQUE_NAME}'
), services_notused AS (
    SELECT
        service_name,
        pluggable_database_name
    FROM
        c##nordeasystem.snapshot_srvctl_config_service
    WHERE
        db_unique_name = '${DATABASE_UNIQUE_NAME}'
        AND service_name != 'rman_' || '${DATABASE_UNIQUE_NAME}'
    MINUS
    SELECT
        service_name,
        pluggable_database_name
    FROM
        c##nordeasystem.snapshot_srvctl_config_service
    WHERE
        db_unique_name = '${PRIMARY_DB_NAME_ON_STANDBY}'
        AND service_name != 'rman_' || '${PRIMARY_DB_NAME_ON_STANDBY}'
)
SELECT
    '#########################################'
    || chr(10)
    ||'# Service '
    || service_name
    || nvl2(pluggable_database_name, ' on PDB ' || pluggable_database_name, ' on CDB')
    || ' is on the standby database'
    || CHR(10)
    || '# but not on the primary database. Try the following to delete it:'
    || CHR(10)
    || 'srvctl stop service -d '
    || sys_context('USERENV', 'DB_UNIQUE_NAME')
    || ' -s '
    || service_name
    || CHR(10)
    || 'srvctl remove service -d '
    || sys_context('USERENV', 'DB_UNIQUE_NAME')
    || ' -s '
    || service_name
    || chr(10)
    || '#########################################'
    fix_text
FROM
    c##nordeasystem.snapshot_srvctl_config_service
WHERE
    ( service_name,
      pluggable_database_name ) IN (
        SELECT
            service_name,
            pluggable_database_name
        FROM
            services_notused
    )
UNION
SELECT
    '#########################################'
    || chr(10)
    ||'# Service '
    || service_name
    || nvl2(pluggable_database_name, ' on PDB ' || pluggable_database_name, ' on CDB')
    || ' is missing on standby database, try the following to create it:'
    || CHR(10)
    || 'srvctl add service -d '
    || sys_context('USERENV', 'DB_UNIQUE_NAME')
    || nvl2(pluggable_database_name, ' -pdb ' || pluggable_database_name, '')
    || ' -s '
    || service_name
    || CASE (select value from v\\\$parameter where name='cluster_database')
       WHEN 'TRUE' THEN
         nvl2(preferred_instances, ' -r '
                                 || regexp_replace(preferred_instances, '[^,]*([^,])', regexp_replace(sys_context('USERENV', 'INSTANCE_NAME'
                                 ), '(.*)' || sys_context('USERENV', 'INSTANCE'), '\1')
                                                                                       || '\1'), '')
         || nvl2(available_instances, ' -a '
                                 || regexp_replace(available_instances, '[^,]*([^,])', regexp_replace(sys_context('USERENV', 'INSTANCE_NAME'
                                 ), '(.*)' || sys_context('USERENV', 'INSTANCE'), '\1')
                                                                                       || '\1'), '')
       END
    || nvl2(service_role, ' -l ' || service_role, '')
    || chr(10)
    || '#########################################'
    fix_text
FROM
    c##nordeasystem.snapshot_srvctl_config_service
WHERE
    ( service_name,
      pluggable_database_name ) IN (
        SELECT
            service_name,
            pluggable_database_name
        FROM
            services_missing
    )
UNION
SELECT
    '#########################################'
    || chr(10)
    ||'# Service '
    || service_name
    || nvl2(pluggable_database_name, ' on PDB ' || pluggable_database_name, ' on CDB ')
    || ' differs on the following:'
    ||
        CASE
            WHEN count_preferred_primary != count_preferred_standby THEN
                CHR(10)
                || '# Number of preferred instances ('
                || db_unique_name_primary
                || '='
                || count_preferred_primary
                || ','
                || db_unique_name_standby
                || '='
                || count_preferred_standby
                || ')'
            ELSE
                ''
        END
    ||
        CASE
            WHEN count_available_primary != count_available_standby THEN
                CHR(10)
                || '# Number of available instances ('
                || db_unique_name_primary
                || '='
                || count_available_primary
                || ','
                || db_unique_name_primary
                || '='
                || count_available_standby
                || ')'
            ELSE
                ''
        END
    ||
        CASE
            WHEN service_role_primary != service_role_standby THEN
                CHR(10)
                || '# Service role ('
                || db_unique_name_primary
                || '='
                || service_role_primary
                || ','
                || db_unique_name_standby
                || '='
                || service_role_standby
                || ')'
            ELSE
                ''
        END
    ||
        CASE
            WHEN instances_preferred_primary != instances_preferred_standby THEN
                CHR(10)
                || '# Instance numbers in preferred instances ('
                || db_unique_name_primary
                || '='
                || instances_preferred_primary
                || ','
                || db_unique_name_standby
                || '='
                || instances_preferred_standby
                || ')'
            ELSE
                ''
        END
    ||
        CASE
            WHEN instances_available_primary != instances_available_standby THEN
                CHR(10)
                || '# Instance numbers in available instances ('
                || db_unique_name_primary
                || '='
                || instances_available_primary
                || ','
                || db_unique_name_standby
                || '='
                || instances_available_standby
                || ')'
            ELSE
                ''
        END
    ||
        CASE
            WHEN service_is_primary != service_is_standby THEN
                CHR(10)
                || '# Service is enabled ('
                || db_unique_name_primary
                || '='
                || service_is_primary
                || ','
                || db_unique_name_standby
                || '='
                || service_is_standby
                || ')'
            ELSE
                ''
        END
    || ' Try running the following on standby to fix it:'
    || CHR(10)
    -- If new state is disabled then disable the service
    ||
        CASE
            WHEN service_is_primary != service_is_standby
                 AND service_is_primary = 'enabled' THEN
                'srvctl enable service -db '
                || db_unique_name_standby
                || ' -service '
                || service_name
                || CHR(10)
        END
    ||
        CASE
            WHEN service_is_primary != service_is_standby
                 AND service_is_primary = 'disabled' THEN
                'srvctl enable service -db '
                || db_unique_name_standby
                || ' -service '
                || service_name
                || CHR(10)
        END
    || 'srvctl modify service -db '
    || db_unique_name_standby
    || ' -service '
    || service_name
    ||
        CASE
            WHEN ( instances_preferred_primary != instances_preferred_standby )
                 OR ( instances_available_primary != instances_available_standby ) THEN
                ' -modifyconfig '
                || nvl2(instances_preferred_primary, ' -preferred '
                                                     || regexp_replace(instances_preferred_primary, '[^,]*([^,])', regexp_replace
                                                     (sys_context('USERENV', 'INSTANCE_NAME'), '(.*)' || sys_context('USERENV', 'INSTANCE'
                                                     ), '\1')
                                                                                                                   || '\1'), '')
                || nvl2(instances_available_primary, ' -available '
                                                     || regexp_replace(instances_available_primary, '[^,]*([^,])', regexp_replace
                                                     (sys_context('USERENV', 'INSTANCE_NAME'), '(.*)' || sys_context('USERENV', 'INSTANCE'
                                                     ), '\1')
                                                                                                                   || '\1'), '')
        END
    ||
        CASE
            WHEN service_role_primary != service_role_standby THEN
                ' -role ' || service_role_primary
        END
    || chr(10)
    || '#########################################'
    fix_text
FROM
    services_different;
"

  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$CHECK_SERVICE_ISSUES_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get srvctl service issues on standby failed with code=$last_error_code and error text=$last_result"
    exit 1    
  else
    # success
    local PROBLEM_SERVICES=$(echo ${last_result})
    if [ "$PROBLEM_SERVICES" != "" ]
    then
      # Now check if we should autofix
      if [ "$AUTO_FIX_SERVICES_SPECIFIED" = "Y" ]
      then
        # Try to fix
        echo "   INFO: Will try to fix services setup on standby by executing: $last_result"
        # Now excute as script line by line, but we need to set envionment for srvctl to run
        while read -r execute_line; do
          #echo "... $execute_line ..."
          last_result=$(export ORACLE_HOME=$ORACLE_HOME;export PATH=$ORACLE_HOME/bin:$PATH;$execute_line)
          last_error_code=$?
          # Now check return code, 2 is something we can libve with (service is not running when try to sop f.x.)
          case $last_error_code in
            0)
              cecho g "     OK: $execute_line"
              ;;
            2)
              cecho p "WARNING: $execute_line"
              cecho p "         Return code=$last_error_code"
              cecho p "         Result=$last_result"
              ;;
            *)
              cecho r "  ERROR: $execute_line"
              cecho r "         Return code=$last_error_code"
              cecho r "         Result=$last_result"
              ;;
          esac
        done <<< "$( echo "$last_result"| sed -e '/#.*$/d' -e '/^[[:space:]]*$/d')"        
      else  
        cecho r "  ERROR: Primary and standby database has services that are not alike"
        cecho r "$last_result"
        (( errors_found++ ))
      fi
    else
      cecho g "     OK: Primary and standby database has roughly same service setup"      
    fi     
  fi   

  # Now we have checked as much as we can
  # If any errors found, then abort
  if [ $errors_found -ne 0 ]
  then
    cecho r "  ERROR: $errors_found errors found in precheck - will exit precheck with error ($(date +"%F_%T"))"
    exit 1
  else
    cecho g "     OK: No errors found in precheck - will continue"    
  fi  
  
  if [ "$DRY_RUN" != "YES" ]
  then
    # On specific node run dgmgrl script
    echo "   INFO: Will switchover to ${DATABASE_UNIQUE_NAME} ($(date +"%F_%T"))"
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${DGMGRL_SWITCHOVER_COMMANDS}\" | $ORACLE_HOME/bin/dgmgrl"
    last_error_code=$?
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: switchover to ${DATABASE_UNIQUE_NAME} failed ($(date +"%F_%T")) with code=$last_error_code"
      exit 2    
    else    
      cecho g "     OK: Switchover to ${DATABASE_UNIQUE_NAME} succeeded ($(date +"%F_%T"))"
    fi
  else
    echo "   INFO: Skiping switchover to ${DATABASE_UNIQUE_NAME} as we are doing a Dry Run"
  fi  
}

show_dataguard_status="set heading off
set feedback off
set pagesize 0
set linesize 132
column db_unique_name format A12
column database_role format A20
column open_mode format A20
column transport_lag format A13
column apply_lag format A13
column apply_finish_time format A16
select 
  db_unique_name,
  database_role,
  open_mode,
  nvl((select value from v\\\$dataguard_stats where name='transport lag'),'UNKNOWN') transport_lag,
  nvl((select value from v\\\$dataguard_stats where name='apply lag'),'UNKNOWN') apply_lag,
  nvl((select value from v\\\$dataguard_stats where name='apply finish time'),'UNKNOWN') apply_finish_time
from v\\\$database;
"
#show_dataguard_status="set heading off
#set feedback off
#set pagesize 0
#set linesize 132
#column db_unique_name format A12
#column database_role format A20
#column open_mode format A20
#column transport_lag format A13
#column apply_lag format A13
#column apply_finish_time format A16
#set line 132
#with raw_data as (
#select 
#  db_unique_name,
#  database_role,
#  open_mode,
#  nvl((select value from v\\\$dataguard_stats where name='transport lag'),'N/A') transport_lag,
#  nvl((select value from v\\\$dataguard_stats where name='apply lag'),'N/A') apply_lag
#  --nvl((select value from v\\\$dataguard_stats where name='apply finish time'),'N/A') apply_finish_time
#from v\\\$database
#)
#select 
#  chr(92)||'033[1;32m'||
#  rpad(db_unique_name,13)||' '||
#  rpad(database_role,21)||' '||
#  rpad(open_mode,21)||' '||
#  rpad(transport_lag,20)||' '||
#  rpad(apply_lag,20)||
#  chr(92)||'033[0m'
# from raw_data
#"
status_standby()
{
  local DATABASE_UNIQUE_NAME_REGEX=$1
  local DATABASE_UNIQUE_NAME=""
  local ALL_DATABASES=""
  local ORACLE_HOME=""
  local node_selected="" 
  local sid_selected="" 
  local GRID_HOME=""
  local databases_found=$(find_databases "$DATABASE_UNIQUE_NAME_REGEX" ) 
  local_sql_result=""
  #echo "DATABASE_UNIQUE_NAME_REGEX=$DATABASE_UNIQUE_NAME_REGEX"
  # Find all databases we should test
  GRID_HOME=$(find_grid_home)
  ALL_DATABASES=$(find_databases "$DATABASE_UNIQUE_NAME_REGEX" )
  if [ "$ALL_DATABASES" != "" ]
  then
    echo "DB_UNIQUE    ROLE                 OPEN_MODE            TRANSPORT_LAG APPLY_LAG     APPLY_FINISH_TIME"
  fi
  for DATABASE_UNIQUE_NAME in $databases_found
  do
    #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
    # Find database Oracle_home
    local ORACLE_HOME=$($GRID_HOME/bin/crsctl status resource ora.${DATABASE_UNIQUE_NAME}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
    # First find a node where it's configured
    node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
    if [ "$node_selected" = "" ]
    then
      #cecho r "$DATABASE_UNIQUE_NAME    ROLE                 OPEN_MODE            TRANSPORT_LAG APPLY_LAG"
      #printf '%-12s %-20s %-20s %-13s %-13s' "$DATABASE_UNIQUE_NAME" "N/A" "NOT RUNNING" "N/A" "N/A"
      cecho r "$(printf '%-12s %-20s %-20s %-13s %-13s %-13s' "$DATABASE_UNIQUE_NAME" "N/A" "NOT RUNNING" "N/A" "N/A" "N/A" )"
    else
      # Then find instance on that node
      sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
      if [ "$node_selected" = "" ]
      then
        cecho r "$(printf '%-12s %-20s %-20s %-13s %-13s' "$DATABASE_UNIQUE_NAME" "N/A" "NOT RUNNING" "N/A" "N/A")"
      else
        # On specific node run sqlplus script to show data guard status
        sql_result=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${show_dataguard_status}\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
        echo -e "$sql_result"        
      fi
    fi
  done   
}

prepatch_standby()
{
  local DATABASE_UNIQUE_NAME=$1
  local NEW_ORACLE_HOME=$2
  local DRY_RUN=$3
  local VERBOSE=$4
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "NEW_ORACLE_HOME=$NEW_ORACLE_HOME"
  #echo "DRY_RUN=$DRY_RUN"
  local LOG_DIRECTORY="${DBPATCH_CLUSTERED_LOG_LOCATION}/$DATABASE_UNIQUE_NAME"
  if [ "$DRY_RUN" = "YES" ]
  then
    local LOG_FILE="${LOG_DIRECTORY}/dry_run_prepatch_standby_${DATABASE_UNIQUE_NAME}_${now}.log"
  else
    local LOG_FILE="${LOG_DIRECTORY}/prepatch_standby_${DATABASE_UNIQUE_NAME}_${now}.log"
  fi
  # Let's create log directory
  mkdir -p ${LOG_DIRECTORY}
  # Let's log evry normal screen output to log file also
  exec   > >(tee -ia $LOG_FILE)
  exec  2> >(tee -ia $LOG_FILE >& 2)
  # We have tested that new home is different then old home and that new home exists
  # Find database Oracle_home
  local ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${DATABASE_UNIQUE_NAME}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  # First find a node where it's configured
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get node where there is a instanse of ${DATABASE_UNIQUE_NAME} running"
    exit 1
  fi
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get a running instanse of ${DATABASE_UNIQUE_NAME}"
    exit 1
  fi
  # Now start more logical checks that can be done while the above was successfull
  local errors_found=0
  local last_result=""
  local last_error_code=0
  
  # Check that this is a standby database
  # Try to get primary database name, if that is empty we are not running as standby
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_NAME_ON_STANDBY_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get Primary database name failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    # Filter out new lines using echo
    local PRIMARY_DB_NAME_ON_STANDBY=$(echo ${last_result})
    if [ "$PRIMARY_DB_NAME_ON_STANDBY" = "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is not running as a standby database"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is running as a standby database"      
    fi     
  fi
  
  # Check Transport lag is less than 10 seconds
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show database $DATABASE_UNIQUE_NAME" "-silent")
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to dgmgrl to show database failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else  
    local TRANSPORT_LAG=$( echo "$last_result" | sed -n "s/[[:space:]]*Transport Lag:[[:space:]]*\\([0-9]*\\).*\$/\\1/p")
    if [ "$TRANSPORT_LAG" = "" ]
    then
      # We have no value for transport lag
      cecho r "  ERROR: Transport lag can not be determined."
      (( errors_found++ ))   
    fi  
    local timelag_seconds=$(convert_dgmgrl_time_to_seconds "$TRANSPORT_LAG")   
    if [ $timelag_seconds -gt 10 ]
    then
      # We have lags on transport
      cecho r "  ERROR: Transport lag for $DATABASE_UNIQUE_NAME is to big ($timelag_seconds seconds) should be less than 10"
      (( errors_found++ ))    
    else
      cecho g "     OK: Transport lag ($timelag_seconds seconds) for $DATABASE_UNIQUE_NAME is below 10 seconds"
    fi
  fi
  
  # Check that all components are valid
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$INVALID_COMPONENTS_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get Standby database component status failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    local INVALID_COMPONENTS=$(echo ${last_result})
    if [ "$INVALID_COMPONENTS" != "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having invalid components $last_result"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is having valid components"      
    fi     
  fi
  
  # Check that all sys objects are valid
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$INVALID_SYS_OBJECTS_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get Primary database sys objects status failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    local INVALID_SYS_OBJECTS=$(echo ${last_result})
    if [ "$INVALID_SYS_OBJECTS" != "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having invalid sys objects $last_result"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is having valid sys objects"      
    fi     
  fi

  # Check that there is no pdb plugin violations
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PDB_PLUG_IN_VIOLATIONS_SQL" "-S" )
  last_error_code=$?
  if [ $last_error_code -ne 0 ]
  then
    # failed
    cecho r "  ERROR: Call to get Primary database PDB violations failed with code=$last_error_code and error text=$last_result"
    (( errors_found++ ))    
  else
    # success
    local PDB_PLUG_IN_VIOLATIONS=$(echo ${last_result})
    if [ "$PDB_PLUG_IN_VIOLATIONS" != "" ]
    then
      cecho r "  ERROR: $DATABASE_UNIQUE_NAME is having PDB plugin violations $last_result"
      (( errors_found++ ))
    else
      cecho g "     OK: $DATABASE_UNIQUE_NAME is having no PDB plugin violations"      
    fi     
  fi
  
  # Now we have checked as much as we can
  # If any errors found, then abort
  if [ $errors_found -ne 0 ]
  then
    cecho r "  ERROR: $errors_found errors found in precheck - will exit precheck with error"
    exit 1
  else
    cecho g "     OK: No errors found in precheck - will continue"    
  fi
  
  # On specific node run dgmgrl script to turn apply off
  APPLY_OFF_DGMGRL="edit database ${DATABASE_UNIQUE_NAME} set state='APPLY-OFF';"
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$APPLY_OFF_DGMGRL" "-silent" "$DRY_RUN" )
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to turn apply off: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Turn apply off for $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
      exit 2    
    else  
      cecho g "     OK: Turn apply off for $DATABASE_UNIQUE_NAME succeeded"
    fi
  fi

  # Now stop standby database
  last_result=$(call_srvctl "$ORACLE_HOME" "stop database -db ${DATABASE_UNIQUE_NAME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to stop database: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Stopping database ${DATABASE_UNIQUE_NAME} failed with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Stopping database ${DATABASE_UNIQUE_NAME} succeeded"
    fi
  fi
  
  # Modify Oracle Home
  last_result=$(call_srvctl "$ORACLE_HOME" "modify database -db ${DATABASE_UNIQUE_NAME} -o ${NEW_ORACLE_HOME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to modify ORACLE_HOME in cluster registry: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Modify ORACLE_HOME for ${DATABASE_UNIQUE_NAME} in cluster registry failed  with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Modify ORACLE_HOME for ${DATABASE_UNIQUE_NAME} in cluster registry succeeded"
    fi
  fi

  # Start the database in mount mode in new Oracle HOME
  last_result=$(call_srvctl "$ORACLE_HOME" "start database -db ${DATABASE_UNIQUE_NAME} -o mount" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to start database in mount mode: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Starting database ${DATABASE_UNIQUE_NAME} in mount mode failed  with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Starting database ${DATABASE_UNIQUE_NAME} in mount mode"
    fi
  fi
}

postpatch_standby()
{
  local DATABASE_UNIQUE_NAME=$1
  local DRY_RUN=$2
  local DONT_RELOAD_LISTENER=$3
  local VERBOSE=$4
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "DRY_RUN=$DRY_RUN"
  local LOG_DIRECTORY="${DBPATCH_CLUSTERED_LOG_LOCATION}/$DATABASE_UNIQUE_NAME"
  if [ "$DRY_RUN" = "YES" ]
  then
    local LOG_FILE="${LOG_DIRECTORY}/dry_run_postpatch_standby_${DATABASE_UNIQUE_NAME}_${now}.log"
  else
    local LOG_FILE="${LOG_DIRECTORY}/postpatch_standby_${DATABASE_UNIQUE_NAME}_${now}.log"
  fi 
  # Let's create log directory
  mkdir -p ${LOG_DIRECTORY}  
  # Let's log evry normal screen output to log file also
  exec   > >(tee -ia $LOG_FILE)
  exec  2> >(tee -ia $LOG_FILE >& 2)
  # We have tested that new home is different then old home and that new home exists
  # Find database Oracle_home
  local ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${DATABASE_UNIQUE_NAME}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  # First find a node where it's configured
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME}  | sed -n "s/.*is running on node[[:space:]]*\(.*\)$/\1/p"| head -1)
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get node where there is a instanse of ${DATABASE_UNIQUE_NAME} running"
    exit 1
  fi
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | sed -n "s/.*Instance[[:space:]]*\(.*\)[[:space:]]*is running on node[[:space:]]*.*$/\1/p" | head -1 )    
  if [ "$node_selected" = "" ]
  then
    cecho r "  ERROR: Can't get a running instanse of ${DATABASE_UNIQUE_NAME}"
    exit 1
  fi
  # Now start more logical checks that can be done while the above was successfull
  local errors_found=0
  local last_result=""
  local last_error_code=0
  # We should probably check here if oracle home on primary is the same as the one here
  # Set apply on
  # Currently no ligical checks here - s we do that in the prepatch  

  # Now we have checked as much as we can
  # If any errors found, then abort
  if [ $errors_found -ne 0 ]
  then
    cecho r "  ERROR: $errors_found errors found in precheck - will exit with error"
    exit 1
  else
    cecho g "     OK: No errors found in precheck - will continue"    
  fi
  
  # On specific node run dgmgrl script to turn apply on
  APPLY_ON_DGMGRL="edit database ${DATABASE_UNIQUE_NAME} set state='APPLY-ON';"
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$APPLY_ON_DGMGRL" "-silent" "$DRY_RUN" )
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    echo "   INFO: Would run command to turn apply on: $last_result"
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Turn apply on for $DATABASE_UNIQUE_NAME failed with code=$last_error_code and error text=$last_result"
      exit 2    
    else  
      cecho g "     OK: Turn apply on for $DATABASE_UNIQUE_NAME succeeded"
    fi
  fi

  # Now stop standby database
  last_result=$(call_srvctl "$ORACLE_HOME" "stop database -db ${DATABASE_UNIQUE_NAME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to stop database: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Stopping database ${DATABASE_UNIQUE_NAME} failed with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Stopping database ${DATABASE_UNIQUE_NAME} succeeded"
    fi
  fi

  # Start the database in normal mode
  last_result=$(call_srvctl "$ORACLE_HOME" "start database -db ${DATABASE_UNIQUE_NAME}" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run command to start database: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed - exit immediately as we need to be able to do this
      cecho r "  ERROR: Starting database ${DATABASE_UNIQUE_NAME} failed  with code=$last_error_code and output=$last_result"
      exit 2
    else
      cecho g "     OK: Starting database ${DATABASE_UNIQUE_NAME}"
    fi
  fi

  # Update static listener data
  if [ "$DRY_RUN" != "YES" ]
  then
    # Now maybe check that the version of the ORACLE_HOME is the same as the one nstalled on primary
    # TBD - does it make sense, maybe other checks also
    # Check if DONT_RELOAD_LISTENER is YES
    if [ "$DONT_RELOAD_LISTENER" = "YES" ]
    then
      #Run ndtnsctl to fix listener.ora 
      echo "   INFO: Will update static data in listener.ora and NOT restart listener"  
      ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME} --dontReloadListener
      # Can we check if it failed?
    else
      #Run ndtnsctl to fix listener.ora 
      echo "   INFO: Will update static data in listener.ora and restart listener"  
      ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME}
      # Can we check if it failed?
    fi
  else
    if [ "$DONT_RELOAD_LISTENER" = "YES" ]
    then
      if [ "$VERBOSE" = "YES" ]
      then
        echo "   INFO: Would update static data in listener.ora and restart listener with command: ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME} --dontReloadListener"
      fi
    else
      if [ "$VERBOSE" = "YES" ]
      then
        echo "   INFO: Would update static data in listener.ora and restart listener with command: ndtnsctl addorupdate tnsconf --entries static  --databaseUniqueName ${DATABASE_UNIQUE_NAME}"
      fi
    fi
  fi

  
  
  # Post patch checks
  
  # Check that standby home is the same as standby home
  PRIMARY_DB_ORACLE_HOME_SQL="set heading off
  set feedback off
  select value
  from c##nordeasystem.PATCH_HELPER
  where KEY = 'PRIMARY_DB_ORACLE_HOME';
  "
  last_result=$(call_sql_plus_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "$PRIMARY_DB_ORACLE_HOME_SQL" "-S" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    if [ "$VERBOSE" = "YES" ]
    then
      echo "   INFO: Would run to get new ORACLE_HOME from database table: $last_result"
    fi
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to get Primary database ORACLE_HOME from internal table failed with code=$last_error_code and error text=$last_result"
      (( errors_found++ ))    
    else
      # success
      local PRIMARY_DB_ORACLE_HOME=$(echo ${last_result})
      if [ "$ORACLE_HOME" != "$PRIMARY_DB_ORACLE_HOME" ]
      then
        cecho r "  ERROR: ORACLE_HOME on Primary is $PRIMARY_DB_ORACLE_HOME and Standby ORACLE_HOME is $ORACLE_HOME"
        (( errors_found++ ))
      else
        cecho g "     OK: ORACLE_HOME on Primary and Standby is both $PRIMARY_DB_ORACLE_HOME"      
      fi     
    fi  
  fi
  # Check Transport lag is less than 10 seconds
  last_result=$(call_dgmgrl_as_sys "$node_selected" "$ORACLE_HOME" "$sid_selected" "show database $DATABASE_UNIQUE_NAME" "-silent" "$DRY_RUN")
  last_error_code=$?
  if [ "$DRY_RUN" = "YES" ]
  then
    echo "   INFO: Would run to get dgmgrl database status and extract lag: $last_result"
  else
    if [ $last_error_code -ne 0 ]
    then
      # failed
      cecho r "  ERROR: Call to dgmgrl to show database failed with code=$last_error_code and error text=$last_result"
      (( errors_found++ ))    
    else  
      local TRANSPORT_LAG=$( echo "$last_result" | sed -n "s/[[:space:]]*Transport Lag:[[:space:]]*\\([0-9]*\\).*\$/\\1/p")
      if [ "$TRANSPORT_LAG" = "" ]
      then
        # We have no value for transport lag
        cecho r "  ERROR: Transport lag can not be determined."
        (( errors_found++ ))   
      fi  
      local timelag_seconds=$(convert_dgmgrl_time_to_seconds "$TRANSPORT_LAG")   
      if [ $timelag_seconds -gt 10 ]
      then
        # We have lags on transport
        cecho r "  ERROR: Transport lag for $DATABASE_UNIQUE_NAME is to big ($timelag_seconds seconds) should be less than 10"
        (( errors_found++ ))    
      else
        cecho g "     OK: Transport lag ($timelag_seconds seconds) for $DATABASE_UNIQUE_NAME is below 10 sesonds"
      fi
    fi
  fi
  # Now we have checked as much as we can
  # If any errors found, then exit with error (not during --dryRun)
  if [ "$DRY_RUN" != "YES" ]
  then
    if [ $errors_found -ne 0  ]
    then
      cecho r "  ERROR: $errors_found errors found in postcheck - will exit with error"
      exit 3
    else
      cecho g "     OK: No errors found in postcheck"    
    fi
  fi
}

dgfinish_pdb()
{
  local PDB_NAME=$1
  local DATABASE_UNIQUE_NAME=$2
  local PRIMARY_TNS_SERVICE_NAME=$3
  local PDB_SERVICE=$4
  local PDB_SERVICE_RO=$5
  local PDB_PREFERRED_INSTANCES=$6
  local PDB_AVAILABLE_INSTANCES=$7
  local PDB_RECOVERY_STATUS=$8
  local PDB_ADMIN_SERVICE=$9
  #echo "PDB_NAME=$PDB_NAME"
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "PRIMARY_TNS_SERVICE_NAME=$PRIMARY_TNS_SERVICE_NAME"
  #echo "PDB_PRIMARY_SERVICE_NAME=$PDB_PRIMARY_SERVICE_NAME"
  #echo "PDB_STANDBY_SERVICE_NAME=$PDB_STANDBY_SERVICE_NAME"
  #echo "PDB_PREFERRED_INSTANCES=$PDB_PREFERRED_INSTANCES"
  #echo "PDB_AVAILABLE_INSTANCES=$PDB_AVAILABLE_INSTANCES"
  #echo "PDB_RECOVERY_STATUS=$PDB_RECOVERY_STATUS"
  #echo "PDB_PRIMARY_ADMIN_SERVICE_NAME=$PDB_PRIMARY_ADMIN_SERVICE_NAME"
  # Make rman restore script
  RESTORE_PDB_RMAN="run{
  set newname for pluggable database ${PDB_NAME} to new;
  restore pluggable database ${PDB_NAME} from service ${PRIMARY_TNS_SERVICE_NAME};
  switch datafile all;
  }"
  # MAke script that enables PDB Recovery
  PDB_ENABLE_RECOVERY_SQL="alter session set container=${PDB_NAME};
  alter pluggable database enable recovery;"
  # Turn APPLY OFF
  APPLY_OFF_DGMGRL="connect /
  edit database ${DATABASE_UNIQUE_NAME} set state='APPLY-OFF';
  exit;"
  # Turn APPLY ON
  APPLY_ON_DGMGRL="connect /
  ! sleep 90
  edit database ${DATABASE_UNIQUE_NAME} set state='APPLY-ON';
  exit;"

  # Set grid environment - if not set
  set_grid_home
  # First Check if database exists
  # Find databases Oracle_home
  DB_ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${DATABASE_UNIQUE_NAME}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  # First find a first node where it exists
  node_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  sid_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p") 
  # If pluggable recovery status is disabled then fix that by copying over pdb files etc
  if [ "$PDB_RECOVERY_STATUS" = "DISABLED" ]
  then
    # Use RMAN to copy over files from primary
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${RESTORE_PDB_RMAN}\" | $DB_ORACLE_HOME/bin/rman target /"
    if [ $? -ne 0 ]
    then
      # Problems
      cecho r "  ERROR: Problems executing rman restore command"
      echo "${RESTORE_PDB_RMAN}"
      exit 1
    fi
    # On specific node run dgmgrl script to turn apply off
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${APPLY_OFF_DGMGRL}\" | $DB_ORACLE_HOME/bin/dgmgrl"       
    # Now stop standby database
    (export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; ${ORACLE_HOME}/bin/srvctl stop database -db ${DATABASE_UNIQUE_NAME})
    # Start in mount mode
    (export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; ${ORACLE_HOME}/bin/srvctl start database -db ${DATABASE_UNIQUE_NAME} -startoption "mount")
    # Enable recovery of PDB
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"${PDB_ENABLE_RECOVERY_SQL}\" | $DB_ORACLE_HOME/bin/sqlplus -S / as sysdba"  
    # On specific node run dgmgrl script to turn apply ON
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${APPLY_ON_DGMGRL}\" | $DB_ORACLE_HOME/bin/dgmgrl"       
    # Restart Database (to get in open mode
    (export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; ${DB_ORACLE_HOME}/bin/srvctl stop database -db ${DATABASE_UNIQUE_NAME}) 
    (export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; ${DB_ORACLE_HOME}/bin/srvctl start database -db ${DATABASE_UNIQUE_NAME})
    # We are finished getting pluggable out of DISBALED recovery status
  fi
  # Now create SERVICES
  # We need to test if we run RAC or NOT
  CHECK_CLUSTER_DB_SQL="set heading off
set feedback off
WHENEVER SQLERROR EXIT SQL.SQLCODE
select upper(value) from v\\\$parameter where name = 'cluster_database';
exit;"
  CHECK_CLUSTER_DB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CHECK_CLUSTER_DB_SQL\" | $DB_ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_CHECK_CLUSTER_DB=$?
  CHECK_CLUSTER_DB_RESULT=$(trim ${CHECK_CLUSTER_DB_RESULT})
  if [ $RESULT_FROM_CHECK_CLUSTER_DB -ne 0 ]
  then
    echo "${CHECK_CLUSTER_DB_RESULT}"
    cecho r "  ERROR: Problem Checking if Database runs RAC. SQL*plus returned Error code $RESULT_FROM_CHECK_CLUSTER_DB."
    exit 1
  fi
  #echo "CHECK_CLUSTER_DB_RESULT=$CHECK_CLUSTER_DB_RESULT"
  if [ "$CHECK_CLUSTER_DB_RESULT" == "FALSE" ]
  then
    # SINGLE INstance PDB
    # Create and start the "database name" service:
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -l primary)
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -l primary,physical_standby)
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -l physical_standby)
  else
    # RAC PDB
    # Did we run on all nodes in cluster?
    if [ -z "${PDB_AVAILABLE_INSTANCES}" ]
    then
      # No avail_instances, start on all nodes
      # Create and start the "database name" service:
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -l primary)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -l primary,physical_standby)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${PDB_PREFERRED_INSTANCES} -l physical_standby)
    else
      # avail instances are present, start on the ones we selected
      # Create and start the "database name" service:
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l primary)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l primary,physical_standby)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l physical_standby)
    fi
  fi
  # Start the ro service as we are on standby
  (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_SERVICE_RO})
  # Start the admin service on the standby
  (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_ADMIN_SERVICE})
  cecho g "     OK: Finished Pluggable Database ${PDB_NAME} and services ${PDB_SERVICE}, ${PDB_ADMIN_SERVICE} and ${PDB_SERVICE_RO}"
  (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status service -d ${DATABASE_UNIQUE_NAME}  -pdb  ${PDB_NAME})
}

create_services()
{
  local PDB_NAME=$1
  local DATABASE_UNIQUE_NAME=$2
  local IS_PRIMARY_DATABASE=$3
  local PDB_SERVICE=$4
  local PDB_SERVICE_RO=$5
  local PDB_PREFERRED_INSTANCES=$6
  local PDB_AVAILABLE_INSTANCES=$7
  local PDB_RECOVERY_STATUS=$8 # Do use this at all
  local PDB_ADMIN_SERVICE=$9
  #echo "PDB_NAME=$PDB_NAME"
  #echo "DATABASE_UNIQUE_NAME=$DATABASE_UNIQUE_NAME"
  #echo "PDB_PRIMARY_SERVICE_NAME=$PDB_PRIMARY_SERVICE_NAME"
  #echo "PDB_STANDBY_SERVICE_NAME=$PDB_STANDBY_SERVICE_NAME"
  #echo "PDB_PREFERRED_INSTANCES=$PDB_PREFERRED_INSTANCES"
  #echo "PDB_AVAILABLE_INSTANCES=$PDB_AVAILABLE_INSTANCES"
  #echo "PDB_RECOVERY_STATUS=$PDB_RECOVERY_STATUS"
  #echo "PDB_PRIMARY_ADMIN_SERVICE_NAME=$PDB_PRIMARY_ADMIN_SERVICE_NAME"
  # Set grid environment - if not set
  set_grid_home
  # First Check if database exists
  # Find databases Oracle_home
  DB_ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${DATABASE_UNIQUE_NAME}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  # First find a first node where it exists
  node_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  sid_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p") 
  # Now create SERVICES
  # We need to test if we run RAC or NOT
  CHECK_CLUSTER_DB_SQL="set heading off
set feedback off
WHENEVER SQLERROR EXIT SQL.SQLCODE
select upper(value) from v\\\$parameter where name = 'cluster_database';
exit;"
  CHECK_CLUSTER_DB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CHECK_CLUSTER_DB_SQL\" | $DB_ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_CHECK_CLUSTER_DB=$?
  CHECK_CLUSTER_DB_RESULT=$(trim ${CHECK_CLUSTER_DB_RESULT})
  if [ $RESULT_FROM_CHECK_CLUSTER_DB -ne 0 ]
  then
    echo "${CHECK_CLUSTER_DB_RESULT}"
    cecho r "  ERROR: Problem Checking if Database runs RAC. SQL*plus returned Error code $RESULT_FROM_CHECK_CLUSTER_DB."
    exit 1
  fi
  #echo "CHECK_CLUSTER_DB_RESULT=$CHECK_CLUSTER_DB_RESULT"
  if [ "$CHECK_CLUSTER_DB_RESULT" == "FALSE" ]
  then
    # SINGLE INstance PDB
    # Create and start the "database name" service:
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -l primary)
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -l primary,physical_standby)
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -l physical_standby)
  else
    # Did we run on all nodes in cluster?
    if [ -z "${PDB_AVAILABLE_INSTANCES}" ]
    then
      # No avail_instances, start on all nodes
      # Create and start the "database name" service:
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -l primary)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -l primary,physical_standby)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${PDB_PREFERRED_INSTANCES} -l physical_standby)
    else
      # avail instances are present, start on the ones we selected
      # Create and start the "database name" service:
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l primary)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l primary,physical_standby)
      (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l physical_standby)
    fi
  fi
  # Start the admin service on the all databases
  (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_ADMIN_SERVICE})
  if [ "$IS_PRIMARY_DATABASE" = "YES" ]
  then
    # Start the app service as we are on primary
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_SERVICE})
  else
    # Start the ro service as we are on standby
    (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_SERVICE_RO})
  fi
  cecho g "     OK: Finished Pluggable Database ${PDB_NAME} and services ${PDB_SERVICE}, ${PDB_ADMIN_SERVICE} and ${PDB_SERVICE_RO}"
  (export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status service -d ${DATABASE_UNIQUE_NAME}  -pdb  ${PDB_NAME})
}


create_pdb()
{
  #set -x
  local PDB_NAME=$1
  local PDB_SERVICE=$2
  local PDB_SERVICE_RO=$3  
  local DATABASE_UNIQUE_NAME=$4
  local ORACLE_HOME=$5
  local USE_SGA_MEMORY_PROFILE=$6
  local USE_CPU_COUNT_PROFILE=$7
  local USE_STORAGE_CAPACITY_PROFILE=$8
  local USE_STORAGE_IOPS_PROFILE=$9
  local USE_STORAGE_BANDWIDTH_PROFILE=${10}
  local PDB_PREFERRED_INSTANCES=${11}
  local PDB_AVAILABLE_INSTANCES=${12}
  local PDB_ADMIN_HASH_PASSWORD=${13}
  local PDB_PLUG_FILE=${14}
  local PDB_NLS_LENGTH_SEMANTICS=${15}
  local PDB_PREPARE_FOR_MIGRATION=${16}
  local PDB_ADMIN_SERVICE=${17}
  local PDB_STANDBYS=${18}  
  #echo "PDB_NAME=$1"
  #echo "PDB_SERVICE=$2"
  #echo "PDB_SERVICE_RO=$3"  
  #echo "DATABASE_UNIQUE_NAME=$4"
  #echo "ORACLE_HOME=$5"
  #echo "USE_SGA_MEMORY_PROFILE=$6"
  #echo "USE_CPU_COUNT_PROFILE=$7"
  #echo "USE_STORAGE_CAPACITY_PROFILE=$8"
  #echo "USE_STORAGE_IOPS_PROFILE=$9"
  #echo "USE_STORAGE_BANDWIDTH_PROFILE=${10}"
  #echo "PDB_PREFERRED_INSTANCES=${11}"
  #echo "PDB_AVAILABLE_INSTANCES=${12}"
  #echo "PDB_ADMIN_HASH_PASSWORD=${13}"
  #echo "PDB_PLUG_FILE=${14}"  
  #echo "PDB_NLS_LENGTH_SEMANTICS=${15}"  
  #echo "PDB_PREPARE_FOR_MIGRATION=${16}"    
  #echo "PDB_ADMIN_SERVICE=${17}"    
  #echo "PDB_STANDBYS=${18}"    
  # Basically we call the pdb create stuf in the C##nordea_system
  #set -x
  # First find a node where it's configured
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")  # update audit_trail
  CLOSE_PDB_ON_ALL_INSTANCES="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
   PDB_ALREADY_CLOSED EXCEPTION; 
   PRAGMA EXCEPTION_INIT (PDB_ALREADY_CLOSED, -65020); 
BEGIN
  execute immediate 'ALTER PLUGGABLE DATABASE ${PDB_NAME} CLOSE IMMEDIATE INSTANCES = ALL';
EXCEPTION
  WHEN PDB_ALREADY_CLOSED THEN
    --Ignore if it's already closed
    NULL;
END;
/
"
  OPEN_PDB_ON_ALL_INSTANCES="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
   PDB_ALREADY_CLOSED EXCEPTION; 
   PRAGMA EXCEPTION_INIT (PDB_ALREADY_CLOSED, -65020); 
BEGIN
  execute immediate 'ALTER PLUGGABLE DATABASE ${PDB_NAME} CLOSE IMMEDIATE INSTANCES = ALL';
EXCEPTION
  WHEN PDB_ALREADY_CLOSED THEN
    --Ignore if it's already closed
    NULL;
END;
/
ALTER PLUGGABLE DATABASE ${PDB_NAME} open read write INSTANCES = ALL;
"  
  INSERT_PDB_SERVICES_SQL="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE  
delete from c##nordeasystem.PDB_SERVICES
where SERVICE_NAME IN ('${PDB_SERVICE}','${PDB_SERVICE_RO}','${PDB_ADMIN_SERVICE}');  
insert into c##nordeasystem.PDB_SERVICES(
SERVICE_NAME
,SERVICE_ROLE
,PDB_NAME
,NORDEA_TYPE
) values (
'${PDB_SERVICE}'
,'PRIMARY'
,'${PDB_NAME}'
,'APP_SERVICE'
);
insert into c##nordeasystem.PDB_SERVICES(
SERVICE_NAME
,SERVICE_ROLE
,PDB_NAME
,NORDEA_TYPE
) values (
'${PDB_SERVICE_RO}'
,'PHYSICAL STANDBY'
,'${PDB_NAME}'
,'APP_RO_SERVICE'
);
insert into c##nordeasystem.PDB_SERVICES(
SERVICE_NAME
,SERVICE_ROLE
,PDB_NAME
,NORDEA_TYPE
) values (
'${PDB_ADMIN_SERVICE}'
,'PRIMARY'
,'${PDB_NAME}'
,'ADMIN_SERVICE'
);
COMMIT;
"
  CREATE_SNAPSHOT_GV_SERVICES_SQL="set serveroutput on
WHENEVER SQLERROR CONTINUE
 CREATE TABLE c##nordeasystem.PDB_SERVICES 
  (	SERVICE_NAME VARCHAR2(30 CHAR), 
    SERVICE_ROLE VARCHAR2(30 CHAR), 
    PDB_NAME VARCHAR2(30 CHAR)
  ) ;
 ALTER TABLE c##nordeasystem.PDB_SERVICES MODIFY (SERVICE_NAME NOT NULL ENABLE);
 ALTER TABLE c##nordeasystem.PDB_SERVICES MODIFY (SERVICE_ROLE NOT NULL ENABLE);
 ALTER TABLE c##nordeasystem.PDB_SERVICES ADD CONSTRAINT PDB_SERVICES_PK PRIMARY KEY (SERVICE_NAME)
 USING INDEX  ENABLE;
 ALTER TABLE c##nordeasystem.PDB_SERVICES MODIFY (PDB_NAME NOT NULL ENABLE);
 ALTER TABLE c##nordeasystem.PDB_SERVICES 
 ADD (NORDEA_TYPE VARCHAR2(30) DEFAULT 'OLD' NOT NULL);
drop table c##nordeasystem.snapshot_gv\\\$services cascade constraints PURGE;
WHENEVER SQLERROR EXIT SQL.SQLCODE
create table c##nordeasystem.snapshot_gv\\\$services as select * from gv\\\$services;
"
  CREATE_PDB_SQL="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
  P_NEW_PDBNAME VARCHAR2(200);
  P_CPU_PROFILE VARCHAR2(200);
  P_MEMORY_PROFILE VARCHAR2(200);
  P_STORAGECAPACITY_PROFILE VARCHAR2(200);
  P_STORAGEIOPS_PROFILE VARCHAR2(200);
  P_STORAGEBANDWIDTH_PROFILE VARCHAR2(200);
  P_GENERIC_PROFILE VARCHAR2(200);
  P_PDB_ADMIN_USERNAME VARCHAR2(200);
  P_PDB_ADMIN_HASH_PASSWORD VARCHAR2(400);
  P_PDB_PLUG_FILE VARCHAR2(200);
  P_NLS_LENGTH_SEMANTICS VARCHAR2(200);
  P_PREPARE_FOR_MIGRATION VARCHAR2(200);
  v_Return VARCHAR2(200);
BEGIN
  P_NEW_PDBNAME := '${PDB_NAME}';
  P_CPU_PROFILE := '${USE_CPU_COUNT_PROFILE}';
  P_MEMORY_PROFILE := '${USE_SGA_MEMORY_PROFILE}';
  P_STORAGECAPACITY_PROFILE := '${USE_STORAGE_CAPACITY_PROFILE}';
  P_STORAGEIOPS_PROFILE := '${USE_STORAGE_IOPS_PROFILE}';
  P_STORAGEBANDWIDTH_PROFILE := '${USE_STORAGE_BANDWIDTH_PROFILE}';
  P_GENERIC_PROFILE := 'generic';
  P_PDB_ADMIN_USERNAME := 'pdb_admin';
  P_PDB_ADMIN_HASH_PASSWORD := '${PDB_ADMIN_HASH_PASSWORD}';
  P_PDB_PLUG_FILE := '${PDB_PLUG_FILE}';
  P_NLS_LENGTH_SEMANTICS := '${PDB_NLS_LENGTH_SEMANTICS}';
  P_PREPARE_FOR_MIGRATION := '${PDB_PREPARE_FOR_MIGRATION}';
  v_Return := C##NORDEASYSTEM.DBMGMT.CREATE_PDB_FROM_SEED(
    P_NEW_PDBNAME => P_NEW_PDBNAME,
    P_CPU_PROFILE => P_CPU_PROFILE,
    P_MEMORY_PROFILE => P_MEMORY_PROFILE,
    P_STORAGECAPACITY_PROFILE => P_STORAGECAPACITY_PROFILE,
    P_STORAGEIOPS_PROFILE => P_STORAGEIOPS_PROFILE,
    P_STORAGEBANDWIDTH_PROFILE => P_STORAGEBANDWIDTH_PROFILE,
    P_GENERIC_PROFILE => P_GENERIC_PROFILE,
    P_PDB_ADMIN_USERNAME => P_PDB_ADMIN_USERNAME,
    P_PDB_ADMIN_HASH_PASSWORD => P_PDB_ADMIN_HASH_PASSWORD,
    P_PDB_PLUG_FILE => P_PDB_PLUG_FILE,
    P_NLS_LENGTH_SEMANTICS => P_NLS_LENGTH_SEMANTICS,
    P_PREPARE_FOR_MIGRATION => P_PREPARE_FOR_MIGRATION
  );
  DBMS_OUTPUT.PUT_LINE('v_Return = ' || v_Return);
END;
/"

  CREATE_RAW_PDB_SQL="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
  P_NEW_PDBNAME VARCHAR2(200);
  P_PDB_ADMIN_USERNAME VARCHAR2(200);
  P_PDB_ADMIN_HASH_PASSWORD VARCHAR2(400);
  P_PDB_PLUG_FILE VARCHAR2(200);
  v_Return VARCHAR2(200);
BEGIN
  P_NEW_PDBNAME := '${PDB_NAME}';
  P_PDB_ADMIN_USERNAME := 'pdb_admin';
  P_PDB_ADMIN_HASH_PASSWORD := '${PDB_ADMIN_HASH_PASSWORD}';
  P_PDB_PLUG_FILE := '${PDB_PLUG_FILE}';
  v_Return := C##NORDEASYSTEM.DBMGMT.CREATE_RAW_PDB_FROM_SEED(
    P_NEW_PDBNAME => P_NEW_PDBNAME,
    P_PDB_ADMIN_USERNAME => P_PDB_ADMIN_USERNAME,
    P_PDB_ADMIN_HASH_PASSWORD => P_PDB_ADMIN_HASH_PASSWORD,
    P_PDB_PLUG_FILE => P_PDB_PLUG_FILE
  );
  DBMS_OUTPUT.PUT_LINE('v_Return = ' || v_Return);
END;
/"

  CREATE_RAW_PDB_STANDBYS_SQL="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
  P_NEW_PDBNAME VARCHAR2(200);
  P_PDB_ADMIN_USERNAME VARCHAR2(200);
  P_PDB_ADMIN_HASH_PASSWORD VARCHAR2(400);
  P_PDB_PLUG_FILE VARCHAR2(200);
  v_Return VARCHAR2(200);
BEGIN
  P_NEW_PDBNAME := '${PDB_NAME}';
  P_PDB_ADMIN_USERNAME := 'pdb_admin';
  P_PDB_ADMIN_HASH_PASSWORD := '${PDB_ADMIN_HASH_PASSWORD}';
  P_PDB_PLUG_FILE := '${PDB_PLUG_FILE}';
  v_Return := C##NORDEASYSTEM.DBMGMT.CREATE_RAW_PDB_FROM_SEED(
    P_NEW_PDBNAME => P_NEW_PDBNAME,
    P_PDB_ADMIN_USERNAME => P_PDB_ADMIN_USERNAME,
    P_PDB_ADMIN_HASH_PASSWORD => P_PDB_ADMIN_HASH_PASSWORD,
    P_PDB_PLUG_FILE => P_PDB_PLUG_FILE,
    P_PDB_STANDBYS => '${PDB_STANDBYS}'
  );
  DBMS_OUTPUT.PUT_LINE('v_Return = ' || v_Return);
END;
/"

  CONFIGURE_PDB_SQL="set serveroutput on
WHENEVER SQLERROR EXIT SQL.SQLCODE
DECLARE
  P_NEW_PDBNAME VARCHAR2(200);
  P_CPU_PROFILE VARCHAR2(200);
  P_MEMORY_PROFILE VARCHAR2(200);
  P_STORAGECAPACITY_PROFILE VARCHAR2(200);
  P_STORAGEIOPS_PROFILE VARCHAR2(200);
  P_STORAGEBANDWIDTH_PROFILE VARCHAR2(200);
  P_GENERIC_PROFILE VARCHAR2(200);
  P_PDB_ADMIN_USERNAME VARCHAR2(200);
  P_PDB_ADMIN_HASH_PASSWORD VARCHAR2(400);
  P_PDB_PLUG_FILE VARCHAR2(200);
  P_NLS_LENGTH_SEMANTICS VARCHAR2(200);
  P_PREPARE_FOR_MIGRATION VARCHAR2(200);
  v_Return VARCHAR2(200);
BEGIN
  P_NEW_PDBNAME := '${PDB_NAME}';
  P_CPU_PROFILE := '${USE_CPU_COUNT_PROFILE}';
  P_MEMORY_PROFILE := '${USE_SGA_MEMORY_PROFILE}';
  P_STORAGECAPACITY_PROFILE := '${USE_STORAGE_CAPACITY_PROFILE}';
  P_STORAGEIOPS_PROFILE := '${USE_STORAGE_IOPS_PROFILE}';
  P_STORAGEBANDWIDTH_PROFILE := '${USE_STORAGE_BANDWIDTH_PROFILE}';
  P_GENERIC_PROFILE := 'generic';
  P_PDB_ADMIN_USERNAME := 'pdb_admin';
  P_PDB_ADMIN_HASH_PASSWORD := '${PDB_ADMIN_HASH_PASSWORD}';
  P_NLS_LENGTH_SEMANTICS := '${PDB_NLS_LENGTH_SEMANTICS}';
  P_PREPARE_FOR_MIGRATION := '${PDB_PREPARE_FOR_MIGRATION}';
  v_Return := C##NORDEASYSTEM.DBMGMT.CONFIGURE_PDB(
    P_NEW_PDBNAME => P_NEW_PDBNAME,
    P_CPU_PROFILE => P_CPU_PROFILE,
    P_MEMORY_PROFILE => P_MEMORY_PROFILE,
    P_STORAGECAPACITY_PROFILE => P_STORAGECAPACITY_PROFILE,
    P_STORAGEIOPS_PROFILE => P_STORAGEIOPS_PROFILE,
    P_STORAGEBANDWIDTH_PROFILE => P_STORAGEBANDWIDTH_PROFILE,
    P_GENERIC_PROFILE => P_GENERIC_PROFILE,
    P_PDB_ADMIN_USERNAME => P_PDB_ADMIN_USERNAME,
    P_PDB_ADMIN_HASH_PASSWORD => P_PDB_ADMIN_HASH_PASSWORD,
    P_NLS_LENGTH_SEMANTICS => P_NLS_LENGTH_SEMANTICS,
    P_PREPARE_FOR_MIGRATION => P_PREPARE_FOR_MIGRATION
  );
  DBMS_OUTPUT.PUT_LINE('v_Return = ' || v_Return);
END;
/"

  # If we using a seed file, it might be old and we need to create pdb first and then datapatch it. So now we call 2 procedures. One that makes simple creation
  # and one that does the configuration
  # First creation
  if [ "${PDB_STANDBYS}" = "" ]
  then
    #echo "No Standbys option used, use old SQL"
    CREATE_PDB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CREATE_RAW_PDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  else
    #echo "Standbys option used, pass it on"
    CREATE_PDB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CREATE_RAW_PDB_STANDBYS_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  fi
  RESULT_FROM_CREATION=$?
  if [ $RESULT_FROM_CREATION -ne 0 ]
  then
    cecho r "  ERROR: Problem creating PDB. SQL *plus returned Error code $RESULT_FROM_CREATION."
    cecho r "${CREATE_PDB_RESULT}"
    exit 1
  fi
  # Before moving on we need to run datapatch on the pdb
  # ensure the pdb is open first as datapatch wont work otherwise
  OPEN_PDB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$OPEN_PDB_ON_ALL_INSTANCES\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_OPEN=$?
  if [ $RESULT_FROM_OPEN -ne 0 ]
  then
    cecho r "  ERROR: Problem opening PDB (before datapatch). SQL*plus returned Error code $RESULT_FROM_OPEN."
    cecho r "${OPEN_PDB_RESULT}"
    exit 1
  fi
#MJ 2021-05-31 added execute of dbupgrade
  # Run dbupgrade where the CDB has some instances if we need to characterset seed database
  # do not bitehr to check the version since it takes only 5 sec to do dbupgrade on 12.2
  if [ "$PDB_PLUG_FILE" != "" ]
  then
    DBUPGRADE_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; $ORACLE_HOME/bin/dbupgrade -c $(convert_to_upper ${PDB_NAME}) -l /tmp")
    # ensure the pdb is closed on all instances
    RESULT_FROM_DBUPGRADE=$?
    if [ $RESULT_FROM_DBUPGRADE -ne 0 ]
    then
      cecho r "  ERROR: Problem running dbupgrade. dbupgrade returned Error code $RESULT_FROM_DBUPGRADE."
      cecho r "${DBUPGRADE_RESULT}"
      exit 1
    fi
    # ensure the pdb is open first as dbupgrade wont work otherwise
    OPEN_PDB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$OPEN_PDB_ON_ALL_INSTANCES\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
    RESULT_FROM_OPEN=$?
    if [ $RESULT_FROM_OPEN -ne 0 ]
    then
      cecho r "  ERROR: Problem opening PDB (before datapatch). SQL*plus returned Error code $RESULT_FROM_OPEN."
      cecho r "${OPEN_PDB_RESULT}"
      exit 1
    fi
  fi
#
  # Run datapatch where the CDB has some instances
  DATAPATCH_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; $ORACLE_HOME/OPatch/datapatch -verbose -pdbs $(convert_to_upper ${PDB_NAME})")
  # ensure the pdb is closed on all instances
  RESULT_FROM_DATAPATCH=$?
  if [ $RESULT_FROM_DATAPATCH -ne 0 ]
  then
    cecho r "  ERROR: Problem running datapatch. datapatch returned Error code $RESULT_FROM_DATAPATCH."
    cecho r "${DATAPATCH_RESULT}"
    exit 1
  fi
  ## Reopen PDB after datapatch
  CLOSE_PDB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$OPEN_PDB_ON_ALL_INSTANCES\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_CLOSE=$?
  if [ $RESULT_FROM_CLOSE -ne 0 ]
  then
    cecho r "  ERROR: Problem closing PDB (after datapatch). SQL*plus returned Error code $RESULT_FROM_CLOSE."
    cecho r "${CLOSE_PDB_RESULT}"
    exit 1
  fi
  # Now do the configuration of the pdb
  CONFIGURE_PDB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CONFIGURE_PDB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_CONFIGURATION=$?
  if [ $RESULT_FROM_CONFIGURATION -ne 0 ]
  then
    cecho r "  ERROR: Problem configuring PDB. SQL *plus returned Error code $RESULT_FROM_CONFIGURATION."
    cecho r "${CONFIGURE_PDB_RESULT}"
    exit 1
  fi
  
  # Then create the services - the service should be picked up automatically on Standbys using a script
  # Standard service and _ro service
  # Di we run on all nodes in cluster?
  
  # We need to test if we run RAC or NOT
  CHECK_CLUSTER_DB_SQL="set heading off
set feedback off
WHENEVER SQLERROR EXIT SQL.SQLCODE
select upper(value) from v\\\$parameter where name = 'cluster_database';
exit;"
  CHECK_CLUSTER_DB_RESULT=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CHECK_CLUSTER_DB_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_CHECK_CLUSTER_DB=$?
  CHECK_CLUSTER_DB_RESULT=$(trim ${CHECK_CLUSTER_DB_RESULT})
  if [ $RESULT_FROM_CHECK_CLUSTER_DB -ne 0 ]
  then
    cecho r "  ERROR: Problem Checking if Database runs RAC. SQL*plus returned Error code $RESULT_FROM_CHECK_CLUSTER_DB."
    cecho r "${CHECK_CLUSTER_DB_RESULT}"
    exit 1
  fi
  #echo "CHECK_CLUSTER_DB_RESULT=$CHECK_CLUSTER_DB_RESULT"
  if [ "$CHECK_CLUSTER_DB_RESULT" == "FALSE" ]
  then
    # SINGLE INstance PDB
    # Create and start the "database name" service:
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -l primary)
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -l primary,physical_standby)
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -l physical_standby)
  else
    # RAC PDB
    if [ -z "${PDB_AVAILABLE_INSTANCES}" ]
    then
      # No avail_instances, start on all nodes
      # Create and start the "database name" service:
      (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -l primary)
      (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -l primary,physical_standby)
      (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${PDB_PREFERRED_INSTANCES} -l physical_standby)
    else
      # avail instances are present, start on the ones we selected
      # Create and start the "database name" service:
      (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l primary)
      (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_ADMIN_SERVICE} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l primary,physical_standby)
      (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${PDB_PREFERRED_INSTANCES} -a ${PDB_AVAILABLE_INSTANCES} -l physical_standby)
    fi
  fi
  (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_SERVICE})
  (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_ADMIN_SERVICE})
  # Start/stop the ro service as that sometimes seems to be needed for it to work later in a dataguard configuration
  (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${PDB_SERVICE_RO})
  # Now create a snapshot of gv$services in c##nordeasystem, which can be used on standbys to create services
  # If no standby this is still ok We do this here as both services should probably be up for us to see them in gv$SERVICES
  CREATE_SNAPSHOT_GV_SERVICES=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CREATE_SNAPSHOT_GV_SERVICES_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_SNAPSHOT=$?
  if [ $RESULT_FROM_CREATION -ne 0 ]
  then
    cecho p "WARNING: Problem creating snapshot of GV\$SERVICES for easy data guard service creation. SQL *plus returned Error code $RESULT_FROM_SNAPSHOT."
    cecho p "${CREATE_SNAPSHOT_GV_SERVICES}"
  fi
  # Stop the service we don't need on primart  
  (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl stop service -d $DATABASE_UNIQUE_NAME -s ${PDB_SERVICE_RO})
  cecho g "     OK: Created Pluggable Database ${PDB_NAME} and services ${PDB_SERVICE}, ${PDB_ADMIN_SERVICE} and ${PDB_SERVICE_RO}"
  (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status service -d ${DATABASE_UNIQUE_NAME}  -pdb  ${PDB_NAME})
  INSERT_PDB_SERVICES=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$INSERT_PDB_SERVICES_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  RESULT_FROM_INSERT=$?
  if [ $RESULT_FROM_INSERT -ne 0 ]
  then
    cecho p "WARNING: Problem inserting service roles in snapshot of GV\$SERVICES for easy data guard service creation. SQL *plus returned Error code $RESULT_FROM_INSERT."
    cecho p "${INSERT_PDB_SERVICES}"
  fi
  # make sure services are registred immediately
  snapshot_services "$DATABASE_UNIQUE_NAME" "$ORACLE_HOME"
  echo "## PDB Post Configuration START"
  echo "1) Suggested TNS entry for applications. Remember to order DNS names that points to the two scan listener IP's"
  echo "   ora-${PDB_SERVICE}-a.${HOSTNAME#*.} and ora-${PDB_SERVICE}-b.${HOSTNAME#*.}"
  cecho b "## TNS START"
  cecho b "#
# Service description for ${PDB_SERVICE}
#
${PDB_SERVICE}.world =
  (DESCRIPTION =
    (LOAD_BALANCE = OFF)
    (FAILOVER = ON)
    (CONNECT_TIMEOUT = 5)
    (TRANSPORT_CONNECT_TIMEOUT = 3)
    (RETRY_COUNT = 3 )
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = ora-${PDB_SERVICE}-a.${HOSTNAME#*.})(PORT = 1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = ora-${PDB_SERVICE}-b.${HOSTNAME#*.})(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVICE_NAME = ${PDB_SERVICE})
      (FAILOVER_MODE = (TYPE = SELECT)(METHOD = BASIC))
    )
  )"
  cecho b "#
# Service description for ${PDB_SERVICE_RO}
#
${PDB_SERVICE_RO}.world =
  (DESCRIPTION =
    (LOAD_BALANCE = OFF)
    (FAILOVER = ON)
    (CONNECT_TIMEOUT = 5)
    (TRANSPORT_CONNECT_TIMEOUT = 3)
    (RETRY_COUNT = 3)
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = ora-${PDB_SERVICE}-a.${HOSTNAME#*.})(PORT = 1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = ora-${PDB_SERVICE}-b.${HOSTNAME#*.})(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVICE_NAME = ${PDB_SERVICE_RO})
      (FAILOVER_MODE = (TYPE = SELECT)(METHOD = BASIC))
    )
  )"  
  # Check if database has standbys
  CDB_STDBY_UNIQUE_NAMES_SQL="set heading off
set feedback off
select lower(db_unique_name) from v\\\$archive_dest where status = 'VALID' and target = 'STANDBY';
"
  CDB_STDBY_UNIQUE_NAMES=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"$CDB_STDBY_UNIQUE_NAMES_SQL\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba")
  if [ "$CDB_STDBY_UNIQUE_NAMES" != "" ]
  then
    echo "## DG SETUP START"
    echo "Seems like we are running in a database that have a standby database setup."
    echo "Services post configuration needs to be done for each standby database."
    echo "Do this on one of the hosts where the standby database runs."
    #echo "## We assume standard Nordea instance naming - if this is not correct the instances"
    #echo "## given in commands below will not be correct and commands will fail."
  fi
  for stdby_unique_name in $CDB_STDBY_UNIQUE_NAMES
  do
    local new_preferred_instances=""
    local new_available_instances=""
    # First calculate new instance names assuming we folow nordea naming convention for db's and instance names
    #for preferred_instance in ${PDB_PREFERRED_INSTANCES//,/ }
    #do
    #  if [ "$new_preferred_instances" = "" ]
    #  then 
    #    new_preferred_instances="${stdby_unique_name}${preferred_instance: -1}"
    #  else
    #    new_preferred_instances="${new_preferred_instances},${stdby_unique_name}${preferred_instance: -1}"
    #  fi
    #done
    #for available_instance in ${PDB_AVAILABLE_INSTANCES//,/ }
    #do
    #  if [ "$new_available_instances" = "" ]
    #  then 
    #    new_available_instances="${stdby_unique_name}${available_instance: -1}"
    #  else
    #    new_available_instances="${new_available_instances},${stdby_unique_name}${available_instance: -1}"
    #  fi
    #done   
    echo "## POST Configuration on database $stdby_unique_name"
    echo "Configure services and make data guard work for non AL32UT8 PDB's on standby"
    echo "database $stdby_unique_name. Be aware that if PDB characterset is not AL32UTF" 
    echo "the standby database will be restarted during the proces of getting dataguard"
    echo "for the PDB to work." 
    echo "1) Login as oracle on a node in the standby cluster(s) where the standby database(s) is located" 
    echo "2) Run the following script"
    cecho c "   nddbctl dgfinish pdb --pdbName ${PDB_NAME} --databaseUniqueName ${stdby_unique_name}"     
    #if [ -z "${PDB_AVAILABLE_INSTANCES}" ]
    #then
    #  # No avail_instances, start on all nodes
    #  # Create and start the "database name" service:
    #  cecho r "   srvctl add service -d ${stdby_unique_name} -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${new_preferred_instances} -l primary"
    #  cecho r "   srvctl add service -d ${stdby_unique_name} -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${new_preferred_instances} -l physical_standby"
    #else
    #  # avail instances are present, start on the ones we selected
    #  # Create and start the "database name" service:
    #  cecho r "   srvctl add service -d ${stdby_unique_name} -pdb ${PDB_NAME} -s ${PDB_SERVICE} -r ${new_preferred_instances} -a ${new_available_instances} -l primary"
    #  cecho r "   srvctl add service -d ${stdby_unique_name} -pdb ${PDB_NAME} -s ${PDB_SERVICE_RO} -r ${new_preferred_instances} -a ${new_available_instances} -l physical_standby"
    #fi
    #echo "4) Start \"standby\" service on standby"
    #cecho r "   srvctl start service -d ${stdby_unique_name} -s ${PDB_SERVICE_RO}"
  done
  echo "## PDB Post Configuration END"
}

check_pdb()
{
  #set -x
  local INPUT_DATABASE_UNIQUE_NAME="$1"
  local INPUT_PDB_NAME="$2"
  local INPUT_CHECKS="$3"
  local INPUT_TRY_FIX="$4"
  echo "INPUT_DATABASE_UNIQUE_NAME=$INPUT_DATABASE_UNIQUE_NAME"
  echo "INPUT_PDB_NAME=$INPUT_PDB_NAME"
  echo "INPUT_CHECKS=$INPUT_CHECKS"
  echo "INPUT_TRY_FIX=$INPUT_TRY_FIX"
  local SIZE_ANALYZE_SQL
  if [ "$INPUT_PDB_NAME" != "" ]
  then
    SIZE_ANALYZE_SQL="select 
    name,MAX_SIZE_GB,TOTAL_SIZE_GB
    from
    c##nordeasystem.pdb_size_recomendation
    where
    lower(name) = lower('$INPUT_PDB_NAME')
    and
    max_size_gb * 0.7 < total_size_gb;"
  else
    SIZE_ANALYZE_SQL="select 
    name,MAX_SIZE_GB,TOTAL_SIZE_GB
    from
    c##nordeasystem.pdb_size_recomendation
    where
    max_size_gb * 0.7 < total_size_gb;"
  fi
  SIZE_ANALYZE_SQL="set heading off
set pagesize 0
set linesize 80
set feedback off
COLUMN name FORMAT A32
COLUMN MAX_SIZE_GB FORMAT 999999
COLUMN TOTAL_SIZE_GB FORMAT 999999
${SIZE_ANALYZE_SQL}"
  DB_COUNTER=0
  INSTANCE_COUNTER=0
  # We need to load all databases even if looking only for one
  # Set grid home
  GRID_HOME=$(find_grid_home)
  #set -x
  while read LINE; do
    CLUSTER_DB_NAMES[$DB_COUNTER]=`echo "$LINE" | cut -f 1`
    CLUSTER_DB_HOMES[$DB_COUNTER]=`echo "$LINE" | cut -f 2`
    CLUSTER_DB_VERSIONS[$DB_COUNTER]=`echo "$LINE" | cut -f 3`
    (( DB_COUNTER++ ))
  done < <($GRID_HOME/bin/srvctl config database -verbose)
  # Find instances
  for count in ${!CLUSTER_DB_NAMES[*]}
  do
    if [ "$INPUT_DATABASE_UNIQUE_NAME" = "" -o "$INPUT_DATABASE_UNIQUE_NAME" = "${CLUSTER_DB_NAMES[$count]}" ]
    then
      while read LINE2; do
        # Now check if INPUT_DB_UNIQUE_NAME is supplied
        CLUSTER_INSTANCE_DB_NAME[$INSTANCE_COUNTER]=${CLUSTER_DB_NAMES[$count]}
        CLUSTER_INSTANCE_DB_ID[$INSTANCE_COUNTER]=$count
        #echo "####"
        DB_FOUND[$count]="NO"
        #echo $LINE2
        CLUSTER_INSTANCE_NAME[$INSTANCE_COUNTER]=`echo "$LINE2" | sed 's/Instance[[:blank:]]*\([^ \t]*\).*/\1/'`
        #echo ${CLUSTER_INSTANCE_NAME[$INSTANCE_COUNTER]}
        CLUSTER_INSTANCE_STATUS[$INSTANCE_COUNTER]=`echo "$LINE2" | sed 's/Instance[[:blank:]]*[^ \t]*[[:blank:]]*is[[:blank:]]*\(.*\)[[:blank:]]on[[:blank:]]node.*/\1/' `
        #echo ${CLUSTER_INSTANCE_STATUS[$INSTANCE_COUNTER]}
        CLUSTER_INSTANCE_HOST[$INSTANCE_COUNTER]=`echo "$LINE2" | sed 's/.*[[:blank:]]\([^\t]*\)$/\1/' `
        #echo ${CLUSTER_INSTANCE_HOST[$INSTANCE_COUNTER]}
        (( INSTANCE_COUNTER++ ))
      done < <(export ORACLE_HOME=${CLUSTER_DB_HOMES[$count]};${CLUSTER_DB_HOMES[$count]}/bin/srvctl status database -d ${CLUSTER_DB_NAMES[$count]})
    fi
  done
  for count in ${!CLUSTER_INSTANCE_DB_ID[@]}
  do
    db_id=${CLUSTER_INSTANCE_DB_ID[$count]}
    #echo "${CLUSTER_INSTANCE_DB_ID[$count]}"
    #echo ${CLUSTER_INSTANCE_STATUS[$count]}
    if [ "${CLUSTER_INSTANCE_STATUS[$count]}" = "running" ]
    then
      if [ "${DB_FOUND[$db_id]}" = "NO" ]
      then
        DB_FOUND[$db_id]="YES"
        #echo "Check DB ${CLUSTER_INSTANCE_DB_NAME[$count]} instance ${CLUSTER_INSTANCE_NAME[$count]} on ${CLUSTER_INSTANCE_HOST[$count]}"
        # Do some work
        PARAMETER_VALUES=`ssh -o 'StrictHostKeyChecking no' ${CLUSTER_INSTANCE_HOST[$count]} "export ORACLE_SID=${CLUSTER_INSTANCE_NAME[$count]}; export ORACLE_HOME=${CLUSTER_DB_HOMES[$db_id]}; echo \"$SIZE_ANALYZE_SQL\"|${CLUSTER_DB_HOMES[$db_id]}/bin/sqlplus -S / as sysdba"`
        if [ "$PARAMETER_VALUES" != "" ]
        then
          echo "$PARAMETER_VALUES"
        fi
      fi
    fi
  done
}

list_pdb()
{
  #set -x
  local INPUT_GUID=$1
  local INPUT_DB_UNIQUE_NAME=$2
  local INPUT_DATA_ONLY=$3
  GET_PDB_GUID_MAPPING_SQL=$(generate_pdb_sql "$INPUT_GUID" "$INPUT_DATA_ONLY")
  #set +x
  DB_COUNTER=0
  INSTANCE_COUNTER=0
  # We need to load all databases even if looking only for one
  # Set grid home
  GRID_HOME=$(find_grid_home)
  #set -x
  while read LINE; do
    CLUSTER_DB_NAMES[$DB_COUNTER]=`echo "$LINE" | cut -f 1`
    CLUSTER_DB_HOMES[$DB_COUNTER]=`echo "$LINE" | cut -f 2`
    CLUSTER_DB_VERSIONS[$DB_COUNTER]=`echo "$LINE" | cut -f 3`
    (( DB_COUNTER++ ))
  done < <($GRID_HOME/bin/srvctl config database -verbose)
  # Find instances
  for count in ${!CLUSTER_DB_NAMES[*]}
  do
    if [ "$INPUT_DB_UNIQUE_NAME" = "" -o "$INPUT_DB_UNIQUE_NAME" = "${CLUSTER_DB_NAMES[$count]}" ]
    then
      while read LINE2; do
        # Now check if INPUT_DB_UNIQUE_NAME is supplied
        CLUSTER_INSTANCE_DB_NAME[$INSTANCE_COUNTER]=${CLUSTER_DB_NAMES[$count]}
        CLUSTER_INSTANCE_DB_ID[$INSTANCE_COUNTER]=$count
        #echo "####"
        DB_FOUND[$count]="NO"
        #echo $LINE2
        CLUSTER_INSTANCE_NAME[$INSTANCE_COUNTER]=`echo "$LINE2" | sed 's/Instance[[:blank:]]*\([^ \t]*\).*/\1/'`
        #echo ${CLUSTER_INSTANCE_NAME[$INSTANCE_COUNTER]}
        CLUSTER_INSTANCE_STATUS[$INSTANCE_COUNTER]=`echo "$LINE2" | sed 's/Instance[[:blank:]]*[^ \t]*[[:blank:]]*is[[:blank:]]*\(.*\)[[:blank:]]on[[:blank:]]node.*/\1/' `
        #echo ${CLUSTER_INSTANCE_STATUS[$INSTANCE_COUNTER]}
        CLUSTER_INSTANCE_HOST[$INSTANCE_COUNTER]=`echo "$LINE2" | sed 's/.*[[:blank:]]\([^\t]*\)$/\1/' `
        #echo ${CLUSTER_INSTANCE_HOST[$INSTANCE_COUNTER]}
        (( INSTANCE_COUNTER++ ))
      done < <(export ORACLE_HOME=${CLUSTER_DB_HOMES[$count]};${CLUSTER_DB_HOMES[$count]}/bin/srvctl status database -d ${CLUSTER_DB_NAMES[$count]})
    fi
  done
  # Get relevant parameters for one of the instances that are active
  if [ "$INPUT_DATA_ONLY" != "YES" ]
  then
    echo "Databaseuniq PDBGUID                          PDB"
  fi
  for count in ${!CLUSTER_INSTANCE_DB_ID[@]}
  do
    db_id=${CLUSTER_INSTANCE_DB_ID[$count]}
    #echo "${CLUSTER_INSTANCE_DB_ID[$count]}"
    #echo ${CLUSTER_INSTANCE_STATUS[$count]}
    if [ "${CLUSTER_INSTANCE_STATUS[$count]}" = "running" ]
    then
      if [ "${DB_FOUND[$db_id]}" = "NO" ]
      then
        DB_FOUND[$db_id]="YES"
        #echo "Check DB ${CLUSTER_INSTANCE_DB_NAME[$count]} instance ${CLUSTER_INSTANCE_NAME[$count]} on ${CLUSTER_INSTANCE_HOST[$count]}"
        # Do some work
        PARAMETER_VALUES=`ssh -o 'StrictHostKeyChecking no' ${CLUSTER_INSTANCE_HOST[$count]} "export ORACLE_SID=${CLUSTER_INSTANCE_NAME[$count]}; export ORACLE_HOME=${CLUSTER_DB_HOMES[$db_id]}; echo \"$GET_PDB_GUID_MAPPING_SQL\"|${CLUSTER_DB_HOMES[$db_id]}/bin/sqlplus -S / as sysdba"`
        if [ "$PARAMETER_VALUES" != "" ]
        then
          echo "$PARAMETER_VALUES"
        fi
      fi
    fi
  done
}

demultiplex_standbylog()
{
  #set -x
  local database_unique_name=$1  
  echo "   INFO: Demultiplex standby logs"
  # Set grid home
  set_grid_home
  # First Check if database exists
  # Find databases Oracle_home
  DB_ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${database_unique_name}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  if [ "$DB_ORACLE_HOME" == "" ]
  then
    # Does not exists as we can't find connected home
    cecho r "  ERROR: Database ${database_unique_name} is not configured on this cluster"
    exit 1
  fi
  status=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name})
  if [ $? -ne 0 ]
  then
    # Does not exists
    cecho r "  ERROR: Database ${database_unique_name} is not configured on this cluster"
    exit 1
  fi
  echo "$status" | grep "is running">/dev/null
  if [ $? -ne 0 ]
  then
    # Does not exists
    cecho r "  ERROR: Database ${database_unique_name} does not have running instances on this cluster"
    exit 2
  fi
  # First find a first node where it exists
  node_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  sid_selected=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")
  # Now delete unessececary standby logs
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$DB_ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"${demultiplex_standby_logs_sql}\" | $DB_ORACLE_HOME/bin/sqlplus -S / as sysdba"  
}

prepare_standby()
{
  #set -x
  local database_unique_name=$1
  local STANDBY_DUPLICATE_NODE=$2  
  echo "   INFO: Prepare database for being used as standby"
  echo "# Find oracle_home etc for database. We only have unique name"
  # Set grid home
  set_grid_home
  # First Check if database exists
  # Find databases Oracle_home
  DB_ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${database_unique_name}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  if [ "$DB_ORACLE_HOME" == "" ]
  then
    # Does not exists as we can't find connected home
    cecho r "  ERROR: Database ${database_unique_name} is not configured on this cluster"
    exit 1
  fi
  status=$(export ORACLE_HOME=$DB_ORACLE_HOME;$DB_ORACLE_HOME/bin/srvctl status database -d ${database_unique_name})
  if [ $? -ne 0 ]
  then
    # Does not exists
    cecho r "  ERROR: Database ${database_unique_name} is not configured on this cluster"
    exit 1
  fi
  echo "$status" | grep "is running">/dev/null
  if [ $? -ne 0 ]
  then
    # Does not exists
    cecho r "  ERROR: Database ${database_unique_name} does not have running instances on this cluster"
    exit 2
  fi
  prepare_as_standby "$database_unique_name" "$STANDBY_DUPLICATE_NODE"  
  #echo "# Check that dataguard configuration is one - also put tis in delete database"
  #echo "# Dump existing rman stuff to some temporary place"
  #echo "# Now call old prepare_as_standby"
  #echo "# reload saved rman settings"
}

prepare_as_standby()
{
  #set -x
  local database_unique_name=$1  
  local STANDBY_DUPLICATE_NODE=$2  
  #echo "$PREPARE_AS_STANDBY"
  # Ensure GRID_ORACLE__HOME is set
  set_grid_home
  # Check that database exists and find Oracle home
  ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${database_unique_name}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
  if [ "$ORACLE_HOME" = "" ]
  then
    cecho r "  ERROR: Can't find database $DATABASE_UNIQUE_NAME on this cluster"
    exit 1
  fi
  # Now we use the value supplied at command line instead instead - NO
  node_selected=${STANDBY_DUPLICATE_NODE}
  # Then find instance on that node - we make sure to find it on that node only
  sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running on node ${node_selected}" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")
  # Then find asm instance on that node
  #asm_sid_selected=$(ssh -o 'StrictHostKeyChecking no' $node_selected "ps -ef | grep pmon_+ASM | grep asm_ | sed -n \"s/.*\\\(+ASM[0123456789][0123456789]*\\\)/\\\1/p\"")
  # GEt the vip on that node (assuming we run grid 12.1
  vip_selected=$(export ORACLE_HOME=${GRID_ORACLE_HOME};$ORACLE_HOME/bin/srvctl config vip -n ${node_selected} | sed -n "s/^VIP Name:[[:space:]]*\(.*\)/\1/p")
  # Get spfile name from ASM - we always have it there
  spfile_name=$(ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"set heading off\nset newpage none\nset feed off\nSELECT value from v\\\$parameter where name = 'spfile';\" | $ORACLE_HOME/bin/sqlplus -s / as sysdba")
  # Get spfile diskgroup
  spfile_disk_group=${spfile_name%%/*}
  #echo "ORACLE_HOME=$ORACLE_HOME"
  #echo "vip_selected=$vip_selected"
  #echo "node_selected=$node_selected"
  #echo "sid_selected=$sid_selected"
  # TBD remove existing data guard configuration!!!!!
  #set -x
#  if [ "$ORACLE_MAJOR_VERSION" == "12" ]
#  then
#    # Password in ASM at nordea for 12 databases, back it up using sudo
#    sudo -u grid /zfssa/tmpwork/asolvang/nddbctl export asmpasswordfile --file=/tmp/pwd${database_unique_name} --databaseUniqueName=${database_unique_name}
#  fi
  # Then enable dataguard broker, create a spfile copy and make database non rac
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"alter system set dg_broker_start=true scope=both;\ncreate pfile='/tmp/pfile${database_unique_name}.ora' from spfile;\nALTER SYSTEM SET CLUSTER_DATABASE=FALSE SCOPE=SPFILE;\n\" | $ORACLE_HOME/bin/sqlplus / as sysdba"
  # Can we delete all archive log files?
  # Shutdown database
  (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl stop database -d ${database_unique_name})
  # On specific node startup in restricted mode
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"startup mount exclusive restrict;\" | $ORACLE_HOME/bin/sqlplus / as sysdba"
  # Use rman to delete evrything
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"DROP DATABASE INCLUDING BACKUPS NOPROMPT;\" | $ORACLE_HOME/bin/rman target /"
  # Shutdown instance
  # NOt needed it's gone
  #ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"shutdown immediate\" | $ORACLE_HOME/bin/sqlplus / as sysdba"
  # Maybe we should load the password file in 12c?

#  if [ "$ORACLE_MAJOR_VERSION" == "12" ]
#  then
#    # Password in ASM at nordea for 12 databases, back it up using sudo
#    sudo -u grid /usr/bin/nddbctl import asmpasswordfile --file=/tmp/pwd${database_unique_name} --databaseUniqueName=${database_unique_name}
#  fi
  # create spfile='${spfile_disk_group}/spfile${database_unique_name}.ora' from pfile='/tmp/pfile${database_unique_name}.ora'; 
  # Now startup the database with pfile and recreste the spfile and shutdown again and startup mount
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"startup nomount pfile='/tmp/pfile${database_unique_name}.ora';\ncreate spfile='${spfile_disk_group}/${DATABASE_UNIQUE_NAME}/spfile${DATABASE_UNIQUE_NAME}.ora' from pfile='/tmp/pfile${DATABASE_UNIQUE_NAME}.ora';\nshutdown immediate;\nstartup nomount;\" | $ORACLE_HOME/bin/sqlplus / as sysdba"
  # As s final step modify the cluster repository to let it know it's now a standby database
  (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl modify database -d ${database_unique_name}  -r 'PHYSICAL_STANDBY' )
  echo "When running ndtnsctl on primary cluster use \"--remoteNodeVip $vip_selected \""
  echo "or --standbyVip if using the nddbctl command."
  echo "$ORACLE_SID is now running in nomount mode on $node_selected and is ready for rman"
  echo "to create the standby database"
}

#mkdir +S008OED_DATA/z9989t1o/PASSWORD
#pwcopy --dbuniquename z9989t1o  /u01/app/oracle/product/12.2.0.1/db200114a/dbs/orapwz9989t1o  +S008OED_DATA/z9989t1o/PASSWORD/orapwz9989t1o
#srvctl modify database -db z9989t1o -pwfile '+S008OED_DATA/z9989t1o/PASSWORD/pwdz9989t1o.301.1035371787'
# maybe
#orapwd file='+S008OED_DATA/z9988t1o/PASSWORD/orapwz9988t1o' dbuniquename='z9988t1o'

create_database()
{
  ###SR 3-20154033281 start ####################
  # This some steps to avoid problems reported in the service request below 
  # SR 3-20154033281 : Starting a RAC database don't - always - start the services for the databases
  # Find Grid home
  #set -x
  local GRID_ORACLE_HOME=$(find_grid_home)
  # Find scan dns name
  local SCAN_DNS_NETWORK_1=$(${GRID_ORACLE_HOME}/bin/srvctl config scan -netnum 1| sed -n "s/SCAN name:[[:space:]]*\([^, ]*\).*/\1/p")
  # Find port
  local SCAN_PORT_NETWORK_1=$(${GRID_ORACLE_HOME}/bin/srvctl config scan_listener -scannumber 1 | sed -n "s/.*\(Port\|Endpoints\):[[:space:]]*TCP:\(.*\)/\2/p" )
  if [ "$SCAN_DNS_NETWORK_1" != "" -a "$SCAN_PORT_NETWORK_1" != "" ]
  then
    # set the remote_listener
    REMOTE_LISTENER_PARAMETER="remote_listener='${SCAN_DNS_NETWORK_1}:${SCAN_PORT_NETWORK_1}',"
    echo "   INFO: Will set $REMOTE_LISTENER_PARAMETER. Remove this when SR 3-20154033281 is solved"
  else
    cecho p "WARNING: Can't get data about scan listener SCAN_DNS_NETWORK_1=$SCAN_DNS_NETWORK_1, SCAN_PORT_NETWORK_1=$SCAN_PORT_NETWORK_1. Wont set remote_listener"
  fi
  ###SR 3-20154033281 end ####################  
  create_database_dbca
  if [ $? -ne 0 ]
  then
    cecho r "  ERROR: dbca failed"
    exit 1
  fi
  # Some of the following wont work unless we do this
  export ORACLE_HOME=$ORACLE_HOME;
  # If using clustered TNS_ADMIN then set this in the cluster configuration for the given database
  if [ "$USING_SHARED_TNS_ADMIN" == "Y" ]
  then
    echo "   INFO: Setting TNS_ADMIN in cluster registry to ${CLUSTERED_TNS_ADMIN} "
    ${ORACLE_HOME}/bin/srvctl setenv database -d $DATABASE_UNIQUE_NAME -T TNS_ADMIN=${CLUSTERED_TNS_ADMIN}
    echo "   INFO: Setting dependency to /clustershare and /u01/app/oracle/diag"
    ${ORACLE_HOME}/bin/srvctl modify database -d $DATABASE_UNIQUE_NAME  -acfspath "/clustershare,/u01/app/oracle/diag"
  fi
  #set -x
  # Let's add an extra controlfile and ensure that the  audit_trail is correct
  # First find a node where it's configured
  node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${DATABASE_UNIQUE_NAME} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")  # update audit_trail
  # update audit_trail
  update_audit_trail_sql="alter system set audit_trail=${AUDIT_TRAIL} scope=spfile sid='*';
exit;"
  # Open up some sys user accounts and set passwords to be the "correct ones"
  open_sys_accounts="alter user sysdg identified by StoreP8tterErFodbold;
alter user sysdg identified by values '$SYSDG_PASSWORD';
alter user sysdg account unlock;
alter user sysbackup identified by StoreP8tterErFodbold;
alter user sysbackup identified by values '$SYSBACKUP_PASSWORD';
alter user sysbackup account unlock;
grant sysbackup to sysbackup container=all;
alter user syskm identified by StoreP8tterErFodbold;
alter user syskm identified by values '$SYSKM_PASSWORD';
alter user syskm account unlock;
alter user dbsnmp identified by StoreP8tterErFodbold;
alter user dbsnmp identified by values '$DBSNMP_PASSWORD';
alter user dbsnmp account unlock;
alter user sys identified by StoreP8tterErFodbold;
alter user sys identified by values '$SYS_PASSWORD';
alter user system identified by StoreP8tterErFodbold;
alter user system identified by values '$SYSTEM_PASSWORD';
exit;"
  # First if we run NONRAC ensure password file is in ASM
  if [ "${ORACLE_INSTANCE_TYPE}" == 'SINGLE' ]
  then
    echo "   INFO: Stop cluster database"
    $ORACLE_HOME/bin/srvctl stop database -d $DATABASE_UNIQUE_NAME
    echo "   INFO: Recreating Passwd file in ASM"
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_SID=${sid_selected}; export ORACLE_HOME=${ORACLE_HOME};${ORACLE_HOME}/bin/orapwd file='+${ASM_DATA_DISK_GROUP}/${DATABASE_UNIQUE_NAME}/PASSWORD/orapw${DATABASE_UNIQUE_NAME}' dbuniquename='${DATABASE_UNIQUE_NAME}' input_file=${ORACLE_HOME}/dbs/orapw${DATABASE_UNIQUE_NAME}"
    if [ $? -eq 0 ]
    then
      echo "   INFO: Deleting file based passwd file $ORACLE_HOME/dbs/orapw${DATABASE_UNIQUE_NAME} on $node "
      ssh -o 'StrictHostKeyChecking no' $node_selected "rm $ORACLE_HOME/dbs/orapw${DATABASE_UNIQUE_NAME}"
    else
      echo "WARNING: recreating Passwd file in ASM failed "      
    fi    
    echo "   INFO: Start cluster database"
    $ORACLE_HOME/bin/srvctl start database -d $DATABASE_UNIQUE_NAME
  fi
  echo "   INFO: Update audit_trail"
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_SID=${sid_selected}; export ORACLE_HOME=${ORACLE_HOME}; echo \"${update_audit_trail_sql}\"|${ORACLE_HOME}/bin/sqlplus -S / as sysdba"
  echo "   INFO: Open up some users (sysdg,syskm,sysbackup)"
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_SID=${sid_selected}; export ORACLE_HOME=${ORACLE_HOME}; echo \"${open_sys_accounts}\"|${ORACLE_HOME}/bin/sqlplus -S / as sysdba"
  # find the control files
  select_control_files_sql="set heading off
set feedback off
select name from v\\\$controlfile;
exit;"
  CONTROL_FILES_FOUND=`ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_SID=${sid_selected}; export ORACLE_HOME=${ORACLE_HOME}; echo \"${select_control_files_sql}\"|${ORACLE_HOME}/bin/sqlplus -S / as sysdba"`
  found_control_files=0
  for control_file_found in $CONTROL_FILES_FOUND
  do
    ((found_control_files++))
  done
  if [ $found_control_files -eq 1 ]
  then
    echo "   INFO: Need to fix control files as there is only one defined. We will add one in disk group used for data"
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"alter system set control_files='${control_file_found}','+${ASM_DATA_DISK_GROUP}' scope=spfile sid='*';\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba"
    # Then stop the database
    echo "   INFO: Stop cluster database"
    $ORACLE_HOME/bin/srvctl stop database -d $DATABASE_UNIQUE_NAME
    # Start in nomount mode
    echo "   INFO: Start instance in nomount mode"
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"startup nomount;\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba"
    # Use rman to create copy
    echo "   INFO: Use RMAN to restore the newly added controlfile"
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"restore controlfile from '${control_file_found}'; \" | $ORACLE_HOME/bin/rman target /"
    # Shutdown
    echo "   INFO: Stop instance"
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"shutdown immediate;\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba"
    # Then start again
    echo "   INFO: Start cluster database"
    $ORACLE_HOME/bin/srvctl start database -d $DATABASE_UNIQUE_NAME
  else
    # Just restart the damm thing as the rest does not work well otherwise sometimes
    # First stop
    echo "   INFO: Stop cluster database"
    $ORACLE_HOME/bin/srvctl stop database -d $DATABASE_UNIQUE_NAME
    # Then start again
    echo "   INFO: Start cluster database"
    $ORACLE_HOME/bin/srvctl start database -d $DATABASE_UNIQUE_NAME
  fi
  if [ "${ORACLE_INSTANCE_TYPE}" == 'SINGLE' ]
  then
    # Single instance
    # Create and start the "database name" service:
    $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME} -l primary
    $ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}
    # Create the read only service on the standby (to be prepared)
    $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}_ro -l physical_standby
    # Start/stop the ro service as that sometimes seems to be needed for it to work later in a dataguard configuration
    $ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}_ro
    $ORACLE_HOME/bin/srvctl stop service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}_ro
    # Give variable to be printed later some meaningfull values
    RUN_INSTANCE_FOR_APP_SERVICE="${sid_selected}"
    RUN_INSTANCES="${sid_selected}"
    RUN_ON_NODES="${node_selected}"
    CLUSTER_NODES="${node_selected}"
  else
    #RAC
    # Find all database instances
    DATABASE_INSTANCES=`$ORACLE_HOME/bin/srvctl config database -d $DATABASE_UNIQUE_NAME |  sed -n 's/^Database instance\(s\)\{0,1\}:\(.*\)/\2/p'`
    # Find instances we want to run on
    # and the ones we "don't" want to run on
    # Now check if we want the instance to be "on"
    for database_instance in ${DATABASE_INSTANCES//,/ }
    do
      # Find the node the instance run on
      # First if we run NONRAC 
      instance_on_node=`$ORACLE_HOME/bin/srvctl status instance -d $DATABASE_UNIQUE_NAME -i $database_instance |  sed -n "s/.*running on node \(.*\)/\1/p"`
      # is it the one we want to run the app service on?
      if [ "$instance_on_node" = "$RUN_NODE_FOR_APP_SERVICE" ]
      then
        # We want to run on it 
        RUN_INSTANCE_FOR_APP_SERVICE=$database_instance
      else
        # Add it to apps avail list
        if [ "$AVAIL_INSTANCE_FOR_APP_SERVICE" = "" ]
        then
          AVAIL_INSTANCE_FOR_APP_SERVICE="$database_instance"
        else
          AVAIL_INSTANCE_FOR_APP_SERVICE="$AVAIL_INSTANCE_FOR_APP_SERVICE,$database_instance"
        fi
      fi      
      # IS it one of the nodes where we want an instance to run?
      node_found="N"
      for run_node in ${RUN_ON_NODES//,/ }
      do
        if [ "$instance_on_node" = "$run_node" ]
        then
        	node_found="Y"
        fi
      done
      if [ "$node_found" = "N" ]
      then
        # We want not to run on it add to comma separated list
        if [ "$AVAIL_INSTANCES" = "" ]
        then
          AVAIL_INSTANCES="$database_instance"
        else
          AVAIL_INSTANCES="$AVAIL_INSTANCES,$database_instance"
        fi
      else
        # We want to run on it add to comma separated list
        if [ "$RUN_INSTANCES" = "" ]
        then
          RUN_INSTANCES="$database_instance"
        else
          RUN_INSTANCES="$RUN_INSTANCES,$database_instance"
        fi
      fi  
    done
    # Create services
    echo "Creating services"
    if [ "$CREATE_AS_CONTAINER" = "YES" ]
    then  
      # Start on all configured nodes as it's an container database
      if [ -z "${AVAIL_INSTANCES}" ]
      then
        # No avail_instances, start on all nodes
        # Create and start the "database name" service:
        $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME} -r $RUN_INSTANCES -l primary
      else
        # avail instances are present, start on the ones we selected
        # Create and start the "database name" service:
        $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME} -r $RUN_INSTANCES -a $AVAIL_INSTANCES -l primary
      fi
    else
      # Start on only one node as it's a regular db - not container db
      if [ -z "${AVAIL_INSTANCE_FOR_APP_SERVICE}" ]
      then
        # No AVAIL_INSTANCE_FOR_APP_SERVICE is avaialable
        # Create the normal service on the primary (to be prepared) on one of the instances (can later be changed to all if the App supports it)
        $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME} -r $RUN_INSTANCE_FOR_APP_SERVICE -l primary
      else
        # AVAIL_INSTANCE_FOR_APP_SERVICE is available
        # Create the normal service on the primary (to be prepared) on one of the instances (can later be changed to all if the App supports it)
        $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME} -r $RUN_INSTANCE_FOR_APP_SERVICE -a $AVAIL_INSTANCE_FOR_APP_SERVICE -l primary
      fi
    fi
    if [ -z "${AVAIL_INSTANCES}" ]
    then
      # No avail_instances
    #  # Create and start the Rman service:
    #  $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s rman_${DATABASE_UNIQUE_NAME} -r $RUN_INSTANCES -l primary,physical_standby
      # Create the read only service on the standby (to be prepared)
      $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}_ro -r $RUN_INSTANCES -l physical_standby
    else
      # avail instances are present
    #  # Create and start the Rman service:
    #  $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s rman_${DATABASE_UNIQUE_NAME} -r $RUN_INSTANCES -a $AVAIL_INSTANCES -l primary,physical_standby
    #  # Start/stop the service as that sometimes seems to be needed for it to work later in a dataguard configuration
    #  $ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s rman_${DATABASE_UNIQUE_NAME}
    #  $ORACLE_HOME/bin/srvctl stop service -d $DATABASE_UNIQUE_NAME -s rman_${DATABASE_UNIQUE_NAME}    
      # Create the read only service on the standby (to be prepared)
      $ORACLE_HOME/bin/srvctl add service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}_ro -r $RUN_INSTANCES -a $AVAIL_INSTANCES -l physical_standby
    fi  
    # Start/stop the ro service as that sometimes seems to be needed for it to work later in a dataguard configuration
    $ORACLE_HOME/bin/srvctl start service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}_ro
    $ORACLE_HOME/bin/srvctl stop service -d $DATABASE_UNIQUE_NAME -s ${DATABASE_NAME}_ro    
  fi
  if [ "${ORACLE_INSTANCE_TYPE}" != 'SINGLE' ]
  then
    # The final steps for RAC databases
    # First stop
    echo "Stop database"
    $ORACLE_HOME/bin/srvctl stop database -d $DATABASE_UNIQUE_NAME
    echo "Configuring which instances to enable"
    # Disable all the instances
    $ORACLE_HOME/bin/srvctl disable instance -d $DATABASE_UNIQUE_NAME -i $DATABASE_INSTANCES
    # Enable instances we want active
    $ORACLE_HOME/bin/srvctl enable instance -d $DATABASE_UNIQUE_NAME -i $RUN_INSTANCES
    # Then start again
    echo "Starting database"
    $ORACLE_HOME/bin/srvctl start database -d $DATABASE_UNIQUE_NAME
  fi
  # make sure services are registred immediately
  snapshot_services "$DATABASE_UNIQUE_NAME" "$ORACLE_HOME"
  # Save some info for later
  create_database_report
  # Print a little report
  echo "-------------------Database created---------------------"
  echo "            Database Name: $DATABASE_NAME"
  echo "     Database Unique Name: $DATABASE_UNIQUE_NAME"
  echo "             Characterset: $CHARACTERSET"
  echo "    National Characterset: $NATIONAL_CHARACTERSET"
  echo "     NLS Length Semantics: $NLS_LENGTH_SEMANTICS"
  echo "   Database runs on nodes: $RUN_ON_NODES"
  echo "Database defined on nodes: $CLUSTER_NODES"
  echo "             Service name: $DATABASE_NAME runs on instance(s) $RUN_INSTANCE_FOR_APP_SERVICE when database is primary"
  echo "             Service name: ${DATABASE_NAME}_ro runs on instance(s) $RUN_INSTANCES when database is physical standby"
  echo "     Services on database:`$ORACLE_HOME/bin/srvctl config database -d $DATABASE_UNIQUE_NAME | sed -n 's/^Services:\(.*\)/\1/p'`" 
  echo "        Grid cluster name: $GRID_CLUSTER_NAME"
  echo "         Nodes in cluster: $CLUSTER_NODES"
  echo "      ASM DATA disk group: $ASM_DATA_DISK_GROUP"
  echo "      ASM RECO disk group: $ASM_RECO_DISK_GROUP"
  echo "Logs for this creation in: ${LOG_DIRECTORY}_$(convert_to_lower ${DATABASE_UNIQUE_NAME})"
}


export_asmpasswordfile()
{
  #set -x
  echo "Not Tested, will probably not work when ASM is running FLEX - has to fix that"
  exit 99
  local database_unique_name=$1
  local file=$2
  export ORACLE_HOME=$GRID_ORACLE_HOME
  export ORACLE_SID=$GRID_ASM_INSTANCE
  # asm_passsword_asm=$(ssh -o 'StrictHostKeyChecking no' $node_selected export ORACLE_HOME=${GRID_ORACLE_HOME};export ORACLE_SID=${asm_sid_selected};$GRID_ORACLE_HOME/bin/asmcmd pwget --dbuniquename wfp1c )
  asm_passsword_asm=$(${ORACLE_HOME}/bin/asmcmd pwget --dbuniquename ${database_unique_name})    
  #+DATAC1/WFP1C/PASSWORD/pwdwfp1c.535.932897113
  ${ORACLE_HOME}/bin/asmcmd pwcopy ${asm_passsword_asm} ${file}
  #copying +DATAC1/WFP1C/PASSWORD/pwdwfp1c.535.932897113 -> /tmp/pwdwfp1c
}

import_asmpasswordfile()
{
  #set -x
  echo "Not Tested, will probably not work when ASM is running FLEX - has to fix that"
  exit 99
  local database_unique_name=$1
  local file=$2
  local disk_group=$3
  export ORACLE_HOME=$GRID_ORACLE_HOME
  export ORACLE_SID=$GRID_ASM_INSTANCE
  ${ORACLE_HOME}/bin/asmcmd  pwcopy $file ${disk_group}/${database_unique_name}/orapw${database_unique_name}
  srvctl modify database -d STDBYDB -pwfile ${disk_group}/${database_unique_name}/orapw${database_unique_name}
  # Password file for 12c
  # srvctl modify asm -pwfile location
  # srvctl modify database -db dbname -pwfile location    
}

distribute_passwordfile()
{
  local database_unique_name=$1
  # Find Oracle home
  local ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${database_unique_name}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  # Passwordfile is then in $ORACLE_HOME/dbs/orapw<instance_name> we dont now the last characters (0-99)
  #scp /u01/app/oracle/product/11.2.0.4/db160419a/dbs/orapwds002p1c1 dm16db02:/u01/app/oracle/product/11.2.0.4/db160419a/dbs/orapwds002p1c2
  # First loop over all nodes and find the instance that is there
  local instance_node
  local instance
  local node
  local instance_nodes="$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | sed -e "s/Instance[[:space:]]*\(.*\)[[:space:]]is[[:space:]]*.*node[[:space:]]\(.*\)/\1:\2/")"
  #set -x
  while read -r instance_node; do
    instance=${instance_node%:*}
    node=${instance_node#*:}
    #echo "instance_node=$instance_node"
    #echo "instance=$instance"
    #echo "node=$node"
    ssh -o 'StrictHostKeyChecking no' n $node "[ -f $ORACLE_HOME/dbs/orapw${instance} ]"
    if [ $? -eq 0 ]
    then
      echo "   INFO: Getting $node $ORACLE_HOME/dbs/orapw${instance}"
      scp -q $node:$ORACLE_HOME/dbs/orapw${instance} /tmp
    fi
  done <<< "$instance_nodes"
  # now figure out which one differs from the others, this will be the new one
  declare -A diff_counter
  local node_with_most
  local instance_with_most
  local max_difference_found=0
  local number_of_nodes=0
  local file_to_copy=""
  while read -r instance_node; do
    (( number_of_nodes++ ))
    instance=${instance_node%:*}
    node=${instance_node#*:}
    diff_counter[$node]=0
    #echo "instance_node=$instance_node"
    #echo "instance=$instance"
    #echo "node=$node"
    while read -r instance_node2; do
      instance2=${instance_node2%:*}
      node1=${instance_node2#*:}
      #echo "cmp /tmp/orapw${instance} /tmp/orapw${instance2}"
      cmp -s /tmp/orapw${instance} /tmp/orapw${instance2} || ((diff_counter[$node]++ ))
    done  <<< "$instance_nodes"
    echo "   INFO: Password file on $node differs from ${diff_counter[$node]} other passwords files"
    if [ ${diff_counter[$node]} -gt $max_difference_found ]
    then
      # New top
      max_difference_found=${diff_counter[$node]}
      node_with_most=$node
      instance_with_most=$instance
    fi
  done <<< "$instance_nodes"
  #echo "Node with most difference=$node_with_most"
  #echo "Max difference=$max_difference_found"
  #echo "Number of nodes= ${number_of_nodes}"
  if [ $max_difference_found -eq 0 ]
  then
    cecho r "  ERROR: No single host has a password files that differ, exact one should be different"
    exit 1
  fi
  if (( max_difference_found + 1 != number_of_nodes  ))
  then
    cecho r "  ERROR: More that one password file is different, don't kow which one to pick"
    exit 1
  fi
  while read -r instance_node; do
    instance=${instance_node%:*}
    node=${instance_node#*:}
    #echo "instance_node=$instance_node"
    #echo "instance=$instance"
    #echo "node=$node"
    ssh -o 'StrictHostKeyChecking no' n $node "[ -f $ORACLE_HOME/dbs/orapw${instance} ]"
    if [ $? -eq 0 ]
    then
      if [ "$$node_with_most" != "$node" ]
      then
        echo "   INFO: Updating $node $ORACLE_HOME/dbs/orapw${instance}"
        scp -q /tmp/orapw${instance_with_most} $node:$ORACLE_HOME/dbs/orapw${instance}
      fi
    fi
  done <<< "$instance_nodes"  
}

finish_standby()
{
  local database_unique_name=$1
  local standby_database_unique_name=$2
  local sys_password=$3
  local switch_over=$4  
  # Find the GRID ORACLE_HOME (maybe check it's not empty
  #GRID_ORACLE_HOME=$(find_grid_home)
  get_environment_names
  ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${database_unique_name}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
  if [ "$ORACLE_HOME" = "" ]
  then
    cecho r "  ERROR: Can't find database $database_unique_name on this cluster"
    exit 1
  fi
  # First find a first node where a running instance is
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")
  # Then find database name
  local database_name=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl config database -d ${database_unique_name} |  sed -n "s/Database name:[[:space:]]*\(.*\)[[:space:]]*.*$/\1/p")
  # Now delete unessececary standby logs
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"${demultiplex_standby_logs_sql}\" | $ORACLE_HOME/bin/sqlplus -S / as sysdba"  
  # Then set rman "right"
  make_backup_directories_etc $database_unique_name
  # Create snapshot of srvctl config services
  snapshot_services "$database_unique_name" "$ORACLE_HOME" "$sys_password" "$standby_database_unique_name"
  # Then Switch back
  DGMGRL_COMMANDS="connect sys/${sys_password}
   switchover to ${standby_database_unique_name};
   exit"
  DGMGRL_COMMANDS_READ_ONLY="connect sys/${sys_password}
   startup open read only;
   exit;"
  if [ "$switch_over" = "YES" ]
  then
    # On specific node run dgmgrl script
    echo "Will switchover to ${standby_database_unique_name}"
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${DGMGRL_COMMANDS}\" | $ORACLE_HOME/bin/dgmgrl"
    # We stop and start the database to be able to open it read only mode so active data guard will work
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl stop database -d $database_unique_name)
    # But then make sure database is open read only at least we try
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${DGMGRL_COMMANDS_READ_ONLY}\" | $ORACLE_HOME/bin/dgmgrl"
    # MAke sure all instances are started - maybe not needed
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl stop database -d $database_unique_name>/dev/null)
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl start database -d $database_unique_name -startoption open>/dev/null)
  else
    echo "Skiping switchover to ${standby_database_unique_name}"
  fi
}

duplicate_standby()
{
  local database_unique_name=$1
  local standby_database_unique_name=$2
  local sys_password=$3
  local switch_over=$4
  # Find the GRID ORACLE_HOME (maybe check it's not empty
  #GRID_ORACLE_HOME=$(find_grid_home)
  get_environment_names
  ORACLE_HOME=$($GRID_ORACLE_HOME/bin/srvctl config database -v | sed -n "s/${database_unique_name}[[:blank:]]*\(.*\)[[:blank:]].*/\1/p")
  if [ "$ORACLE_HOME" = "" ]
  then
    cecho r "  ERROR: Cam't find database $database_unique_name on this cluster"
    exit 1
  fi
  # First find a first node where a running instance is
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")
  # Then find database name
  local database_name=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl config database -d ${database_unique_name} |  sed -n "s/Database name:[[:space:]]*\(.*\)[[:space:]]*.*$/\1/p")
  #set -x
  RMAN_COMMANDS="connect target sys/${sys_password}
  connect auxiliary sys/${sys_password}@${standby_database_unique_name}_dup
  CONFIGURE SNAPSHOT CONTROLFILE NAME TO '+${ASM_DATA_DISK_GROUP}/${database_unique_name}/CONTROLFILE/snapcf_${database_unique_name}.f' ;
  run {
    allocate channel prmy1 type disk;
    allocate channel prmy2 type disk;
    allocate channel prmy3 type disk;
    allocate channel prmy4 type disk;
    allocate auxiliary channel stby type disk;
    duplicate target database for standby from active database;
  }  
  exit;"
  # On specific node run rman script
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${RMAN_COMMANDS}\" | $ORACLE_HOME/bin/rman"
  # Had issues with this in below command
  # edit database ${database_unique_name} set property applyinstances='ALL';
  # edit database ${standby_database_unique_name} set property applyinstances='ALL';   
  DGMGRL_COMMANDS_SETUP="connect sys/${sys_password}
   create configuration ${database_name} as primary database is ${database_unique_name} connect identifier is ${database_unique_name};
   add database ${standby_database_unique_name} as connect identifier is ${standby_database_unique_name} maintained as physical;
   enable configuration;
   exit;"
  DGMGRL_COMMANDS_SWITCH="connect sys/${sys_password}
   -- Wait before we switch
   ! sleep 120
   switchover to ${standby_database_unique_name};
   exit;"
  DGMGRL_COMMANDS_READ_ONLY="connect sys/${sys_password}
   startup open read only;
   exit;"
  # On specific node run dgmgrl script
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${DGMGRL_COMMANDS_SETUP}\" | $ORACLE_HOME/bin/dgmgrl"
  if [ "$switch_over" = "YES" ]
  then   
    echo "Will switchover to ${standby_database_unique_name}"
    # On specific node run dgmgrl script
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${DGMGRL_COMMANDS_SWITCH}\" | $ORACLE_HOME/bin/dgmgrl"
    # We stop and start the database to be able to open it read only mode so active data guard will work
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl stop database -d $database_unique_name)
    # But then make sure database is open read only at least we try
    ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo \"${DGMGRL_COMMANDS_READ_ONLY}\" | $ORACLE_HOME/bin/dgmgrl"
    # MAke sure all instances are started - maybe not needed
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl stop database -d $database_unique_name >/dev/null)
    (export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl start database -d $database_unique_name -startoption open>/dev/null)
    echo "########################## Post configuration start #########################"
    echo "1) Run the following command on a node in the standby cluster"
    cecho r "   nddbctl finish standby --databaseUniqueName ${standby_database_unique_name} --standbyDatabaseUniqueName ${database_unique_name} -switchOver"
    echo "########################## Post configuration end ###########################"
  else
    echo "Skiping switchover to ${standby_database_unique_name}"
  fi
}

prepare_primary()
{
  GRID_ORACLE_HOME=$(find_grid_home)
  local database_unique_name=$1
  local ORACLE_HOME=$($GRID_ORACLE_HOME/bin/crsctl status resource ora.${database_unique_name}.db -f | sed -n -e "s/ORACLE_HOME=\(.*\)/\1/p")
  echo "   INFO: Preparing for standby by enabling data guard broker and creating missing standby logs"
  # First find a first node where a running instance is
  local node_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/.*node[[:space:]]*\(.*\)$/\1/p")
  # Then find instance on that node
  local sid_selected=$(export ORACLE_HOME=$ORACLE_HOME;$ORACLE_HOME/bin/srvctl status database -d ${database_unique_name} | grep "is running" | head -1 | sed -n "s/Instance[[:space:]]*\(.*\)[[:space:]]*is[[:space:]]*.*$/\1/p")
  ssh -o 'StrictHostKeyChecking no' $node_selected "export ORACLE_HOME=$ORACLE_HOME;export ORACLE_SID=$sid_selected; echo -e \"${prepare_primary_sql}\" | $ORACLE_HOME/bin/sqlplus -s / as sysdba"
  # Now print out what to do next
  echo "########################## Post configuration start #########################"
  echo "1) First ensure that you have run the command that creates a standby \"ready\""
  echo "   database on the standby site. This will be a command like the one you have just run" 
  echo "   except that you use the --prepareAsStandby option instead of --prepareAsPrimary."
  echo "   When this is successfully done you can continue with step 2."
  echo "2) Run the following command on a node on the primary cluster f.x. the node you are on now"
  cecho g "   nddbctl duplicate standby --databaseUniqueName ${database_unique_name} --standbyDatabaseUniqueName ${STANDBY_DATABASE_UNIQUE_NAME}"
  echo "   When this is successfully done you can continue with step 3."
  echo "3) Follow the post configuration steps given in the above comand's output"
  echo "########################## Post configuration end ###########################"
  #echo "########################## Post configuration start #########################"
  #echo "1) Login as oracle on a primary host where an active instance ($RUN_ON_NODES)."
  #echo "   Ensure you have proper environment. (if you get \"ORACLE_HOME set but not" 
  #echo "   ORACLE_SID\" you are on a wrong node. Run:"
  #cecho g "   oe ${database_unique_name}"
  #echo "2) start rman:"
  #cecho g "   rman"
  #echo "3) Run the following rman commands one by one - you should know the passwords:"
  #cecho g "   connect target sys"
  #cecho g "   connect auxiliary sys@${STANDBY_DATABASE_UNIQUE_NAME}_dup"
  #echo "4) After ensuring you are properly logged in on both databases now run the"
  #echo "   following rman script:"
  #echo "   ########### rman script start"
  #cecho g "   CONFIGURE SNAPSHOT CONTROLFILE NAME TO '+${ASM_DATA_DISK_GROUP}/${database_unique_name}/CONTROLFILE/snapcf_${database_unique_name}.f' ;"
  #cecho g "   run {"
  #cecho g "     allocate channel prmy1 type disk;"
  #cecho g "     allocate channel prmy2 type disk;"
  #cecho g "     allocate channel prmy3 type disk;"
  #cecho g "     allocate channel prmy4 type disk;"
  #cecho g "     allocate auxiliary channel stby type disk;"
  #cecho g "     duplicate target database for standby from active database;"
  ##cecho g "     DB_FILE_NAME_CONVERT ('+${ASM_DATA_DISK_GROUP}/${database_unique_name}/','+${STANDBY_ASM_DATA_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/','+${ASM_RECO_DISK_GROUP}/${database_unique_name}/','+${STANDBY_ASM_RECO_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/');"
  #cecho g "   }"
  #echo "   ########### rman script end"
  #echo "5) When finished then exit rman:"
  #cecho g "   exit"
  #echo "6) start dgmgrl:"
  #cecho g "   dgmgrl"
  #echo "7) Run the following dgmgrl command - you should know the password:"
  #cecho g "   connect sysdg"
  #echo "8) After ensuring you are properly logged in run the following dgmgrl commands."
  #echo "   You can ignore the need to restart errors on 12c databases, as we will do that:"
  #echo "   ########### dgmgrl commands start"
  #cecho g "   create configuration ${DATABASE_NAME} as primary database is ${database_unique_name} connect identifier is ${database_unique_name};"
  #cecho g "   add database ${STANDBY_DATABASE_UNIQUE_NAME} as connect identifier is ${STANDBY_DATABASE_UNIQUE_NAME} maintained as physical;"
  ##cecho g "   edit database ${STANDBY_DATABASE_UNIQUE_NAME} set property dbFileNameConvert ='+${ASM_DATA_DISK_GROUP}/${database_unique_name}/,+${STANDBY_ASM_DATA_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/,+${ASM_RECO_DISK_GROUP}/${database_unique_name}/,+${STANDBY_ASM_RECO_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/';"
  ##cecho g "   edit database ${database_unique_name} set property dbFileNameConvert ='+${ASM_DATA_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/,+${STANDBY_ASM_DATA_DISK_GROUP}/${database_unique_name}/,+${ASM_RECO_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/,+${STANDBY_ASM_RECO_DISK_GROUP}/${database_unique_name}/';"
  ##cecho g "   edit database ${STANDBY_DATABASE_UNIQUE_NAME} set property logFileNameConvert ='+${ASM_DATA_DISK_GROUP}/${database_unique_name}/,+${STANDBY_ASM_DATA_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/,+${ASM_RECO_DISK_GROUP}/${database_unique_name}/,+${STANDBY_ASM_RECO_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/';"
  ##cecho g "   edit database ${database_unique_name} set property logFileNameConvert ='+${ASM_DATA_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/,+${STANDBY_ASM_DATA_DISK_GROUP}/${database_unique_name}/,+${ASM_RECO_DISK_GROUP}/${STANDBY_DATABASE_UNIQUE_NAME}/,+${STANDBY_ASM_RECO_DISK_GROUP}/${database_unique_name}/';"
  #cecho g "   enable configuration;"  
  #echo "   ########### dgmgrl commands end"
  #echo "9) exit dgmgrl"
  #cecho g "   exit"
  #echo "10) As oracle on the standby host with an active instance (the VIP is"
  #echo "   ${STANDBY_VIP}) ensure you have proper environment. (if you get " 
  #echo "   \"ORACLE_HOME set but not ORACLE_SID\" you are on a wrong node. Run:"
  #cecho r "   oe ${STANDBY_DATABASE_UNIQUE_NAME}"
  #if [ "$ORACLE_MAJOR_VERSION" = "11.2" ]
  #then
  #  echo "10.1) As we are creating an an 11.2.x database we have passwords in password"
  #  echo "   files. We need to copy the password file from the standby node where we"
  #  echo "   have the standby vip running (${STANDBY_VIP}) to the other nodes."
  #  echo "   You run the following from any standby host to do that:"
  #  cecho r "   nddbctl distribute passwordfile --databaseUniqueName ${STANDBY_DATABASE_UNIQUE_NAME}"
  #fi
  #echo "11) Restart the standby database from a standby node to ensure everything"
  #echo "   works after a total restart"
  #cecho r "   srvctl stop database -d ${STANDBY_DATABASE_UNIQUE_NAME}"
  #cecho r "   srvctl start database -d ${STANDBY_DATABASE_UNIQUE_NAME}"
  #echo "12) Go back to a primary node and restart the primary database to ensure"
  #echo "   everything works after a total restart"
  #cecho g "   srvctl stop database -d ${database_unique_name}"
  #cecho g "   srvctl start database -d ${database_unique_name}"
  #echo "13) To verify that things are working and to clean up multiplexed standby"
  #echo "   logs we need to switchover to standby"
  #echo "   start the dataguard manager:"
  #cecho g "   dgmgrl"
  #echo "   Run the following dataguard manager command - you should know the password:"
  #cecho g "   connect sysdg"
  #echo "   Do the switchover to the standby database"
  #cecho g "   switchover to ${STANDBY_DATABASE_UNIQUE_NAME};"
  #echo "14) Now delete the extra multiplexed set of standby logs in the standby database"
  #echo "   from a login on the standby node"
  #cecho r "   nddbctl demultiplex standbylog --databaseUniqueName ${STANDBY_DATABASE_UNIQUE_NAME}"
  #echo "15) Now switch back the database to have the primary database running on the"
  #echo "   original cluster and to test that it works"
  #echo "   start the dataguard manager:"
  #cecho r "   dgmgrl"
  #echo "   Run the following dataguard manager command - you should know the password:"
  #cecho r "   connect sysdg"
  #cecho r "   switchover to ${database_unique_name};"
  #echo "########################## Post configuration end ###########################"
}


create_standby_tns()
{
  echo "   INFO: Create standby tns"
  ndtnsctl addorupdate tnsconf --entries local,remote,static  --databaseUniqueName ${DATABASE_UNIQUE_NAME}  --remoteDatabaseUniqueName ${PRIMARY_DATABASE_UNIQUE_NAME} --remoteScanListener ${PRIMARY_SCAN_LISTENER}
}

create_primary_tns()
{
  echo "   INFO: Create primary tns"
  ndtnsctl addorupdate tnsconf --entries local,remote,static,duplicate  --databaseUniqueName ${DATABASE_UNIQUE_NAME}  --remoteDatabaseUniqueName ${STANDBY_DATABASE_UNIQUE_NAME} --remoteScanListener ${STANDBY_SCAN_LISTENER} --remoteNodeVip ${STANDBY_VIP}
}
#
# handle_request
#
# Purpose: handles the request after arguments have been analyzed checked
#
handle_request()
{
  #echo $OBJECT,$ACTION
  #get_environment_names
  case $OBJECT in
    pdb)
      case $ACTION in
        setresources)
          setresources_pdb "$PDB_NAME" "$DATABASE_UNIQUE_NAME" "$USE_SGA_MEMORY_PROFILE" "$USE_CPU_COUNT_PROFILE" "$USE_STORAGE_CAPACITY_PROFILE" "$USE_STORAGE_IOPS_PROFILE" "$USE_STORAGE_BANDWIDTH_PROFILE"              
          ;;
        check)
          check_pdb "$INPUT_DATABASE_UNIQUE_NAME" "$INPUT_PDB_NAME" "$INPUT_CHECKS" "$INPUT_TRY_FIX"
          ;;
        list)
          list_pdb "$INPUT_GUID" "$INPUT_DB_UNIQUE_NAME" "$INPUT_DATA_ONLY"
          ;;
        create)
          create_pdb "$PDB_NAME" "$PDB_SERVICE" "$PDB_SERVICE_RO" "$DATABASE_UNIQUE_NAME" "$ORACLE_HOME" "$USE_SGA_MEMORY_PROFILE" "$USE_CPU_COUNT_PROFILE" "$USE_STORAGE_CAPACITY_PROFILE" "$USE_STORAGE_IOPS_PROFILE" "$USE_STORAGE_BANDWIDTH_PROFILE" "$PDB_PREFERRED_INSTANCES" "$PDB_AVAILABLE_INSTANCES" "$PDB_ADMIN_HASH_PASSWORD" "$PDB_PLUG_FILE" "$PDB_NLS_LENGTH_SEMANTICS" "$PDB_PREPARE_FOR_MIGRATION" "$PDB_ADMIN_SERVICE" "$PDB_STANDBYS"             
          ;;
        delete)
          delete_pdb "$PDB_NAME" "$DATABASE_UNIQUE_NAME" "$ORACLE_HOME"             
          ;;
        harden)
          harden_pdb "$PDB_NAME" "$DATABASE_UNIQUE_NAME" "$ORACLE_HOME" "$PDB_FIX_STATIC_GRANTS"            
          ;;
        dgfinish)
          dgfinish_pdb "$PDB_NAME" "$DATABASE_UNIQUE_NAME" "$PRIMARY_TNS_SERVICE_NAME" "$PDB_PRIMARY_SERVICE_NAME" "$PDB_STANDBY_SERVICE_NAME" "$PDB_PREFERRED_INSTANCES" "$PDB_AVAILABLE_INSTANCES" "$PDB_RECOVERY_STATUS" "$PDB_ADMIN_SERVICE"             
          ;;
      esac
      ;;
    stdpdbservices)
      case $ACTION in
        create)
          create_stdpdbservices "$DATABASE_UNIQUE_NAME","$USE_NODES","$PDB_PRIMARY_SERVICE_NAME","$PDB_STANDBY_SERVICE_NAME"
          ;;
      esac
      ;;
    plugfile)
      case $ACTION in
        create)
          create_plugfile "$INPUT_DATABASE_UNIQUE_NAME" "$INPUT_PDB_NAME" "$INPUT_PDB_PLUG_FILE"
          ;;
      esac
      ;;
    standby)
      case $ACTION in
        status)
          status_standby "$INPUT_DATABASE_UNIQUE_NAME_REGEX"
          ;;
        prepatch)
          prepatch_standby "$DATABASE_UNIQUE_NAME" "$NEW_ORACLE_HOME" "$DRY_RUN" "$VERBOSE"
          ;;
        postpatch)
          postpatch_standby "$DATABASE_UNIQUE_NAME" "$DRY_RUN" "$DONT_RELOAD_LISTENER" "$VERBOSE"
          ;;
        prepare)
          prepare_standby "$DATABASE_UNIQUE_NAME" "$STANDBY_DUPLICATE_NODE"
          ;;
        duplicate)
          duplicate_standby "$INPUT_DATABASE_UNIQUE_NAME" "$INPUT_STANDBY_DATABASE_UNIQUE_NAME" "$INPUT_SYS_PASSWORD" "$INPUT_SWITCH_OVER"
          ;;
        finish)
          finish_standby "$INPUT_DATABASE_UNIQUE_NAME" "$INPUT_STANDBY_DATABASE_UNIQUE_NAME" "$INPUT_SYS_PASSWORD" "$INPUT_SWITCH_OVER"
          ;;
      esac
      ;;
    rman)
      case $ACTION in
        prepare)
          prepare_rman "$DATABASE_UNIQUE_NAME"
          ;;
      esac
      ;;
    services)
      case $ACTION in
        create)
          create_services "$PDB_NAME" "$DATABASE_UNIQUE_NAME" "$IS_PRIMARY_DATABASE" "$PDB_PRIMARY_SERVICE_NAME" "$PDB_STANDBY_SERVICE_NAME" "$PDB_PREFERRED_INSTANCES" "$PDB_AVAILABLE_INSTANCES" "$PDB_RECOVERY_STATUS" "$PDB_ADMIN_SERVICE"             
          ;;
        delete)
          delete_services "$PDB_NAME" "$DATABASE_UNIQUE_NAME" "$ORACLE_HOME"             
          ;;
        snapshot)
          snapshot_services "$INPUT_DATABASE_UNIQUE_NAME" "$ORACLE_HOME"             
          ;;
      esac
      ;;
    standbylog)
      case $ACTION in
        demultiplex)
          demultiplex_standbylog "$DATABASE_UNIQUE_NAME" 
          ;;
      esac
      ;;
    primary)
      case $ACTION in
        patch)
          patch_primary "$DATABASE_UNIQUE_NAME" "$NEW_ORACLE_HOME" "$DRY_RUN" "$DONT_RELOAD_LISTENER" "$VERBOSE"
          ;;
        prepare)
          prepare_primary "$DATABASE_UNIQUE_NAME" 
          ;;
      esac
      ;;
    passwordfile)
      case $ACTION in
        distribute)
          distribute_passwordfile "$DATABASE_UNIQUE_NAME"
          ;;
      esac
      ;;
    asmpasswordfile)
      case $ACTION in
        export)
          export_asmpasswordfile "$DATABASE_UNIQUE_NAME" "$IMPORT_EXPORT_FILE"
          ;;
        import)
          import_asmpasswordfile "$DATABASE_UNIQUE_NAME" "$IMPORT_EXPORT_FILE" "$IMPORT_DISK_GROUP"
          ;;
      esac
      ;;          
    database)
      case $ACTION in
        setresources)
          setresources_database "$DATABASE_UNIQUE_NAME" "$USE_SGA_MEMORY_PROFILE" "$USE_CPU_COUNT_PROFILE" "$USE_STORAGE_CAPACITY_PROFILE" "$USE_STORAGE_IOPS_PROFILE" "$USE_STORAGE_BANDWIDTH_PROFILE"              
          ;;
        create)
          create_database_build_environment_names
          create_database
          make_backup_directories_etc "$DATABASE_UNIQUE_NAME" "$STANDBY_DATABASE_UNIQUE_NAME"
          if [ "$PREPARE_AS_STANDBY" = "YES" ]
          then
            prepare_as_standby "$DATABASE_UNIQUE_NAME" "$STANDBY_DUPLICATE_NODE"
            if [ "$PRIMARY_SCAN_LISTENER" != "" -a "" != "$PRIMARY_DATABASE_UNIQUE_NAME" -a "$INPUT_SKIP_TNS" != "YES" ]
            then
              create_standby_tns
            fi
          fi
          if [ "$PREPARE_AS_PRIMARY" = "YES" ]
          then
            prepare_primary "$DATABASE_UNIQUE_NAME"
            if [ "$STANDBY_SCAN_LISTENER" != "" -a "" != "$STANDBY_DATABASE_UNIQUE_NAME" -a "" != "$STANDBY_VIP" -a "$INPUT_SKIP_TNS" != "YES" ]
            then
              create_primary_tns
            fi            
          fi
          ;;
        delete)
          delete_database "$DATABASE_UNIQUE_NAME" "$SHUTDOWN_DATABASE" "$INCLUDING_BACKUP";;
        switchover)
          switchover_database "$INPUT_DATABASE_UNIQUE_NAME" "$INPUT_SYS_PASSWORD" "$INPUT_IGNORE_TESTS" "$INPUT_MAX_TRANSPORT_LAG" "$INPUT_MAX_APPLY_LAG" "$INPUT_AUTO_FIX" "$INPUT_DRY_RUN";;
      esac
      ;;
  esac
}
# Ok do the stuff
parse_arguments $*

# We still need to check arguments even better
# Ok guess we are kind of ready now to build database

handle_request

